# Project: specification

## Directory Structure

```
ðŸ“ specification
â”œâ”€â”€ ðŸ“ 2024-11-05
â”‚   â”œâ”€â”€ ðŸ“ architecture
â”‚   â”‚   â””â”€â”€ ðŸ“„ index.mdx
â”‚   â”œâ”€â”€ ðŸ“ basic
â”‚   â”‚   â”œâ”€â”€ ðŸ“ utilities
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ cancellation.mdx
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ ping.mdx
â”‚   â”‚   â”‚   â””â”€â”€ ðŸ“„ progress.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ index.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ lifecycle.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ messages.mdx
â”‚   â”‚   â””â”€â”€ ðŸ“„ transports.mdx
â”‚   â”œâ”€â”€ ðŸ“ client
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ roots.mdx
â”‚   â”‚   â””â”€â”€ ðŸ“„ sampling.mdx
â”‚   â”œâ”€â”€ ðŸ“ server
â”‚   â”‚   â”œâ”€â”€ ðŸ“ utilities
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ completion.mdx
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ logging.mdx
â”‚   â”‚   â”‚   â””â”€â”€ ðŸ“„ pagination.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ index.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ prompts.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ resource-picker.png
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ resources.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ slash-command.png
â”‚   â”‚   â””â”€â”€ ðŸ“„ tools.mdx
â”‚   â””â”€â”€ ðŸ“„ index.mdx
â”œâ”€â”€ ðŸ“ 2025-03-26
â”‚   â”œâ”€â”€ ðŸ“ architecture
â”‚   â”‚   â””â”€â”€ ðŸ“„ index.mdx
â”‚   â”œâ”€â”€ ðŸ“ basic
â”‚   â”‚   â”œâ”€â”€ ðŸ“ utilities
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ cancellation.mdx
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ ping.mdx
â”‚   â”‚   â”‚   â””â”€â”€ ðŸ“„ progress.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ authorization.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ index.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ lifecycle.mdx
â”‚   â”‚   â””â”€â”€ ðŸ“„ transports.mdx
â”‚   â”œâ”€â”€ ðŸ“ client
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ roots.mdx
â”‚   â”‚   â””â”€â”€ ðŸ“„ sampling.mdx
â”‚   â”œâ”€â”€ ðŸ“ server
â”‚   â”‚   â”œâ”€â”€ ðŸ“ utilities
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ completion.mdx
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ logging.mdx
â”‚   â”‚   â”‚   â””â”€â”€ ðŸ“„ pagination.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ index.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ prompts.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ resource-picker.png
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ resources.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ slash-command.png
â”‚   â”‚   â””â”€â”€ ðŸ“„ tools.mdx
â”‚   â”œâ”€â”€ ðŸ“„ changelog.mdx
â”‚   â””â”€â”€ ðŸ“„ index.mdx
â”œâ”€â”€ ðŸ“ 2025-06-18
â”‚   â”œâ”€â”€ ðŸ“ architecture
â”‚   â”‚   â””â”€â”€ ðŸ“„ index.mdx
â”‚   â”œâ”€â”€ ðŸ“ basic
â”‚   â”‚   â”œâ”€â”€ ðŸ“ utilities
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ cancellation.mdx
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ ping.mdx
â”‚   â”‚   â”‚   â””â”€â”€ ðŸ“„ progress.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ authorization.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ index.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ lifecycle.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ security_best_practices.mdx
â”‚   â”‚   â””â”€â”€ ðŸ“„ transports.mdx
â”‚   â”œâ”€â”€ ðŸ“ client
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ elicitation.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ roots.mdx
â”‚   â”‚   â””â”€â”€ ðŸ“„ sampling.mdx
â”‚   â”œâ”€â”€ ðŸ“ server
â”‚   â”‚   â”œâ”€â”€ ðŸ“ utilities
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ completion.mdx
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ logging.mdx
â”‚   â”‚   â”‚   â””â”€â”€ ðŸ“„ pagination.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ index.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ prompts.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ resource-picker.png
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ resources.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ slash-command.png
â”‚   â”‚   â””â”€â”€ ðŸ“„ tools.mdx
â”‚   â”œâ”€â”€ ðŸ“„ changelog.mdx
â”‚   â””â”€â”€ ðŸ“„ index.mdx
â”œâ”€â”€ ðŸ“ draft
â”‚   â”œâ”€â”€ ðŸ“ architecture
â”‚   â”‚   â””â”€â”€ ðŸ“„ index.mdx
â”‚   â”œâ”€â”€ ðŸ“ basic
â”‚   â”‚   â”œâ”€â”€ ðŸ“ utilities
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ cancellation.mdx
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ ping.mdx
â”‚   â”‚   â”‚   â””â”€â”€ ðŸ“„ progress.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ authorization.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ index.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ lifecycle.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ security_best_practices.mdx
â”‚   â”‚   â””â”€â”€ ðŸ“„ transports.mdx
â”‚   â”œâ”€â”€ ðŸ“ client
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ elicitation.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ roots.mdx
â”‚   â”‚   â””â”€â”€ ðŸ“„ sampling.mdx
â”‚   â”œâ”€â”€ ðŸ“ server
â”‚   â”‚   â”œâ”€â”€ ðŸ“ utilities
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ completion.mdx
â”‚   â”‚   â”‚   â”œâ”€â”€ ðŸ“„ logging.mdx
â”‚   â”‚   â”‚   â””â”€â”€ ðŸ“„ pagination.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ index.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ prompts.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ resource-picker.png
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ resources.mdx
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ slash-command.png
â”‚   â”‚   â””â”€â”€ ðŸ“„ tools.mdx
â”‚   â”œâ”€â”€ ðŸ“„ changelog.mdx
â”‚   â””â”€â”€ ðŸ“„ index.mdx
â””â”€â”€ ðŸ“„ versioning.mdx
```

------------------------------------------------------------

## File Contents

--- START OF FILE 2024-11-05/architecture/index.mdx ---
---
title: Architecture
---

The Model Context Protocol (MCP) follows a client-host-server architecture where each
host can run multiple client instances. This architecture enables users to integrate AI
capabilities across applications while maintaining clear security boundaries and
isolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused
on context exchange and sampling coordination between clients and servers.

## Core Components

```mermaid
graph LR
    subgraph "Application Host Process"
        H[Host]
        C1[Client 1]
        C2[Client 2]
        C3[Client 3]
        H --> C1
        H --> C2
        H --> C3
    end

    subgraph "Local machine"
        S1[Server 1<br>Files & Git]
        S2[Server 2<br>Database]
        R1[("Local<br>Resource A")]
        R2[("Local<br>Resource B")]

        C1 --> S1
        C2 --> S2
        S1 <--> R1
        S2 <--> R2
    end

    subgraph "Internet"
        S3[Server 3<br>External APIs]
        R3[("Remote<br>Resource C")]

        C3 --> S3
        S3 <--> R3
    end
```

### Host

The host process acts as the container and coordinator:

- Creates and manages multiple client instances
- Controls client connection permissions and lifecycle
- Enforces security policies and consent requirements
- Handles user authorization decisions
- Coordinates AI/LLM integration and sampling
- Manages context aggregation across clients

### Clients

Each client is created by the host and maintains an isolated server connection:

- Establishes one stateful session per server
- Handles protocol negotiation and capability exchange
- Routes protocol messages bidirectionally
- Manages subscriptions and notifications
- Maintains security boundaries between servers

A host application creates and manages multiple clients, with each client having a 1:1
relationship with a particular server.

### Servers

Servers provide specialized context and capabilities:

- Expose resources, tools and prompts via MCP primitives
- Operate independently with focused responsibilities
- Request sampling through client interfaces
- Must respect security constraints
- Can be local processes or remote services

## Design Principles

MCP is built on several key design principles that inform its architecture and
implementation:

1. **Servers should be extremely easy to build**

   - Host applications handle complex orchestration responsibilities
   - Servers focus on specific, well-defined capabilities
   - Simple interfaces minimize implementation overhead
   - Clear separation enables maintainable code

2. **Servers should be highly composable**

   - Each server provides focused functionality in isolation
   - Multiple servers can be combined seamlessly
   - Shared protocol enables interoperability
   - Modular design supports extensibility

3. **Servers should not be able to read the whole conversation, nor "see into" other
   servers**

   - Servers receive only necessary contextual information
   - Full conversation history stays with the host
   - Each server connection maintains isolation
   - Cross-server interactions are controlled by the host
   - Host process enforces security boundaries

4. **Features can be added to servers and clients progressively**
   - Core protocol provides minimal required functionality
   - Additional capabilities can be negotiated as needed
   - Servers and clients evolve independently
   - Protocol designed for future extensibility
   - Backwards compatibility is maintained

## Message Types

MCP defines three core message types based on
[JSON-RPC 2.0](https://www.jsonrpc.org/specification):

- **Requests**: Bidirectional messages with method and parameters expecting a response
- **Responses**: Successful results or errors matching specific request IDs
- **Notifications**: One-way messages requiring no response

Each message type follows the JSON-RPC 2.0 specification for structure and delivery
semantics.

## Capability Negotiation

The Model Context Protocol uses a capability-based negotiation system where clients and
servers explicitly declare their supported features during initialization. Capabilities
determine which protocol features and primitives are available during a session.

- Servers declare capabilities like resource subscriptions, tool support, and prompt
  templates
- Clients declare capabilities like sampling support and notification handling
- Both parties must respect declared capabilities throughout the session
- Additional capabilities can be negotiated through extensions to the protocol

```mermaid
sequenceDiagram
    participant Host
    participant Client
    participant Server

    Host->>+Client: Initialize client
    Client->>+Server: Initialize session with capabilities
    Server-->>Client: Respond with supported capabilities

    Note over Host,Server: Active Session with Negotiated Features

    loop Client Requests
        Host->>Client: User- or model-initiated action
        Client->>Server: Request (tools/resources)
        Server-->>Client: Response
        Client-->>Host: Update UI or respond to model
    end

    loop Server Requests
        Server->>Client: Request (sampling)
        Client->>Host: Forward to AI
        Host-->>Client: AI response
        Client-->>Server: Response
    end

    loop Notifications
        Server--)Client: Resource updates
        Client--)Server: Status changes
    end

    Host->>Client: Terminate
    Client->>-Server: End session
    deactivate Server
```

Each capability unlocks specific protocol features for use during the session. For
example:

- Implemented [server features](/specification/2024-11-05/server) must be
  advertised in the server's capabilities
- Emitting resource subscription notifications requires the server to declare
  subscription support
- Tool invocation requires the server to declare tool capabilities
- [Sampling](/specification/2024-11-05/client) requires the client to
  declare support in its capabilities

This capability negotiation ensures clients and servers have a clear understanding of
supported functionality while maintaining protocol extensibility.

--- END OF FILE 2024-11-05/architecture/index.mdx ---


--- START OF FILE 2024-11-05/basic/utilities/cancellation.mdx ---
---
title: Cancellation
weight: 10
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol (MCP) supports optional cancellation of in-progress requests
through notification messages. Either side can send a cancellation notification to
indicate that a previously-issued request should be terminated.

## Cancellation Flow

When a party wants to cancel an in-progress request, it sends a `notifications/cancelled`
notification containing:

- The ID of the request to cancel
- An optional reason string that can be logged or displayed

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/cancelled",
  "params": {
    "requestId": "123",
    "reason": "User requested cancellation"
  }
}
```

## Behavior Requirements

1. Cancellation notifications **MUST** only reference requests that:
   - Were previously issued in the same direction
   - Are believed to still be in-progress
2. The `initialize` request **MUST NOT** be cancelled by clients
3. Receivers of cancellation notifications **SHOULD**:
   - Stop processing the cancelled request
   - Free associated resources
   - Not send a response for the cancelled request
4. Receivers **MAY** ignore cancellation notifications if:
   - The referenced request is unknown
   - Processing has already completed
   - The request cannot be cancelled
5. The sender of the cancellation notification **SHOULD** ignore any response to the
   request that arrives afterward

## Timing Considerations

Due to network latency, cancellation notifications may arrive after request processing
has completed, and potentially after a response has already been sent.

Both parties **MUST** handle these race conditions gracefully:

```mermaid
sequenceDiagram
   participant Client
   participant Server

   Client->>Server: Request (ID: 123)
   Note over Server: Processing starts
   Client--)Server: notifications/cancelled (ID: 123)
   alt
      Note over Server: Processing may have<br/>completed before<br/>cancellation arrives
   else If not completed
      Note over Server: Stop processing
   end
```

## Implementation Notes

- Both parties **SHOULD** log cancellation reasons for debugging
- Application UIs **SHOULD** indicate when cancellation is requested

## Error Handling

Invalid cancellation notifications **SHOULD** be ignored:

- Unknown request IDs
- Already completed requests
- Malformed notifications

This maintains the "fire and forget" nature of notifications while allowing for race
conditions in asynchronous communication.

--- END OF FILE 2024-11-05/basic/utilities/cancellation.mdx ---


--- START OF FILE 2024-11-05/basic/utilities/ping.mdx ---
---
title: Ping
weight: 5
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol includes an optional ping mechanism that allows either party
to verify that their counterpart is still responsive and the connection is alive.

## Overview

The ping functionality is implemented through a simple request/response pattern. Either
the client or server can initiate a ping by sending a `ping` request.

## Message Format

A ping request is a standard JSON-RPC request with no parameters:

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "method": "ping"
}
```

## Behavior Requirements

1. The receiver **MUST** respond promptly with an empty response:

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {}
}
```

2. If no response is received within a reasonable timeout period, the sender **MAY**:
   - Consider the connection stale
   - Terminate the connection
   - Attempt reconnection procedures

## Usage Patterns

```mermaid
sequenceDiagram
    participant Sender
    participant Receiver

    Sender->>Receiver: ping request
    Receiver->>Sender: empty response
```

## Implementation Considerations

- Implementations **SHOULD** periodically issue pings to detect connection health
- The frequency of pings **SHOULD** be configurable
- Timeouts **SHOULD** be appropriate for the network environment
- Excessive pinging **SHOULD** be avoided to reduce network overhead

## Error Handling

- Timeouts **SHOULD** be treated as connection failures
- Multiple failed pings **MAY** trigger connection reset
- Implementations **SHOULD** log ping failures for diagnostics

--- END OF FILE 2024-11-05/basic/utilities/ping.mdx ---


--- START OF FILE 2024-11-05/basic/utilities/progress.mdx ---
---
title: Progress
weight: 30
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol (MCP) supports optional progress tracking for long-running
operations through notification messages. Either side can send progress notifications to
provide updates about operation status.

## Progress Flow

When a party wants to _receive_ progress updates for a request, it includes a
`progressToken` in the request metadata.

- Progress tokens **MUST** be a string or integer value
- Progress tokens can be chosen by the sender using any means, but **MUST** be unique
  across all active requests.

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "some_method",
  "params": {
    "_meta": {
      "progressToken": "abc123"
    }
  }
}
```

The receiver **MAY** then send progress notifications containing:

- The original progress token
- The current progress value so far
- An optional "total" value

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/progress",
  "params": {
    "progressToken": "abc123",
    "progress": 50,
    "total": 100
  }
}
```

- The `progress` value **MUST** increase with each notification, even if the total is
  unknown.
- The `progress` and the `total` values **MAY** be floating point.

## Behavior Requirements

1. Progress notifications **MUST** only reference tokens that:

   - Were provided in an active request
   - Are associated with an in-progress operation

2. Receivers of progress requests **MAY**:
   - Choose not to send any progress notifications
   - Send notifications at whatever frequency they deem appropriate
   - Omit the total value if unknown

```mermaid
sequenceDiagram
    participant Sender
    participant Receiver

    Note over Sender,Receiver: Request with progress token
    Sender->>Receiver: Method request with progressToken

    Note over Sender,Receiver: Progress updates
    loop Progress Updates
        Receiver-->>Sender: Progress notification (0.2/1.0)
        Receiver-->>Sender: Progress notification (0.6/1.0)
        Receiver-->>Sender: Progress notification (1.0/1.0)
    end

    Note over Sender,Receiver: Operation complete
    Receiver->>Sender: Method response
```

## Implementation Notes

- Senders and receivers **SHOULD** track active progress tokens
- Both parties **SHOULD** implement rate limiting to prevent flooding
- Progress notifications **MUST** stop after completion

--- END OF FILE 2024-11-05/basic/utilities/progress.mdx ---


--- START OF FILE 2024-11-05/basic/index.mdx ---
---
title: Overview
---

<Info>**Protocol Revision**: 2024-11-05</Info>

All messages between MCP clients and servers **MUST** follow the
[JSON-RPC 2.0](https://www.jsonrpc.org/specification) specification. The protocol defines
three fundamental types of messages:

| Type            | Description                            | Requirements                           |
| --------------- | -------------------------------------- | -------------------------------------- |
| `Requests`      | Messages sent to initiate an operation | Must include unique ID and method name |
| `Responses`     | Messages sent in reply to requests     | Must include same ID as request        |
| `Notifications` | One-way messages with no reply         | Must not include an ID                 |

**Responses** are further sub-categorized as either **successful results** or **errors**.
Results can follow any JSON object structure, while errors must include an error code and
message at minimum.

## Protocol Layers

The Model Context Protocol consists of several key components that work together:

- **Base Protocol**: Core JSON-RPC message types
- **Lifecycle Management**: Connection initialization, capability negotiation, and
  session control
- **Server Features**: Resources, prompts, and tools exposed by servers
- **Client Features**: Sampling and root directory lists provided by clients
- **Utilities**: Cross-cutting concerns like logging and argument completion

All implementations **MUST** support the base protocol and lifecycle management
components. Other components **MAY** be implemented based on the specific needs of the
application.

These protocol layers establish clear separation of concerns while enabling rich
interactions between clients and servers. The modular design allows implementations to
support exactly the features they need.

See the following pages for more details on the different components:

<CardGroup cols={3}>
  <Card
    title="Lifecycle"
    icon="arrows-rotate"
    href="/specification/2024-11-05/basic/lifecycle"
  />
  <Card
    title="Resources"
    icon="file-lines"
    href="/specification/2024-11-05/server/resources"
  />
  <Card
    title="Prompts"
    icon="message"
    href="/specification/2024-11-05/server/prompts"
  />
  <Card
    title="Tools"
    icon="wrench"
    href="/specification/2024-11-05/server/tools"
  />
  <Card
    title="Logging"
    icon="rectangle-list"
    href="/specification/2024-11-05/server/utilities/logging"
  />
  <Card
    title="Sampling"
    icon="code"
    href="/specification/2024-11-05/client/sampling"
  />
</CardGroup>

## Auth

Authentication and authorization are not currently part of the core MCP specification,
but we are considering ways to introduce them in future. Join us in
[GitHub Discussions](https://github.com/modelcontextprotocol/specification/discussions)
to help shape the future of the protocol!

Clients and servers **MAY** negotiate their own custom authentication and authorization
strategies.

## Schema

The full specification of the protocol is defined as a
[TypeScript schema](http://github.com/modelcontextprotocol/specification/tree/main/schema/2024-11-05/schema.ts).
This is the source of truth for all protocol messages and structures.

There is also a
[JSON Schema](http://github.com/modelcontextprotocol/specification/tree/main/schema/2024-11-05/schema.json),
which is automatically generated from the TypeScript source of truth, for use with
various automated tooling.

--- END OF FILE 2024-11-05/basic/index.mdx ---


--- START OF FILE 2024-11-05/basic/lifecycle.mdx ---
---
title: Lifecycle
type: docs
weight: 30
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol (MCP) defines a rigorous lifecycle for client-server
connections that ensures proper capability negotiation and state management.

1. **Initialization**: Capability negotiation and protocol version agreement
2. **Operation**: Normal protocol communication
3. **Shutdown**: Graceful termination of the connection

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Initialization Phase
    activate Client
    Client->>+Server: initialize request
    Server-->>Client: initialize response
    Client--)Server: initialized notification

    Note over Client,Server: Operation Phase
    rect rgb(200, 220, 250)
        note over Client,Server: Normal protocol operations
    end

    Note over Client,Server: Shutdown
    Client--)-Server: Disconnect
    deactivate Server
    Note over Client,Server: Connection closed
```

## Lifecycle Phases

### Initialization

The initialization phase **MUST** be the first interaction between client and server.
During this phase, the client and server:

- Establish protocol version compatibility
- Exchange and negotiate capabilities
- Share implementation details

The client **MUST** initiate this phase by sending an `initialize` request containing:

- Protocol version supported
- Client capabilities
- Client implementation information

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "roots": {
        "listChanged": true
      },
      "sampling": {}
    },
    "clientInfo": {
      "name": "ExampleClient",
      "version": "1.0.0"
    }
  }
}
```

The server **MUST** respond with its own capabilities and information:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "logging": {},
      "prompts": {
        "listChanged": true
      },
      "resources": {
        "subscribe": true,
        "listChanged": true
      },
      "tools": {
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "ExampleServer",
      "version": "1.0.0"
    }
  }
}
```

After successful initialization, the client **MUST** send an `initialized` notification
to indicate it is ready to begin normal operations:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized"
}
```

- The client **SHOULD NOT** send requests other than
  [pings](/specification/2024-11-05/basic/utilities/ping) before the server
  has responded to the `initialize` request.
- The server **SHOULD NOT** send requests other than
  [pings](/specification/2024-11-05/basic/utilities/ping) and
  [logging](/specification/2024-11-05/server/utilities/logging) before
  receiving the `initialized` notification.

#### Version Negotiation

In the `initialize` request, the client **MUST** send a protocol version it supports.
This **SHOULD** be the _latest_ version supported by the client.

If the server supports the requested protocol version, it **MUST** respond with the same
version. Otherwise, the server **MUST** respond with another protocol version it
supports. This **SHOULD** be the _latest_ version supported by the server.

If the client does not support the version in the server's response, it **SHOULD**
disconnect.

#### Capability Negotiation

Client and server capabilities establish which optional protocol features will be
available during the session.

Key capabilities include:

| Category | Capability     | Description                                                                         |
| -------- | -------------- | ----------------------------------------------------------------------------------- |
| Client   | `roots`        | Ability to provide filesystem [roots](/specification/2024-11-05/client/roots)       |
| Client   | `sampling`     | Support for LLM [sampling](/specification/2024-11-05/client/sampling) requests      |
| Client   | `experimental` | Describes support for non-standard experimental features                            |
| Server   | `prompts`      | Offers [prompt templates](/specification/2024-11-05/server/prompts)                 |
| Server   | `resources`    | Provides readable [resources](/specification/2024-11-05/server/resources)           |
| Server   | `tools`        | Exposes callable [tools](/specification/2024-11-05/server/tools)                    |
| Server   | `logging`      | Emits structured [log messages](/specification/2024-11-05/server/utilities/logging) |
| Server   | `experimental` | Describes support for non-standard experimental features                            |

Capability objects can describe sub-capabilities like:

- `listChanged`: Support for list change notifications (for prompts, resources, and
  tools)
- `subscribe`: Support for subscribing to individual items' changes (resources only)

### Operation

During the operation phase, the client and server exchange messages according to the
negotiated capabilities.

Both parties **SHOULD**:

- Respect the negotiated protocol version
- Only use capabilities that were successfully negotiated

### Shutdown

During the shutdown phase, one side (usually the client) cleanly terminates the protocol
connection. No specific shutdown messages are definedâ€”instead, the underlying transport
mechanism should be used to signal connection termination:

#### stdio

For the stdio [transport](/specification/2024-11-05/basic/transports), the
client **SHOULD** initiate shutdown by:

1. First, closing the input stream to the child process (the server)
2. Waiting for the server to exit, or sending `SIGTERM` if the server does not exit
   within a reasonable time
3. Sending `SIGKILL` if the server does not exit within a reasonable time after `SIGTERM`

The server **MAY** initiate shutdown by closing its output stream to the client and
exiting.

#### HTTP

For HTTP [transports](/specification/2024-11-05/basic/transports), shutdown
is indicated by closing the associated HTTP connection(s).

## Error Handling

Implementations **SHOULD** be prepared to handle these error cases:

- Protocol version mismatch
- Failure to negotiate required capabilities
- Initialize request timeout
- Shutdown timeout

Implementations **SHOULD** implement appropriate timeouts for all requests, to prevent
hung connections and resource exhaustion.

Example initialization error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Unsupported protocol version",
    "data": {
      "supported": ["2024-11-05"],
      "requested": "1.0.0"
    }
  }
}
```

--- END OF FILE 2024-11-05/basic/lifecycle.mdx ---


--- START OF FILE 2024-11-05/basic/messages.mdx ---
---
title: Messages
type: docs
weight: 20
---

<Info>**Protocol Revision**: 2024-11-05</Info>

All messages in MCP **MUST** follow the
[JSON-RPC 2.0](https://www.jsonrpc.org/specification) specification. The protocol defines
three types of messages:

## Requests

Requests are sent from the client to the server or vice versa.

```typescript
{
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

- Requests **MUST** include a string or integer ID.
- Unlike base JSON-RPC, the ID **MUST NOT** be `null`.
- The request ID **MUST NOT** have been previously used by the requestor within the same
  session.

## Responses

Responses are sent in reply to requests.

```typescript
{
  jsonrpc: "2.0";
  id: string | number;
  result?: {
    [key: string]: unknown;
  }
  error?: {
    code: number;
    message: string;
    data?: unknown;
  }
}
```

- Responses **MUST** include the same ID as the request they correspond to.
- Either a `result` or an `error` **MUST** be set. A response **MUST NOT** set both.
- Error codes **MUST** be integers.

## Notifications

Notifications are sent from the client to the server or vice versa. They do not expect a
response.

```typescript
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

- Notifications **MUST NOT** include an ID.

--- END OF FILE 2024-11-05/basic/messages.mdx ---


--- START OF FILE 2024-11-05/basic/transports.mdx ---
---
title: Transports
type: docs
weight: 40
---

<Info>**Protocol Revision**: 2024-11-05</Info>

MCP currently defines two standard transport mechanisms for client-server communication:

1. [stdio](#stdio), communication over standard in and standard out
2. [HTTP with Server-Sent Events](#http-with-sse) (SSE)

Clients **SHOULD** support stdio whenever possible.

It is also possible for clients and servers to implement
[custom transports](#custom-transports) in a pluggable fashion.

## stdio

In the **stdio** transport:

- The client launches the MCP server as a subprocess.
- The server receives JSON-RPC messages on its standard input (`stdin`) and writes
  responses to its standard output (`stdout`).
- Messages are delimited by newlines, and **MUST NOT** contain embedded newlines.
- The server **MAY** write UTF-8 strings to its standard error (`stderr`) for logging
  purposes. Clients **MAY** capture, forward, or ignore this logging.
- The server **MUST NOT** write anything to its `stdout` that is not a valid MCP message.
- The client **MUST NOT** write anything to the server's `stdin` that is not a valid MCP
  message.

```mermaid
sequenceDiagram
    participant Client
    participant Server Process

    Client->>+Server Process: Launch subprocess
    loop Message Exchange
        Client->>Server Process: Write to stdin
        Server Process->>Client: Write to stdout
        Server Process--)Client: Optional logs on stderr
    end
    Client->>Server Process: Close stdin, terminate subprocess
    deactivate Server Process
```

## HTTP with SSE

In the **SSE** transport, the server operates as an independent process that can handle
multiple client connections.

#### Security Warning

When implementing HTTP with SSE transport:

1. Servers **MUST** validate the `Origin` header on all incoming connections to prevent DNS rebinding attacks
2. When running locally, servers **SHOULD** bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)
3. Servers **SHOULD** implement proper authentication for all connections

Without these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.

The server **MUST** provide two endpoints:

1. An SSE endpoint, for clients to establish a connection and receive messages from the
   server
2. A regular HTTP POST endpoint for clients to send messages to the server

When a client connects, the server **MUST** send an `endpoint` event containing a URI for
the client to use for sending messages. All subsequent client messages **MUST** be sent
as HTTP POST requests to this endpoint.

Server messages are sent as SSE `message` events, with the message content encoded as
JSON in the event data.

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: Open SSE connection
    Server->>Client: endpoint event
    loop Message Exchange
        Client->>Server: HTTP POST messages
        Server->>Client: SSE message events
    end
    Client->>Server: Close SSE connection
```

## Custom Transports

Clients and servers **MAY** implement additional custom transport mechanisms to suit
their specific needs. The protocol is transport-agnostic and can be implemented over any
communication channel that supports bidirectional message exchange.

Implementers who choose to support custom transports **MUST** ensure they preserve the
JSON-RPC message format and lifecycle requirements defined by MCP. Custom transports
**SHOULD** document their specific connection establishment and message exchange patterns
to aid interoperability.

--- END OF FILE 2024-11-05/basic/transports.mdx ---


--- START OF FILE 2024-11-05/client/roots.mdx ---
---
title: Roots
type: docs
weight: 40
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol (MCP) provides a standardized way for clients to expose
filesystem "roots" to servers. Roots define the boundaries of where servers can operate
within the filesystem, allowing them to understand which directories and files they have
access to. Servers can request the list of roots from supporting clients and receive
notifications when that list changes.

## User Interaction Model

Roots in MCP are typically exposed through workspace or project configuration interfaces.

For example, implementations could offer a workspace/project picker that allows users to
select directories and files the server should have access to. This can be combined with
automatic workspace detection from version control systems or project files.

However, implementations are free to expose roots through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Capabilities

Clients that support roots **MUST** declare the `roots` capability during
[initialization](/specification/2024-11-05/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "roots": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the client will emit notifications when the list of roots
changes.

## Protocol Messages

### Listing Roots

To retrieve roots, servers send a `roots/list` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "roots/list"
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "roots": [
      {
        "uri": "file:///home/user/projects/myproject",
        "name": "My Project"
      }
    ]
  }
}
```

### Root List Changes

When roots change, clients that support `listChanged` **MUST** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/roots/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Server
    participant Client

    Note over Server,Client: Discovery
    Server->>Client: roots/list
    Client-->>Server: Available roots

    Note over Server,Client: Changes
    Client--)Server: notifications/roots/list_changed
    Server->>Client: roots/list
    Client-->>Server: Updated roots
```

## Data Types

### Root

A root definition includes:

- `uri`: Unique identifier for the root. This **MUST** be a `file://` URI in the current
  specification.
- `name`: Optional human-readable name for display purposes.

Example roots for different use cases:

#### Project Directory

```json
{
  "uri": "file:///home/user/projects/myproject",
  "name": "My Project"
}
```

#### Multiple Repositories

```json
[
  {
    "uri": "file:///home/user/repos/frontend",
    "name": "Frontend Repository"
  },
  {
    "uri": "file:///home/user/repos/backend",
    "name": "Backend Repository"
  }
]
```

## Error Handling

Clients **SHOULD** return standard JSON-RPC errors for common failure cases:

- Client does not support roots: `-32601` (Method not found)
- Internal errors: `-32603`

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Roots not supported",
    "data": {
      "reason": "Client does not have roots capability"
    }
  }
}
```

## Security Considerations

1. Clients **MUST**:

   - Only expose roots with appropriate permissions
   - Validate all root URIs to prevent path traversal
   - Implement proper access controls
   - Monitor root accessibility

2. Servers **SHOULD**:
   - Handle cases where roots become unavailable
   - Respect root boundaries during operations
   - Validate all paths against provided roots

## Implementation Guidelines

1. Clients **SHOULD**:

   - Prompt users for consent before exposing roots to servers
   - Provide clear user interfaces for root management
   - Validate root accessibility before exposing
   - Monitor for root changes

2. Servers **SHOULD**:
   - Check for roots capability before usage
   - Handle root list changes gracefully
   - Respect root boundaries in operations
   - Cache root information appropriately

--- END OF FILE 2024-11-05/client/roots.mdx ---


--- START OF FILE 2024-11-05/client/sampling.mdx ---
---
title: Sampling
type: docs
weight: 40
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to request LLM
sampling ("completions" or "generations") from language models via clients. This flow
allows clients to maintain control over model access, selection, and permissions while
enabling servers to leverage AI capabilities&mdash;with no server API keys necessary.
Servers can request text or image-based interactions and optionally include context from
MCP servers in their prompts.

## User Interaction Model

Sampling in MCP allows servers to implement agentic behaviors, by enabling LLM calls to
occur _nested_ inside other MCP server features.

Implementations are free to expose sampling through any interface pattern that suits
their needs&mdash;the protocol itself does not mandate any specific user interaction
model.

<Warning>

For trust & safety and security, there **SHOULD** always
be a human in the loop with the ability to deny sampling requests.

Applications **SHOULD**:

- Provide UI that makes it easy and intuitive to review sampling requests
- Allow users to view and edit prompts before sending
- Present generated responses for review before delivery

</Warning>

## Capabilities

Clients that support sampling **MUST** declare the `sampling` capability during
[initialization](/specification/2024-11-05/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "sampling": {}
  }
}
```

## Protocol Messages

### Creating Messages

To request a language model generation, servers send a `sampling/createMessage` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "What is the capital of France?"
        }
      }
    ],
    "modelPreferences": {
      "hints": [
        {
          "name": "claude-3-sonnet"
        }
      ],
      "intelligencePriority": 0.8,
      "speedPriority": 0.5
    },
    "systemPrompt": "You are a helpful assistant.",
    "maxTokens": 100
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "role": "assistant",
    "content": {
      "type": "text",
      "text": "The capital of France is Paris."
    },
    "model": "claude-3-sonnet-20240307",
    "stopReason": "endTurn"
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Server
    participant Client
    participant User
    participant LLM

    Note over Server,Client: Server initiates sampling
    Server->>Client: sampling/createMessage

    Note over Client,User: Human-in-the-loop review
    Client->>User: Present request for approval
    User-->>Client: Review and approve/modify

    Note over Client,LLM: Model interaction
    Client->>LLM: Forward approved request
    LLM-->>Client: Return generation

    Note over Client,User: Response review
    Client->>User: Present response for approval
    User-->>Client: Review and approve/modify

    Note over Server,Client: Complete request
    Client-->>Server: Return approved response
```

## Data Types

### Messages

Sampling messages can contain:

#### Text Content

```json
{
  "type": "text",
  "text": "The message content"
}
```

#### Image Content

```json
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/jpeg"
}
```

### Model Preferences

Model selection in MCP requires careful abstraction since servers and clients may use
different AI providers with distinct model offerings. A server cannot simply request a
specific model by name since the client may not have access to that exact model or may
prefer to use a different provider's equivalent model.

To solve this, MCP implements a preference system that combines abstract capability
priorities with optional model hints:

#### Capability Priorities

Servers express their needs through three normalized priority values (0-1):

- `costPriority`: How important is minimizing costs? Higher values prefer cheaper models.
- `speedPriority`: How important is low latency? Higher values prefer faster models.
- `intelligencePriority`: How important are advanced capabilities? Higher values prefer
  more capable models.

#### Model Hints

While priorities help select models based on characteristics, `hints` allow servers to
suggest specific models or model families:

- Hints are treated as substrings that can match model names flexibly
- Multiple hints are evaluated in order of preference
- Clients **MAY** map hints to equivalent models from different providers
- Hints are advisory&mdash;clients make final model selection

For example:

```json
{
  "hints": [
    { "name": "claude-3-sonnet" }, // Prefer Sonnet-class models
    { "name": "claude" } // Fall back to any Claude model
  ],
  "costPriority": 0.3, // Cost is less important
  "speedPriority": 0.8, // Speed is very important
  "intelligencePriority": 0.5 // Moderate capability needs
}
```

The client processes these preferences to select an appropriate model from its available
options. For instance, if the client doesn't have access to Claude models but has Gemini,
it might map the sonnet hint to `gemini-1.5-pro` based on similar capabilities.

## Error Handling

Clients **SHOULD** return errors for common failure cases:

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -1,
    "message": "User rejected sampling request"
  }
}
```

## Security Considerations

1. Clients **SHOULD** implement user approval controls
2. Both parties **SHOULD** validate message content
3. Clients **SHOULD** respect model preference hints
4. Clients **SHOULD** implement rate limiting
5. Both parties **MUST** handle sensitive data appropriately

--- END OF FILE 2024-11-05/client/sampling.mdx ---


--- START OF FILE 2024-11-05/server/utilities/completion.mdx ---
---
title: Completion
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to offer
argument autocompletion suggestions for prompts and resource URIs. This enables rich,
IDE-like experiences where users receive contextual suggestions while entering argument
values.

## User Interaction Model

Completion in MCP is designed to support interactive user experiences similar to IDE code
completion.

For example, applications may show completion suggestions in a dropdown or popup menu as
users type, with the ability to filter and select from available options.

However, implementations are free to expose completion through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Protocol Messages

### Requesting Completions

To get completion suggestions, clients send a `completion/complete` request specifying
what is being completed through a reference type:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "code_review"
    },
    "argument": {
      "name": "language",
      "value": "py"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "completion": {
      "values": ["python", "pytorch", "pyside"],
      "total": 10,
      "hasMore": true
    }
  }
}
```

### Reference Types

The protocol supports two types of completion references:

| Type           | Description                 | Example                                             |
| -------------- | --------------------------- | --------------------------------------------------- |
| `ref/prompt`   | References a prompt by name | `{"type": "ref/prompt", "name": "code_review"}`     |
| `ref/resource` | References a resource URI   | `{"type": "ref/resource", "uri": "file:///{path}"}` |

### Completion Results

Servers return an array of completion values ranked by relevance, with:

- Maximum 100 items per response
- Optional total number of available matches
- Boolean indicating if additional results exist

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client: User types argument
    Client->>Server: completion/complete
    Server-->>Client: Completion suggestions

    Note over Client: User continues typing
    Client->>Server: completion/complete
    Server-->>Client: Refined suggestions
```

## Data Types

### CompleteRequest

- `ref`: A `PromptReference` or `ResourceReference`
- `argument`: Object containing:
  - `name`: Argument name
  - `value`: Current value

### CompleteResult

- `completion`: Object containing:
  - `values`: Array of suggestions (max 100)
  - `total`: Optional total matches
  - `hasMore`: Additional results flag

## Implementation Considerations

1. Servers **SHOULD**:

   - Return suggestions sorted by relevance
   - Implement fuzzy matching where appropriate
   - Rate limit completion requests
   - Validate all inputs

2. Clients **SHOULD**:
   - Debounce rapid completion requests
   - Cache completion results where appropriate
   - Handle missing or partial results gracefully

## Security

Implementations **MUST**:

- Validate all completion inputs
- Implement appropriate rate limiting
- Control access to sensitive suggestions
- Prevent completion-based information disclosure

--- END OF FILE 2024-11-05/server/utilities/completion.mdx ---


--- START OF FILE 2024-11-05/server/utilities/logging.mdx ---
---
title: Logging
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to send
structured log messages to clients. Clients can control logging verbosity by setting
minimum log levels, with servers sending notifications containing severity levels,
optional logger names, and arbitrary JSON-serializable data.

## User Interaction Model

Implementations are free to expose logging through any interface pattern that suits their
needs&mdash;the protocol itself does not mandate any specific user interaction model.

## Capabilities

Servers that emit log message notifications **MUST** declare the `logging` capability:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

## Log Levels

The protocol follows the standard syslog severity levels specified in
[RFC 5424](https://datatracker.ietf.org/doc/html/rfc5424#section-6.2.1):

| Level     | Description                      | Example Use Case           |
| --------- | -------------------------------- | -------------------------- |
| debug     | Detailed debugging information   | Function entry/exit points |
| info      | General informational messages   | Operation progress updates |
| notice    | Normal but significant events    | Configuration changes      |
| warning   | Warning conditions               | Deprecated feature usage   |
| error     | Error conditions                 | Operation failures         |
| critical  | Critical conditions              | System component failures  |
| alert     | Action must be taken immediately | Data corruption detected   |
| emergency | System is unusable               | Complete system failure    |

## Protocol Messages

### Setting Log Level

To configure the minimum log level, clients **MAY** send a `logging/setLevel` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "logging/setLevel",
  "params": {
    "level": "info"
  }
}
```

### Log Message Notifications

Servers send log messages using `notifications/message` notifications:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/message",
  "params": {
    "level": "error",
    "logger": "database",
    "data": {
      "error": "Connection failed",
      "details": {
        "host": "localhost",
        "port": 5432
      }
    }
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Configure Logging
    Client->>Server: logging/setLevel (info)
    Server-->>Client: Empty Result

    Note over Client,Server: Server Activity
    Server--)Client: notifications/message (info)
    Server--)Client: notifications/message (warning)
    Server--)Client: notifications/message (error)

    Note over Client,Server: Level Change
    Client->>Server: logging/setLevel (error)
    Server-->>Client: Empty Result
    Note over Server: Only sends error level<br/>and above
```

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Invalid log level: `-32602` (Invalid params)
- Configuration errors: `-32603` (Internal error)

## Implementation Considerations

1. Servers **SHOULD**:

   - Rate limit log messages
   - Include relevant context in data field
   - Use consistent logger names
   - Remove sensitive information

2. Clients **MAY**:
   - Present log messages in the UI
   - Implement log filtering/search
   - Display severity visually
   - Persist log messages

## Security

1. Log messages **MUST NOT** contain:

   - Credentials or secrets
   - Personal identifying information
   - Internal system details that could aid attacks

2. Implementations **SHOULD**:
   - Rate limit messages
   - Validate all data fields
   - Control log access
   - Monitor for sensitive content

--- END OF FILE 2024-11-05/server/utilities/logging.mdx ---


--- START OF FILE 2024-11-05/server/utilities/pagination.mdx ---
---
title: Pagination
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol (MCP) supports paginating list operations that may return
large result sets. Pagination allows servers to yield results in smaller chunks rather
than all at once.

Pagination is especially important when connecting to external services over the
internet, but also useful for local integrations to avoid performance issues with large
data sets.

## Pagination Model

Pagination in MCP uses an opaque cursor-based approach, instead of numbered pages.

- The **cursor** is an opaque string token, representing a position in the result set
- **Page size** is determined by the server, and clients **MUST NOT** assume a fixed page
  size

## Response Format

Pagination starts when the server sends a **response** that includes:

- The current page of results
- An optional `nextCursor` field if more results exist

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {
    "resources": [...],
    "nextCursor": "eyJwYWdlIjogM30="
  }
}
```

## Request Format

After receiving a cursor, the client can _continue_ paginating by issuing a request
including that cursor:

```json
{
  "jsonrpc": "2.0",
  "method": "resources/list",
  "params": {
    "cursor": "eyJwYWdlIjogMn0="
  }
}
```

## Pagination Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: List Request (no cursor)
    loop Pagination Loop
      Server-->>Client: Page of results + nextCursor
      Client->>Server: List Request (with cursor)
    end
```

## Operations Supporting Pagination

The following MCP operations support pagination:

- `resources/list` - List available resources
- `resources/templates/list` - List resource templates
- `prompts/list` - List available prompts
- `tools/list` - List available tools

## Implementation Guidelines

1. Servers **SHOULD**:

   - Provide stable cursors
   - Handle invalid cursors gracefully

2. Clients **SHOULD**:

   - Treat a missing `nextCursor` as the end of results
   - Support both paginated and non-paginated flows

3. Clients **MUST** treat cursors as opaque tokens:
   - Don't make assumptions about cursor format
   - Don't attempt to parse or modify cursors
   - Don't persist cursors across sessions

## Error Handling

Invalid cursors **SHOULD** result in an error with code -32602 (Invalid params).

--- END OF FILE 2024-11-05/server/utilities/pagination.mdx ---


--- START OF FILE 2024-11-05/server/index.mdx ---
---
title: Overview
---

<Info>**Protocol Revision**: 2024-11-05</Info>

Servers provide the fundamental building blocks for adding context to language models via
MCP. These primitives enable rich interactions between clients, servers, and language
models:

- **Prompts**: Pre-defined templates or instructions that guide language model
  interactions
- **Resources**: Structured data or content that provides additional context to the model
- **Tools**: Executable functions that allow models to perform actions or retrieve
  information

Each primitive can be summarized in the following control hierarchy:

| Primitive | Control                | Description                                        | Example                         |
| --------- | ---------------------- | -------------------------------------------------- | ------------------------------- |
| Prompts   | User-controlled        | Interactive templates invoked by user choice       | Slash commands, menu options    |
| Resources | Application-controlled | Contextual data attached and managed by the client | File contents, git history      |
| Tools     | Model-controlled       | Functions exposed to the LLM to take actions       | API POST requests, file writing |

Explore these key primitives in more detail below:

<CardGroup cols={3}>
  <Card
    title="Prompts"
    icon="message"
    href="/specification/2024-11-05/server/prompts"
  />
  <Card
    title="Resources"
    icon="file-lines"
    href="/specification/2024-11-05/server/resources"
  />
  <Card
    title="Tools"
    icon="wrench"
    href="/specification/2024-11-05/server/tools"
  />
</CardGroup>

--- END OF FILE 2024-11-05/server/index.mdx ---


--- START OF FILE 2024-11-05/server/prompts.mdx ---
---
title: Prompts
weight: 10
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to expose prompt
templates to clients. Prompts allow servers to provide structured messages and
instructions for interacting with language models. Clients can discover available
prompts, retrieve their contents, and provide arguments to customize them.

## User Interaction Model

Prompts are designed to be **user-controlled**, meaning they are exposed from servers to
clients with the intention of the user being able to explicitly select them for use.

Typically, prompts would be triggered through user-initiated commands in the user
interface, which allows users to naturally discover and invoke available prompts.

For example, as slash commands:

![Example of prompt exposed as slash command](/specification/2024-11-05/server/slash-command.png)

However, implementors are free to expose prompts through any interface pattern that suits
their needs&mdash;the protocol itself does not mandate any specific user interaction
model.

## Capabilities

Servers that support prompts **MUST** declare the `prompts` capability during
[initialization](/specification/2024-11-05/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "prompts": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the server will emit notifications when the list of
available prompts changes.

## Protocol Messages

### Listing Prompts

To retrieve available prompts, clients send a `prompts/list` request. This operation
supports
[pagination](/specification/2024-11-05/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "prompts/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "prompts": [
      {
        "name": "code_review",
        "description": "Asks the LLM to analyze code quality and suggest improvements",
        "arguments": [
          {
            "name": "code",
            "description": "The code to review",
            "required": true
          }
        ]
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Getting a Prompt

To retrieve a specific prompt, clients send a `prompts/get` request. Arguments may be
auto-completed through [the completion API](/specification/2024-11-05/server/utilities/completion).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "prompts/get",
  "params": {
    "name": "code_review",
    "arguments": {
      "code": "def hello():\n    print('world')"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "description": "Code review prompt",
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "Please review this Python code:\ndef hello():\n    print('world')"
        }
      }
    ]
  }
}
```

### List Changed Notification

When the list of available prompts changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/prompts/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Discovery
    Client->>Server: prompts/list
    Server-->>Client: List of prompts

    Note over Client,Server: Usage
    Client->>Server: prompts/get
    Server-->>Client: Prompt content

    opt listChanged
      Note over Client,Server: Changes
      Server--)Client: prompts/list_changed
      Client->>Server: prompts/list
      Server-->>Client: Updated prompts
    end
```

## Data Types

### Prompt

A prompt definition includes:

- `name`: Unique identifier for the prompt
- `description`: Optional human-readable description
- `arguments`: Optional list of arguments for customization

### PromptMessage

Messages in a prompt can contain:

- `role`: Either "user" or "assistant" to indicate the speaker
- `content`: One of the following content types:

#### Text Content

Text content represents plain text messages:

```json
{
  "type": "text",
  "text": "The text content of the message"
}
```

This is the most common content type used for natural language interactions.

#### Image Content

Image content allows including visual information in messages:

```json
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/png"
}
```

The image data **MUST** be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where visual context is important.

#### Embedded Resources

Embedded resources allow referencing server-side resources directly in messages:

```json
{
  "type": "resource",
  "resource": {
    "uri": "resource://example",
    "mimeType": "text/plain",
    "text": "Resource content"
  }
}
```

Resources can contain either text or binary (blob) data and **MUST** include:

- A valid resource URI
- The appropriate MIME type
- Either text content or base64-encoded blob data

Embedded resources enable prompts to seamlessly incorporate server-managed content like
documentation, code samples, or other reference materials directly into the conversation
flow.

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Invalid prompt name: `-32602` (Invalid params)
- Missing required arguments: `-32602` (Invalid params)
- Internal errors: `-32603` (Internal error)

## Implementation Considerations

1. Servers **SHOULD** validate prompt arguments before processing
2. Clients **SHOULD** handle pagination for large prompt lists
3. Both parties **SHOULD** respect capability negotiation

## Security

Implementations **MUST** carefully validate all prompt inputs and outputs to prevent
injection attacks or unauthorized access to resources.

--- END OF FILE 2024-11-05/server/prompts.mdx ---


--- START OF FILE 2024-11-05/server/resource-picker.png ---
ï¿½PNG

   
IHDR   ï¿½   ï¿½   ï¿½Ä¶  `iCCPICC Profile  (ï¿½uï¿½;HAï¿½ï¿½h$Dï¿½ï¿½H!Qï¿½*ï¿½ï¿½ï¿½rF,ï¿½ XQï¿½ï¿½Kï¿½ï¿½dï¿½wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6bciï¿½ï¿½BÒ‰ï¿½ï¿½"ï¿½ï¿½B4ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½3ï¿½ ï¿½%ï¿½gï¿½	ium]ï¿½!
?Âšnï¿½ï¿½ï¿½.P	ï¿½ï¿½ï¿½ï¿½ï¿½z7&fÍ¤cRï¿½rp68$oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½~Pï¿½tï¿½mï¿½ï¿½ï¿½;6|Hï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½-ï¿½5kï¿½2Iï¿½{ï¿½^ï¿½rï¿½ï¿½Ä‘lï¿½oï¿½qï¿½ï¿½Ö¿vï¿½ï¿½ï¿½Eï¿½0ï¿½0Rï¿½Ã¤ï¿½ï¿½
ï¿½P ÓŸ"ï¿½?}Jï¿½/ï¿½2ï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½Â¤ï¿½ï¿½Qï¿½ï¿½qDï¿½eLR*ï¿½Þ¿ï¿½ï¿½zGï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%Pï¿½ï¿½×®7z\7Lï¿½ï¿½ï¿½u=uï¿½ï¿½ï¿½[ï¿½@Ï›ã¼Ž ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½qï¿½@ï¿½#Pï¿½|.Laï¿½vY'   beXIfMM *           ï¿½i       &     ï¿½ï¿½       Pï¿½       ï¿½ï¿½       ï¿½    ASCII   Screenshot9UD  =iTXtXML:com.adobe.xmp     <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="XMP Core 6.0.0">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:exif="http://ns.adobe.com/exif/1.0/"
            xmlns:tiff="http://ns.adobe.com/tiff/1.0/">
         <exif:PixelYDimension>181</exif:PixelYDimension>
         <exif:UserComment>Screenshot</exif:UserComment>
         <exif:PixelXDimension>174</exif:PixelXDimension>
         <tiff:Orientation>1</tiff:Orientation>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
oPï¿½=  3HIDATxï¿½}ï¿½Õ‘nMMï¿½fA(ï¿½0BFH"ï¿½dlï¿½ï¿½ï¿½ï¿½omdï¿½ï¿½ï¿½9ï¿½. ï¿½kï¿½g>{ï¿½kï¿½
ï¿½È€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½EAHï¿½ï¿½rï¿½H3ï¿½hï¿½hï¿½ï¿½ï¿½ï¿½ï¿½Ü¾}cï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½V×©:uï¿½Ô©S]}ï¿½oß¢ï¿½ï¿½Sï¿½Qï¿½rï¿½Xï¿½eï¿½ï¿½1ï¿½ï¿½Þ‘ï¿½EDï¿½,ï¿½_ï¿½RQï¿½ ï¿½ï¿½ï¿½Wï¿½Hzdï¿½L,P,N+ï¿½?2ï¿½ï¿½ï¿½ï¿½x"ï¿½ï¿½ï¿½i%ï¿½f
ï¿½ï¿½Pï¿½^]]Mï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Bï¿½wï¿½*%+ï¿½ï¿½fï¿½Lï¿½ï¿½ wï¿½ï¿½i:]}ï¿½Uqï¿½oXOï¿½>ï¿½;ï¿½ï¿½ï¿½[izï¿½4ï¿½ï¿½ï¿½wï¿½ï¿½C@ï¿½ï¿½;ï¿½ï¿½.ï¿½[ï¿½>kï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½hï¿½ï¿½IT\TL}ï¿½iï¿½Õ¯~ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6å—¿ï¿½5=ï¿½ï¿½v9çœ³éš«ï¿½ï¿½;vï¿½ï¿½Iï¿½ï¿½7ï¿½ï¿½-ï¿½ï¿½ï¿½ï¿½6Û cAï¿½ï¿½ï¿½
Zï¿½Nï¿½ï¿½ï¿½kï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½
ï¿½æš«hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~''ï¿½ï¿½UWï¿½Oï¿½sï¿½Rï¿½-iï¿½%ï¿½ï¿½ï¿½!ï¿½ï¿½ï¿½XW\~-ï¿½Åƒï¿½ï¿½~ï¿½ï¿½wï¿½ï¿½ï¿½ï¿½ï¿½|9mÝ¶=ï¿½ï¿½1cï¿½Ò‹/ï¿½H+Vï¿½ï¿½ï¿½ï¿½Ú½ï¿½=ï¿½ï¿½È‘#ï¿½c[L_ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>!ï¿½ï¿½ï¿½]Kç·ï¿½ wÌ˜1ï¿½ï¿½Ö›ï¿½/~ï¿½ï¿½=ï¿½ï¿½@!ï¿½nï¿½ï¿½Îªï¿½*8ï¿½)=Dï¿½ï¿½pÐ›nï¿½ï¿½+ï¿½N#zï¿½
"<ï¿½z.ï¿½.ï¿½ï¿½Wnï¿½5kï¿½Òµ<ï¿½Cï¿½ï¿½uz0nï¿½XZï¿½ï¿½
zsï¿½ï¿½Jï¿½ï¿½Gï¿½ï¿½]D]]ï¿½Bï¿½|,ï¿½ï¿½ï¿½ï¿½ï¿½r
}ï¿½ï¿½Rï¿½?ï¿½ï¿½ï¿½ï¿½N+Jï¿½+.ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4oï¿½\Ú¶mï¿½ï¿½ï¿½ ;wî¤†ï¿½ï¿½ï¿½=Wï¿½ï¿½wï¿½Fwï¿½ï¿½}ï¿½ï¿½ï¿½oï¿½)ï¿½Nï¿½ï¿½oï¿½I<ï¿½ï¿½ï¿½%ï¿½Lï¿½:Eï¿½ï¿½ï¿½H;/ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8pï¿½ï¿½m JFï¿½lï¿½9.ï¿½Ù¹nÎš(^SSMï¿½ï¿½ï¿½ï¿½ï¿½dï¿½-rï¿½WGï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bÖ‘ï¿½Dï¿½_ï¿½ï¿½ujDeÔŸwÞ¹ï¿½Uï¿½ï¿½Aï¿½m`ï¿½ï¿½ï¿½Ó§ï¿½/ï¿½ï¿½ï¿½xï¿½v[ï¿½ï¿½ï¿½aÃ†ï¿½ï¿½ï¿½_Kï¿½ï¿½ï¿½ï¿½yï¿½ï¿½sï¿½Csï¿½Ì¦qï¿½ï¿½qï¿½ï¿½ï¿½z0ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½|{ï¿½ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½	/ï¿½8Ï|/=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½Oï¿½mï¿½1ï¿½Aï¿½ï¿½4oï¿½<qï¿½W^yï¿½ï¿½{ï¿½o4ï¿½ï¿½VUEXTpï¿½9sï¿½ï¿½ï¿½É“%yï¿½ï¿½ï¿½i5/ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½hÏžï¿½4fï¿½hï¿½ï¿½ï¿½ï¿½ï¿½{~(iï¿½ï¿½ï¿½ï¿½yA\ï¿½ï¿½ï¿½ï¿½ï¿½`>nï¿½ï¿½Kï¿½ï¿½3ï¿½R'ï¿½;Ð¥Xï¿½)ï¿½ï¿½cï¿½ï¿½xH"Ú¦+ï¿½~|pz8
"3rTï¿½!ï¿½ï¿½Oï¿½ï¿½)?ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½Aï¿½~ï¿½Cï¿½ï¿½ï¿½|ï¿½
Gï¿½ï¿½ï¿½4ï¿½ï¿½ï¿½ï¿½O[ï¿½DWg-ï¿½?ï¿½>ï¿½ï¿½%tï¿½ï¿½ï¿½"Qï¿½bagjgï¿½ï¿½Gï¿½*ï¿½ï¿½K_ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½}ï½’ï¿½xï¿½
Ú·oï¿½ï¿½!Ò®]ï¿½Vï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½ï¿½~{mÙ²ï¿½^}Mï¿½6Uï¿½Qï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½#nÙºï¿½ï¿½0ï¿½yï¿½fBï¿½EyGd8<ï¿½ï¿½ï¿½_ï¿½	Nï¿½h-|ÌœÙ”ï¿½ï¿½ï¿½&ï¿½eBHï¿½ï¿½ï¿½M%W`Ä†Jï¿½ï¿½d#
ï¿½~ï¿½ï¿½BM/ï¿½ tï¿½uï¿½cï¿½ï¿½hï¿½ï¿½ï¿½Nï¿½o_ï¿½ï¿½:ï¿½`ï¿½ï¿½ï¿½Q>]#ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½-{ï¿½ï¿½ï¿½É·ï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½.à¨¸ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½ï¿½fï¿½ï¿½ß¡/ï¿½k4ï¿½ï¿½sï¿½ï¿½.ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½>"ï¿½|ï¿½ï¿½Iï¿½"ï¿½ï¿½ï¿½Î¦Mï¿½hï¿½"ï¿½*î¸»ï¿½ï¿½JKJï¿½ï¿½HwOï¿½fcï¿½Ä‰tï¿½I'ï¿½%lï¿½ï¿½Å´uï¿½6ï¿½%ï¿½}ï¿½ï¿½ï¿½qMPï¿½ï¿½9Xjaå¸ˆï¿½,ï¿½7Çµï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½:/ï¿½×­[*ï¿½ï¿½Q4Smï¿½ï¿½p|ï¿½ï¿½9ï¿½ï¿½D?É‘cï¿½ï¿½ä°›ï¿½wttï¿½iï¿½ï¿½~ï¿½ï¿½ï¿½i,ç²‹ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½bpÂ¦3ï¿½Zï¿½ï¿½#äŠ½ï¿½ï¿½ï¿½^|ï¿½%zï¿½ï¿½ï¿½ï¿½ï¿½qï¿½xï¿½É¿P
çµ¼-ï¿½Qï¿½ï¿½?ï¿½ï¿½ÚšZzï¿½hï¿½ï¿½ï¿½ï¿½ï¿½>vï¿½ï¿½ï¿½Úµï¿½Qï¿½v^uZÐ‚wWsXdï¿½ï¿½sï¿½ ï¿½%ï¿½ï¿½%+ï¿½ï¿½~FBJï¿½
Nï¿½Mï¿½#kï¿½vï¿½ï¿½ï¿½3ï¿½Å¿ï¿½ï¿½/ï¿½ï¿½nï¿½ï¿½tEï¿½)wï¿½ï¿½Eï¿½ï¿½+n\ï¿½ï¿½?ï¿½ï¿½*++]ï¿½]ï¿½v'ï¿½ï¿½rï¿½gï¿½Rï¿½ï¿½ï¿½ß–S	_ï¿½ï¿½WHï¿½0~ï¿½Iï¿½446ï¿½ï¿½ï¿½ï¿½ï¿½ 4ï¿½iï¿½ï¿½/ï¿½ï¿½Ø¸ï¿½Ë¦ï¿½A]ï¿½a9-ï¿½ï¿½ï¿½ï¿½l ï¿½ï¿½,ï¿½=Fï¿½ï¿½gï¿½u
^8Nï¿½pï¿½dï¿½#"2ï¿½ï¿½ï¿½ï¿½Ô¡ï¿½tà©œï¿½6]ï¿½ï¿½.*ï¿½ï¿½ï¿½Iï¿½Nï¿½Ygï¿½ï¿½N*Ò€3Nï¿½hï¿½ï¿½;ï¿½ï¿½uï¿½2ï¿½Tjï¿½s\ï¿½Oï¿½Û½8mFï¿½ZerRGOw7ï¿½ï¿½ï¿½ï¿½dï¿½@ï¿½fÏžï¿½gï¿½9ï¿½=Â§ï¿½ï¿½è¬³Î’(Ð±ï¿½>ï¿½,ï¿½Ó“O
;ï¿½ï¿½Qï¿½ï¿½ï¿½bï¿½tï¿½xï¿½'jï¿½ï¿½ï¿½ï¿½ï¿½q:ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½yï¿½mhï¿½oWKï¿½ï¿½ï¿½2ï¿½~ï¿½@ï¿½7UQï¿½iï¿½wWï¿½DZï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½	mWï¿½pP@ï¿½ï¿½ï¿½-ï¿½Ö·ï¿½{ï¿½qï¿½%ï¿½Ð±"Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½sï¿½%ï¿½!ï¿½ï¿½ï¿½Uï¿½ptÐµï¿½Ò›ï¿½7ï¿½ï¿½Qï¿½r
>wï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½|ï¿½ï¿½v~9..~&Lï¿½@ï¿½ï¿½=ï¿½ï¿½ï¿½kï¿½ï¿½ï¿½/ï¿½Vï¿½ï¿½|>uï¿½:ï¿½ï¿½ï¿½ï¿½ï¿½g-_Pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½rï¿½fï¿½Fï¿½pnï¿½ï¿½ï¿½ï¿½0oï¿½!Õ¸ï¿½ï¿½2iï¿½Dzooï¿½ï¿½ï¿½H
ï¿½td7ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½Xï¿½Ò….ï¿½?>ï¿½È¯ï¿½ï¿½ï¿½?Bï¿½Gï¿½fï¿½C6lï¿½ï¿½ï¿½z/ï¿½uï¿½8yï¿½ï¿½ï¿½ï¿½@ï¿½nlhï¿½ï¿½ï¿½p.ï¿½ï¿½R:ï¿½Çˆvmï¿½?Ò˜ï¿½ï¿½rï¿½ï¿½wHï¿½{ï¿½<ï¿½Sï¿½ï¿½gï¿½ï¿½}ï¿½fï¿½~8+\vï¿½ï¿½4mï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½Úªï¿½ï¿½ï¿½ï¿½ï¿½PGGxï¿½EMMï¿½tl'MMï¿½%ï¿½ï¿½ï¿½apXï¿½ï¿½Î¾!ï¿½Ó¢wï¿½ï¿½ï¿½ï¿½|	ï¿½tï¿½Sï¿½ï¿½#ï¿½ï¿½ï¿½Mï¿½Lï¿½ï¿½cï¿½ï¿½ï¿½ï¿½Uï¿½ï¿½mï¿½ï¿½ï¿½(ï¿½U:ï¿½ï¿½ï¿½QT"[]ï¿½<Iï¿½ï¿½>ï¿½ï¿½ï¿½$nAbaï¿½p ikï¿½ï¿½,ï¿½ZQQÉ»ï¿½Oï¿½ï¿½#Gï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½o]m$]`ï¿½ï¿½ï¿½ï¿½ï¿½Fï¿½*ï¿½ï¿½ Yï¿½}Vï¿½ï¿½ï¿½qï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½FLï¿½?ï¿½ï¿½}6ï¿½ï¿½%ï¿½Pï¿½Lï¿½ï¿½ï¿½#Yï¿½ï¿½luNï¿½ï¿½ï¿½o#ï¿½)ï¿½ï¿½rï¿½`ï¿½ï¿½ï¿½?~ï¿½ï¿½Q>Rï¿½Äµ@Bï¿½ï¿½ï¿½ï¿½r\lï¿½`ï¿½ï¿½?
ï¿½'ï¿½ï¿½ï¿½ï¿½=9ï¿½ï¿½ï¿½FVï¿½\ï¿½;kï¿½@ï¿½Mfï¿½4rï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½ï¿½ Nï¿½ï¿½ï¿½í‹»sï¿½.ï¿½`Z 7ï¿½8ï¿½ï¿½33ï¿½gqq0*ï¿½ï¿½ï¿½rï¿½Qn.ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½w0g,ï¿½[,Pï¿½h+NÄÇ™Ç¢ï¿½ï¿½?ï¿½xï¿½8ï¿½ï¿½iï¿½Aï¿½iï¿½49.TKï¿½};ï¿½Aï¿½ï¿½r\ï¿½YWoï¿½9ï¿½ï¿½ï¿½ï¿½ì¸©s[?zoï¿½Qï¿½hï¿½ï¿½/ï¿½O8ï¿½E.ï¿½ï¿½<ï¿½ï¿½O'ï¿½ï¿½DZï¿½ï¿½ï¿½cï¿½ï¿½?Åï¿½ï¿½Ñ·ï¿½Dhï¿½W#k6ï¿½0?Nï¿½ï¿½+gï¿½Tï¿½@2ï¿½ï¿½ï¿½ï¿½ï¿½qï¿½rï¿½dï¿½ï¿½&ï¿½=Fï¿½ï¿½ï¿½hKKï¿½\ï¿½ï¿½ï¿½D(dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½}ï¿½ï¿½^?ï¿½ï¿½*++ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½]ï¿½@D^ï¿½ï¿½o^ï¿½ï¿½&mï¿½ï¿½ï¿½NpGï¿½ÏƒÜ§ï¿½Dï¿½ï¿½$ï¿½ï¿½Ç‹ï¿½ä†…ï¿½_ï¿½(ï¿½ï¿½ï¿½ï¿½Tï¿½[Sï¿½~ï¿½ï¿½ï¿½eï¿½xyï¿½ï¿½ï¿½<ï¿½$yBYï¿½ï¿½y\ï¿½7ï¿½ï¿½f!9Dï¿½pï¿½
ï¿½eï¿½ï¿½ï¿½Zï¿½;Wï¿½ï¿½ï¿½>Å®Cï¿½ï¿½V0ï¿½
ï¿½ï¿½Dï¿½ï¿½ï¿½Yï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½B CPï¿½aë»lï¿½ï¿½ï¿½ï¿½d#e";ï¿½ï¿½S(9ï¿½ï¿½>ï¿½aï¿½ï¿½dï¿½ï¿½ï¿½ï¿½`dï¿½ï¿½ï¿½ iï¿½'tï¿½ï¿½iï¿½TtD\ï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½D8ï¿½ï¿½gï¿½ï¿½ï¿½ï¿½Oz;Xï¿½ï¿½ï¿½,ï¿½Nï¿½Qm7!#ï¿½ï¿½ï¿½ï¿½ï¿½qZs!fG\Gï¿½ï¿½ï¿½ï¿½ï¿½ZtEï¿½ï¿½F0SXï¿½ï¿½Ü„C"ï¿½ï¿½ï¿½Aï¿½ï¿½-ï¿½ï¿½ï¿½;ï¿½ï¿½,_ï¿½ï¿½k~Ì«ï¿½4
ï¿½ï¿½Qï¿½-Ç•ï¿½Df$ï¿½ï¿½]Lï¿½Eï¿½ï¿½ï¿½ï¿½ ï¿½Ô¨7%ï¿½7ï¿½Qï¿½ï¿½â¢ Sï¿½uÊ¥x&<Ù´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½LxTï¿½ï¿½ï¿½ï¿½]nï¿½WÌ¥zfï¿½sjctï¿½ï¿½Xï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç¤aAï¿½Xï¿½x|ï¿½Kn
6ï¿½9rï¿½d/7ï¿½>.{B'ï¿½rï¿½?ï¿½ï¿½t	ï¿½Ö|ï¿½
0ï¿½ï¿½.ï¿½C HqÚ«ï¿½ï¿½99'-^ï¿½^e6Ó‚ï¿½xTF&<fï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½MRï¿½,Æ¤2ï¿½ï¿½7ï¿½>ï¿½ï¿½xï¿½ï¿½ï¿½&ï¿½Ñ¹89>DyÅ…b>ï¿½
9ï¿½IWkï¿½?ï¿½ï¿½ï¿½ï¿½JJï¿½0ï¿½Gï¿½L:ï¿½fï¿½/ Q	bï¿½Rï¿½ï¿½ï¿½Mï¿½DlØ 0ï¿½ï¿½ï¿½Rï¿½&ï¿½hï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½Ü›ï¿½ï¿½ï¿½?ï¿½hï¿½ï¿½+'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½æ¸eï¿½ï¿½ï¿½KPbAï¿½JCnBï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½Jï¿½x,ï¿½ï¿½aï¿½09.7:ï¿½ï¿½ï¿½L@ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<!+Tï¿½!'ï¿½ï¿½ï¿½ï¿½ï¿½ar\g|ï¿½8ï¿½@6xï¿½sSï¿½ï¿½9ï¿½~ï¿½|oï¿½ï¿½GWKhï¿½Tï¿½Éµï¿½!#×¾Oï¿½vyï¿½quï¿½`ï¿½xWï¿½Hï¿½.ï¿½Bï¿½ï¿½,Y,:ï¿½0dï¿½Ô¨ï¿½ 0}<2ï¿½ï¿½/ï¿½Hï¿½%ï¿½ï¿½ï¿½+2ï¿½4aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,zï¿½ï¿½JMCFï¿½Nhï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½q3ï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½3Xxï¿½	=ï¿½ï¿½ï¿½ï¿½Í³
ï¿½ï¿½ï¿½Gs7VÑ€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!Ë²3-?Eï¿½ï¿½(=ï¿½ï¿½ï¿½uÅ£ï¿½dï¿½oï¿½9ï¿½ï¿½ï¿½Bï¿½ ï¿½8~ï¿½eï¿½
ï¿½ï¿½H×ŸÎ/ï¿½ÆºÚ¼LJG}:ï¿½dtï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½\ï¿½ï¿½gï¿½Qï¿½-ï¿½oï¿½ï¿½ï¿½gï¿½,N×¯ï¿½{nï¿½B8ï¿½Q$O::ï¿½Oï¿½8_ï¿½}Wï¿½Nï¿½ï¿½ï¿½Ulï¿½ï¿½ï¿½&ï¿½ï¿½Qvï¿½ï¿½gï¿½ï¿½__Bï¿½^r)-ï¿½ï¿½ï¿½ï¿½ï¿½/ï¿½Iï¿½Cï¿½2ï¿½ï¿½3ï¿½Iï¿½GTï¿½ï¿½ï¿½'ï¿½ï¿½Bï¿½yï¿½ï¿½;ï¿½ivXrï¿½ï¿½ï¿½[Lï¿½ï¿½ï¿½gMï¿½E?Ë–-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aGCï¿½ï¿½?ï¿½ï¿½A:ï¿½pï¿½ï¿½Å’ï¿½zï¿½ï¿½Ò¥K%Â£%.ï¿½uN^}ï¿½ï¿½Eï¿½ï¿½ï¿½}\ï¿½ï¿½ï¿½8t1ï¿½ï¿½ï¿½|ï¿½!ï¿½ï¿½ï¿½yï¿½vï¿½9sï¿½ï¿½ï¿½eï¿½ï¿½ï¿½lï¿½Q7ï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½zï¿½QCï¿½ï¿½>ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{6\ï¿½i"L9ï¿½ï¿½ï¿½ï¿½t4ï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ì´œï¿½"ï¿½ ï¿½"Ç½ï¿½ï¿½ï¿½ï¿½ï¿½9?)$Cï¿½Cyï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½y5ï¿½ï¿½ï¿½ièŽ£ï¿½QOZpï¿½ï¿½ï¿½ï¿½EZ8ï¿½uÑ8-ç·ˆï¿½ï¿½ï¿½Dï¿½0ï¿½}Xï¿½Aï¿½	ï¿½ï¿½ï¿½;ï¿½b $Hï¿½ï¿½ï¿½zï¿½ï¿½<ï¿½}9ï¿½;ï¿½ï¿½ï¿½NÎ˜ï¿½ï¿½ï¿½ï¿½Wï¿½5gï¿½Û‘vï¿½ã´ˆï¿½Ïiï»Ÿï¿½sï¿½kï¿½tï¿½ï¿½'ï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½>S\ï¿½ï¿½qï¿½mm>ï¿½}9ï¿½V{['Gï¿½4ß€0}ï¿½-ï¿½fï¿½1ï¿½ÂŽr ï¿½ï¿½JNï¿½M8ï¿½ï¿½Ï‘vï¿½wï¿½ÒªUï¿½ï¿½8#ï¿½ï¿½sï¿½tcJï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½{qmï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½Ç™ï¿½ï¿½ï¿½ï¿½jï¿½#ï¿½#.Jlï¿½6(.aPÂï¿½50 ï¿½ï¿½ï¿½Vï¿½ ï¿½Eï¿½ï¿½ï¿½iï¿½ï¿½ï¿½-ï¿½ï¿½ï¿½qï¿½ï¿½ï¿½ï¿½^cï¿½ï¿½ï¿½ï¿½:"ï¿½ï¿½@ï¿½}\]&ï¿½dMï¿½ï¿½Vhï¿½ï¿½ï¿½ï¿½ï¿½\N0QWï¿½Zï¿½ï¿½nï¿½]ï¿½:iï¿½ï¿½ï¿½KgÈ±KØ¸-ï¿½=ï¿½ï¿½ï¿½ï¿½zï¿½ï¿½mï¿½s`ï¿½ï¿½6vï¿½Wï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Xeï¿½ï¿½OÖ‡ï¿½ï¿½ï¿½J&Cï¿½Qï¿½9nï¿½Xï¿½ï¿½ ï¿½wï¿½ !;>ï¿½rziyï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½È‘ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½&G<Å½ï¿½Kï¿½+ï¿½ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½:ï¿½ï¿½sï¿½ï·¿ï¿½mN~ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6aï¿½ï¿½ï¿½ï¿½+^N	ï¿½ï¿½AEï¿½k/ï¿½+ï¿½ï¿½ï¿½ï¿½EMMï¿½8F!Lï¿½ï¿½ï¿½aMu5ï¿½wï¿½Yï¿½& Ò¢Hf<ï¿½=ï¿½%ï¿½z\Bï¿½ï¿½*ï¿½n`r56ï¿½ï¿½ï¿½)Kw<ru\ÙŽ)ï¿½ï¿½>rï¿½fï¿½ï¿½ï¿½ï¿½Ã€5ï¿½Uï¿½;.Æ…"ï¿½.CIï¿½&ï¿½ï¿½"ï¿½ï¿½qï¿½YCï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½1TQ5ï¿½ï¿½ï¿½oï¿½:ï¿½ï¿½ï¿½<.ï¿½ï¿½.ï¿½|aï¿½an8ì“¯ï¿½Ã¦TN-ï¿½Lï¿½{a0ï¿½ï¿½Vï¿½ï¿½ï¿½Îµï¿½pï¿½$ï¿½8ï¿½HQï¿½ï¿½ï¿½ï¿½Aï¿½Ê²ï¿½Ã–kï¿½ï¿½~ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½Ç•ï¿½Ú¯ï¿½ï¿½`Sï¿½T|Xï¿½0ï¿½ï¿½dï¿½Ê¬+&>ï¿½*ï¿½Bï¿½[u4ï¿½ï¿½gzï¿½ï¿½Ï±ï¿½ï¿½zï¿½yï¿½ï¿½Qï¿½ï¿½ï¿½&N_[ï¿½}Ì¼ï¿½ï¿½kZÉ³ï¿½cP(ï¿½Xï¿½Lï¿½5ï¿½ï¿½ï¿½sï¿½ï¿½<ï¿½ï¿½ï¿½ 
ï¿½ï¿½uï¿½ï¿½Wï¿½Cï¿½ï¿½ï¿½ãkï¿½ï¿½ï¿½8ï¿½ï¿½NNd
B_wï¿½8+ï¿½ qï¿½ï¿½z+ï¿½ï¿½ï¿½$ï¿½"*A,`ï¿½,ï¿½ï¿½ï¿½<ï¿½ÍŒ.ï¿½ï¿½ï¿½'Ó¬@ï¿½ï¿½Nï¿½ï¿½ï¿½@ï¿½8ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½j:]Dï¿½ï¿½<ï¿½+ï¿½mVï¿½(ï¿½ï¿½6ï¿½(ï¿½xï¿½ï¿½ï¿½f*Wï¿½i_^\ï¿½>ï¿½ï¿½Qï¿½d}{r\g@ï¿½Zï¿½sï¿½4Pq/Lï¿½Kï¿½ï¿½ï¿½Uï¿½Aï¿½W"ï¿½ï¿½Þš0qï¿½65ï¿½ï¿½Oï¿½]Ï‰3B|ï¿½b1ï¿½ï¿½H)1'1r
ï¿½Pï¿½xï¿½ï¿½*ï¿½ï¿½Imï¿½ï¿½%ï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½jxï¿½iï¿½*ï¿½ï¿½mkï¿½ï¿½sfï¿½*U%wï¿½ï¿½APï¿½ï¿½ï¿½ï¿½ï¿½Ag-ï¿½$ï¿½éŽ¡ï¿½ï¿½;V>?ï¿½Jï¿½ï¿½ ï¿½Wl~ï¿½m\ï¿½ï¿½ï¿½ï¿½Ü¯ï¿½ï¿½ï¿½Û¸ê±—8J&<ï¿½3ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç“ï¿½7ï¿½ï¿½
cï¿½aï¿½ï¿½.Í˜	ax6ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*ï¿½pï¿½>ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½ypï¿½ï¿½t2ï¿½ï¿½3ï¿½#Sï¿½X&ï¿½ï¿½v2iï¿½ï¿½ ï¿½
Cï¿½Ä²Lï¿½ï¿½1ï¿½x)ï¿½x&|ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½,ï¿½ï¿½
Û™Vï¿½qï¿½ï¿½ï¿½vï¿½n.ï¿½ï¿½v C!X ï¿½ï¿½qÓ*vNï¿½ï¿½lï¿½ï¿½VQmï¿½Y@ï¿½ï¿½E|5ï¿½ï¿½ï¿½ ï¿½ï¿½zï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç•ï¿½Vï¿½+É½ï¿½hï¿½ï¿½ï¿½K{ï¿½ï¿½ï¿½;U%bï¿½ï¿½#ï¿½7ï¿½ï¿½ï¿½ï¿½jï¿½jï¿½ï¿½jï¿½WTpï¿½ï¿½Gï¿½R?.ï¿½ï¿½ï¿½Imï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½3^nWï¿½ï¿½n,ï¿½ï¿½Ð°ï¿½gï¿½D\ï¿½}C9#qx
ï¿½ï¿½mï¿½
ï¿½13ï¿½ï¿½ï¿½@#Fï¿½Sooï¿½ï¿½wRwOï¿½ï¿½ï¿½rc"<ï¿½[^VFUÃªï¿½ï¿½!ï¿½ï¿½ï¿½Ctï¿½ï¿½ï¿½ï¿½Xfï¿½Å—e ï¿½ï¿½Ð¡kï¿½ÐŸÇ­ï¿½ï¿½ï¿½ï¿½ï¿½r;v4ï¿½tjï¿½8ï¿½:+ï¿½5iï¿½ï¿½%ï¿½Å´gï¿½>vîž¤|ï¿½ï¿½ï¿½@ï¿½ï¿½9ï¿½Ï’5[N+ï¿½+hï¿½ï¿½qtï¿½ï¿½ï¿½ï¿½ï¿½a7Â¦3ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½,#ï¿½~#~ï¿½zï¿½ï¿½Kï¿½ï¿½ï¿½|ï¿½Ï¡ï¿½ï¿½ ï¿½ï¿½ï¿½qï¿½ï¿½8lï¿½KW\ï¿½ï¿½ï¿½ï¿½c8ï¿½vwï¿½1Û‚6h;vï¿½(G#[ï¿½ï¿½Pkï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½=Lï¿½ï¿½Sï¿½Ãšï¿½ï¿½ï¿½Yï¿½uï¿½Aï¿½@ï¿½]ï¿½8ï¿½ï¿½ï¿½ï¿½Ñœï¿½Vï¿½ï¿½yGï¿½ï¿½ï¿½ï¿½Wr^!ï¿½ï¿½ï¿½mï¿½hcXï¿½={ï¿½ï¿½<.bï¿½ï¿½=ï¿½5ï¿½ï¿½ï¿½-ï¿½ï¿½Ø¾}|ï¿½ï¿½ï¿½Bï¿½ZZZï¿½Ý†ï¿½Bï¿½ï¿½myVA#nï¿½ï¿½ï¿½g>sï¿½ï¿½"nï¿½
ï¿½ï¿½jï¿½ï¿½ï¿½+ï¿½ï¿½5ï¿½^ï¿½Úµ{/ï¿½xï¿½ï¿½8ï¿½ï¿½sÎ¤ï¿½Æï¿½G{"ï¿½sØ‰ï¿½ï¿½Vï¿½mï¿½ï¿½ï¿½oï¿½Yqï¿½dï¿½ï¿½bvï¿½Lï¿½*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½7ï¿½Cï¿½5"rï¿½ï¿½
ï¿½ï¿½ï¿½pÚ¹gï¿½ï¿½:/ï¿½u+^]ï¿½Ó‚d7bÑ¢ï¿½ï¿½m7ï¿½ï¿½Gï¿½ï¿½Y@ï¿½ï¿½ï¿½ï¿½Sï¿½ï¿½~p7ï¿½Í£ÎŸw^(zï¿½ï¿½QCï¿½ï¿½eï¿½ï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½V(ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½6ï¿½2ï¿½Yï¿½uZï¿½ï¿½ï¿½[ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,, ï¿½ï¿½ï¿½ï—”ï¿½ï¿½ï¿½gS1ï¿½ï¿½=?ï¿½Û‘`ï¿½ï¿½gï¿½?zï¿½9nï¿½ï¿½ï¿½,ï¿½#ï¿½jï¿½VÔï¿½iï¿½ï¿½o ï¿½ï¿½%xï¿½ï¿½'ï¿½Dï¿½ï¿½ï¿½ï¿½___o3ï¿½Ó¿ï¿½|3Nï¿½tï¿½=ï¿½g3pï¿½Xï¿½/ï¿½ï¿½"ï¿½ï¿½ï¿½@ï¿½ï¿½s\^ï¿½ï¿½ï¿½d1ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½yï¿½9n
ï¿½ï¿½-7ï¿½_Þ£Î‹ï¿½ï¿½n~ï¿½Lw#ï¿½ï¿½y.ï¿½ZQï¿½ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Muï¿½9ï¿½y=lï¿½ï¿½5bDï¿½ï¿½`8.ï¿½Gï¿½8/G^L(ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½nï¿½ï¿½ï¿½%ï¿½ï¿½ï¿½ï¿½,ï¿½ 8hï¿½+ï¿½ï¿½Gï¿½9ï¿½ï¿½ï¿½t'ï¿½Mk;ï¿½ï¿½ï¿½r^<ï¿½0eï¿½ï¿½usï¿½ ï¿½Ö¯x#ï¿½'<xï¿½ï¿½o~Mï¿½ï¿½ï¿½Bw#.ï¿½Õ‰ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½g"ï¿½Fï¿½ï¿½ï¿½kï¿½ï¿½:ßˆï¿½-/ï¿½ï¿½Nï¿½Ç %+gï¿½uN2RTï¿½ï¿½ï¿½Tï¿½nï¿½ï¿½ï¿½8ç½›ï¿½#/ï¿½ï¿½ï¿½ï¿½?6ï¿½3xï¿½ï¿½Jï¿½ï¿½qï¿½0ï¿½jVï¿½F^Å½Ð—ï¿½M5ï¿½*lEï¿½ï¿½ï¿½ÚŽï¿½ï¿½Q
ï¿½ï¿½wï¿½Vï¿½ï¿½Î«ï¿½
kï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½ï¿½<Xï¿½Dï¿½[0É’6ï¿½G^3Ï©ï¿½ß¨ï¿½ï¿½^?Iï¿½^ï¿½ï¿½ï¿½qï¿½ï¿½B\Nï¿½ï¿½+ï¿½
ï¿½gï¿½ï¿½#ï¿½j9xï¿½ï¿½ï¿½y?7`ï¿½ï¿½bï¿½ï¿½
T[[PRï¿½<hï¿½ï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½ï¿½uï¿½Mkï¿½ï¿½ï¿½ï¿½9Pï¿½ï¿½	ï¿½ï¿½ï¿½ï¿½q|ï¿½ï¿½}gï¿½6zyyiï¿½ï¿½ï¿½ï¿½ï¿½sR!]@Xï¿½R:;;ï¿½nWYi)ï¿½ï¿½ï¿½ï¿½n
%ï¿½O8-ï¿½ï¿½xï¿½m_Î¼QÄ™ï¿½Hï¿½ï¿½ï¿½ï¿½apRï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wÅŠï¿½ï¿½ï¿½Ï¿iï¿½ï¿½9ï¿½ï¿½|Aï¿½Fq\,ï¿½ï¿½ï¿½ERWWï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ð‹ï¿½ï¿½ï¿½
ï¿½TR\ï¿½ï¿½ï¿½ï¿½i'L<ï¿½ï¿½ï¿½Û©ï¿½~8Kï¿½JPdï¿½ï¿½Gï¿½wï¿½ï¿½?ï¿½O/ï¿½ï¿½ï¿½ï¿½3ï¿½RÍ·wï¿½sï¿½%ï¿½"ï¿½ï¿½ï¿½b`ï¿½ï¿½y#9ÂŸï¿½9ï¿½Ã‘2tï¿½ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½Wï¿½Ïš5Kï¿½vÂ„ï¿½ï¿½ï¿½ï¿½3ï¿½ï¿½q\3ï¿½ï¿½ï¿½ï¿½Gï¿½+^ï¿½ï¿½á¼™Î¿ï¿½ï¿½ï¿½?ï¿½ï¿½Ãï¿½ï¿½Tqï¿½p<ï¿½xï¿½ï¿½aï¿½Ó9Bï¿½ï¿½ï¿½ï¿½(ï¿½fï¿½xï¿½ï¿½ï¿½ï¿½#ï¿½Dï¿½Vï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½ï¿½"/;ï¿½D\xnï¿½ï¿½_ï¿½ï¿½ï¿½2ÇŽNï¿½uÂ¹8ï¿½|ï¿½F}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½DNï¿½iVï¿½\ï¿½>-ï¿½ï¿½ï¿½{]ï¿½Ê§ï¿½ï¿½pï¿½=ï¿½3je9ï¿½ï¿½Oï¿½Qï¿½ï¿½ï¿½ï¿½>ï¿½Yï¿½ï¿½ï¿½qï¿½ï¿½qï¿½1ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½7ï¿½Gï¿½ï¿½ï¿½nï¿½yï¿½]wGÍˆAï¿½Ãœï¿½qï¿½Wï¿½Ë¼oï¿½mï¿½ï¿½ï¿½ï¿½C~ï¿½ï¿½wï¿½SÏ¿8ï¿½o;ï¿½Jwï¿½qU9KYq<OEWï¿½ï¿½PÕŠï¿½ï¿½Z@ï¿½;ï¿½ï¿½Oï¿½ï¿½gï¿½gï¿½ï¿½?ï¿½#ï¿½\ï¿½ï¿½ï¿½O{ï¿½Î™ï¿½nï¿½ï¿½ï¿½(Wzï¿½ï¿½OJ7ï¿½Fï¿½Cï¿½pï¿½RÞ¢ï¿½ve/oSb{ï¿½ï¿½{#2pD\\ï¿½`gï¿½ï¿½ï¿½Wï¿½Cï¿½qÍ¾4ï¿½21ï¿½ï¿½LÂ‘ï¿½-ï¿½Gï¿½JkuFuï¿½
~!ï¿½j;ï¿½ï¿½ ï¿½-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'ï¿½7ï¿½ï¿½6YNï¿½ï¿½
Mï¿½ï¿½ï¿½ï¿½vï¿½ceï¿½ï¿½4+(^hKHEï¿½ï¿½ï¿½Ç€Z Nï¿½ï¿½ï¿½ï¿½fï¿½hï¿½?D^Lï¿½wï¿½ï¿½tï¿½ï¿½ï¿½ï¿½<ï¿½`ï¿½dï¿½ï¿½ï¿½$#3ï¿½iiVï¿½i[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½N
ï¿½Q=ï¿½s\ï¿½=Öˆï¿½ï¿½;8(ï¿½F\ãœˆï¿½ï¿½ï¿½P#ï¿½ï¿½^ï¿½HWï¿½Ô•ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½gu:ï¿½Gï¿½:ï¿½ï¿½=Vï¿½lï¿½;Sï¿½<ï¿½ï¿½ï¿½mVï¿½ Wï¿½kï¿½8`ï¿½rï¿½S-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½qï¿½GÜ“ï¿½"ï¿½ï¿½+IO9ï¿½ï¿½jï¿½Md;ß™ï¿½;ï¿½ï¿½ï¿½ï¿½QqRï¿½rï¿½ï¿½ÚŠï¿½"-w\ï¿½ECï¿½ï¿½6ï¿½xï¿½ï¿½r\ï¿½lï¿½ï¿½IqIï¿½%(>dg,R\,tï¿½ï¿½ï¿½yTFwï¿½ï¿½ï¿½ <ï¿½ï¿½!mï¿½8ï¿½ï¿½\ï¿½?ï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½69á¬¤ï¿½ur['ï¿½ï¿½Hï¿½,ï¿½ï¿½7ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½qï¿½ï¿½ï¿½?Iï¿½ï¿½s\ï¿½,.r5ï¿½ï¿½ï¿½k0:ï¿½Eeï¿½Z ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ç¸ºï¿½ï¿½F\'vï¿½ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½=ï¿½ï¿½;o'ï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½&ï¿½ï¿½gï¿½ï¿½ï¿½}s\^'ï¿½Zï¿½yaJï¿½Quæ ´ï¿½<ï¿½eï¿½ï¿½ï¿½-ï¿½g;ß™ï¿½{r\dï¿½ï¿½Eq/T.o=:EQï¿½ï¿½9ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½:2MQï¿½jF3ahÌ›ï¿½ï¿½1ï¿½ï¿½;ï¿½*8Î NaC5ï¿½cï¿½+ï¿½GGï¿½ÒƒBï¿½Bï¿½vï¿½pï¿½ï¿½mï¿½ï¿½ï¿½}bï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½cSuï¿½@×¥* ru:oï¿½ï¿½ï¿½;g~Lï¿½Sï¿½ï¿½ï¿½ï¿½Z7ï¿½ï¿½ï¿½qï¿½ï¿½Cï¿½ï¿½?ï¿½ ï¿½
ï¿½Å¸ï¿½ï¿½ï¿½8ï¿½ ï¿½ï¿½ï¿½ï¿½×Ÿï¿½ï¿½>ï¿½zï¿½ï¿½MCB_qÔï¿½+ï¿½ï¿½$ï¿½ï¿½4ï¿½5ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½Qï¿½ï¿½H<ï¿½ï¿½Kï¿½T&iï¿½ï¿½ï¿½:ï¿½B
ï¿½ï¿½;CV3ï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½w>\ï¿½<==Ö€;uï¿½xï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½;ï¿½QGWï¿½wï¿½ZÚºiË®6ï¿½ï¿½ï¿½~ï¿½jHvï¿½kï¿½ï¿½fï¿½ï¿½wï¿½^ï¿½ï¿½7-xï¿½Qgwuï¿½ï¿½ï¿½|<ï¿½ï¿½/ï¿½ï¿½<ï¿½ï¿½GÚï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½stï¿½Sï¿½Oï¿½qï¿½ï¿½x4ï¿½ï¿½ï¿½ï¿½ï¿½Ï¡1ï¿½É.ï¿½ï¿½Thï¿½ï¿½ï¿½ï¿½Apå‡¾ï¿½ï¿½ï¿½ï¿½ï¿½VÓºï¿½ï¿½,ï¿½e~ï¿½Eï¿½ï¿½-9ï¿½Úï¿½ï¿½?{ï¿½ï¿½_ï¿½ï¿½ï¿½'ï¿½V&ï¿½W.ï¿½(8>^Yï¿½L?|x
:ï¿½C#ï¿½Wï¿½ï¿½[Ï£)'ï¿½S[g}ï¿½gï¿½Ñ³ï¿½ï¿½ÞŠï¿½ï¿½ï¿½ï¿½x}ð²©´|ï¿½ï¿½ï¿½ï¿½^ï¿½ï¿½tï¿½ï¿½ï¿½|ï¿½ï¿½ï¿½#W6ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½ï¿½^ï¿½0ï¿½ï¿½e!ï¿½zRï¿½ï¿½vï¿½nï¿½ï¿½
Úºï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Dï¿½fï¿½+ï¿½1ï¿½ï¿½/_ï¿½6HÞ’ï¿½ï¿½{ï¿½
ï¿½w"ï¿½ï¿½ï¿½&ÆšOï¿½
q3ï¿½ï¿½vfWï¿½
&	]ze
ï¿½ï¿½ï¿½Ñ‹ï¿½ï¿½xï¿½{ï¿½ï¿½ï¿½}pï¿½ï¿½ï¿½ï¿½.ï¿½?ï¿½>{ï¿½ï¿½3}$;qï¿½^ï¿½ï¿½ï¿½ï¿½â´¥%ï¿½ï¿½`ï¿½Cï¿½ï¿½ï¿½ï¿½kï¿½yï¿½aw4~i;Õ³ï¿½ï¿½[ï¿½ï¿½ï¿½?ï¿½#zï¿½ï¿½ï¿½ï¿½gï¿½Eï¿½`ï¿½ï¿½dï¿½ï¿½?ï¿½@^{ï¿½Yï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½+ï¿½k1Eï¿½ï¿½`'=ï¿½ï¿½&^ï¿½Eï¿½ï¿½ï¿½,N;wï¿½hï¿½ï¿½ï¿½ï¿½ï¿½VÓ½ï¿½YK+ï¿½5}0ì§±ï¿½5ï¿½d1ï¿½ï¿½$:ï¿½ï¿½Wï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½-ï¿½+WQï¿½Oï¿½ÅŠï¿½`ï¿½ï¿½}ï¿½)|Í¦ï¿½8ï¿½ï¿½ï¿½ï¿½h2ï¿½=sUUï¿½Ñ¿ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½5ï¿½ï¿½0GÖ²2^Qï¿½jï¿½\0ï¿½>ï¿½x=ï¿½ï¿½Vï¿½ï¿½ï¿½_ï¿½g^ï¿½Eï¿½ï¿½ï¿½lï¿½ï¿½KÛ¤ï¿½ï¿½ï¿½
ÇŸï¿½Qsï¿½ï¿½fzbï¿½6ï¿½ï¿½qBï¿½ï¿½?xï¿½ï¿½T_SFï¿½-ï¿½ï¿½8ï¿½'ï¿½Wï¿½ï¿½lï¿½ï¿½ß¶qï¿½~ï¿½ï¿½zuï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½zsï¿½Aï¿½ï¿½oï¿½<ï¿½ï¿½Ó—Ã´zï¿½ï¿½=ï¿½qPì‡ˆï¿½y	2ï¿½0cï¿½ï¿½ï¿½rï¿½ï¿½pï¿½k(ï¿½JWï¿½eï¿½Gï¿½Ö‰ï¿½ï¿½ï¿½ï¿½ï¿½DUfvSï¿½dß ~/ï¿½:ï¿½zï¿½Ëžï¿½ï¿½fï¿½wï¿½_I;ï¿½!D0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4v>Dï¿½ï¿½ï¿½ï¿½NKï¿½ï¿½ï¿½]ï¿½Ìœ2\ï¿½oï¿½d^È‡ï¿½vï¿½ï¿½.7ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Î†ï¿½ï¿½4ï¿½Fï¿½ï¿½ï¿½ï¿½`ï¿½Oï¿½ï¿½ï¿½uï¿½4}Bï¿½È›zï¿½yï¿½*roï¿½ï¿½?ï¿½[IXï¿½Uï¿½ï¿½|ï¿½iï¿½1äºƒe?ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Uï¿½;^jï¿½å®Bï¿½ï¿½K8+Ñ¶ï¿½ï¿½zMï¿½sï¿½6ï¿½ï¿½ï¿½_&9ï¿½mï¿½ï¿½ï¿½'6ï¿½)yï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½ï¿½Zï¿½a?]:b<=ï¿½ï¿½nj=ï¿½-N=ï¿½xï¿½o_H5ï¿½ï¿½Wï¿½9ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|Ñ‡2ï¿½|ï¿½ï¿½&
ï¿½oAtï¿½ï¿½ï¿½ï¿½ï¿½ï¿½N|ï¿½Dï¿½ï¸„&ï¿½ï¿½ï¿½/ï¿½ï¿½èƒ‹ï¿½ï¿½ï¿½ï¿½ï¿½3ï¿½ï¿½_ï¿½ï¿½ï¿½0ï¿½[ï¿½ï¿½Lï¿½ï¿½ï¿½\pcitï¿½ï¿½ï¿½ ï¿½ï¿½F>1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½g>ï¿½rï¿½3gï¿½tï¿½,ï¿½rï¿½Â‰ï¿½è³›ï¿½?yï¿½~ï¿½ï¿½zï¿½Ä»ï¿½=ï¿½ï¿½ÞŠn6ï¿½ï¿½l ï¿½ï¿½ï¿½ï¿½ÎŸDï¿½<ï¿½ï¿½ï¿½ï¿½ï¿½iGï¿½ï¿½ï¿½ï¿½/ï¿½ï¿½Ç¯>ï¿½f8ï¿½"ï¿½ï¿½L&ï¿½8ï¿½]{ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½w$~aï¿½^ï¿½ï¿½=ï¿½(ï¿½ï¿½ï¿½ï¿½b/U"6?ï¿½Qï¿½ï¿½!ï¿½ÅºPï¿½7+.Wï¿½ï¿½Ø±ï¿½"
'ï¿½ï¿½p0 ï¿½Wo:ï¿½ï¿½}ï¿½kreï¿½ï¿½{ï¿½sgï¿½ï¿½]ï¿½@ï¿½:ï¿½{ï¿½//ï¿½ï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½ï¿½W3ï¿½ï¿½"3ï¿½ï¿½4Swï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/+vï¿½ï¿½ï¿½ï¿½Mï¿½ï¿½ï¿½4zeï¿½q:ï¿½ï¿½h)ï¿½M.ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½8ï¿½ï¿½Bï¿½Fï¿½ï¿½ï¿½?ï¿½dï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½l?ï¿½iï¿½ï¿½
ï¿½ï¿½ï¿½Fï¿½ï¿½+nï¿½.?uzï¿½Pï¿½ï¿½ZÉ¹ï¿½_ï¿½ï¿½a:cï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½G:ï¿½ÒCï¿½PWEï¿½Uï¿½ï¿½Kï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½}4zDï¿½DHIJ-z*ï¿½~ï¿½ï¿½ï¿½ï¿½Ó¨ï¿½Õœ&ï¿½Bï¿½ï¿½ï¿½rï¿½ï¿½Fï¿½ï¿½ï¿½Y9ï¿½ï¿½\ï¿½ï¿½
\ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½Aï¿½$ï¿½ï¿½Jï¿½ï¿½}ï¿½;[ï¿½ï¿½ï¿½ï¿½CMmï¿½cï¿½qDï¿½ï¿½ÙŠï¿½bï¿½-ï¿½Ç«*ï¿½y'ï¿½Fï¿½ï¿½ï¿½{ï¿½ï¿½Fï¿½ï¿½Mtï¿½F?ï¿½ï¿½eLCï¿½ï¿½0ï¿½ï¿½ï¿½%ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½Hï¿½ï¿½~ï¿½Y&ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½r\6]vï¿½]ï¿½Zï¿½ï¿½XIJï¿½ï¿½$0çˆ£wï¿½VsQ1ï¿½cs ï¿½ï¿½=ï¿½Vï¿½ï¿½Xï¿½ï¿½ï¿½r\ï¿½$r(ï¿½ï¿½[iï¿½t6Xcï¿½Bï¿½ï¿½ï¿½Wï¿½
ï¿½ï¿½WKXï¿½ï¿½8ï¿½ï¿½ï¿½'ï¿½ï¿½lLï¿½ï¿½
ï¿½ï¿½'Â†ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½x"'Kxï¿½ï¿½PMRHï¿½ï¿½ï¿½Mï¿½ï¿½=ï¿½ï¿½GO5#Iï¿½o .ï¿½ï¿½ï¿½/l{ï¿½ï¿½
1y	9ï¿½BYï¿½Åµ]}Kï¿½ï¿½ï¿½Â±q0ï¿½ï¿½Q
ï¿½>q'Jgï¿½ï¿½ï¿½ï¿½qCï¿½Pï¿½0ï¿½Øˆï¿½ï¿½2ï¿½~ï¿½ï¿½Zï¿½Ü¨ï¿½ï¿½F6ï¿½xï¿½â¹©ï¿½ï¿½ï¿½ï¿½Yï¿½pï¿½ï¿½ï¿½ï¿½jï¿½^ï¿½ZÅœï¿½lhn+y/ï¿½'(ï¿½ï¿½ï¿½ï¿½,qï¿½1ï¿½ÛŸï¿½n,Yï¿½ï¿½pï¿½|ï¿½ï¿½iO:ï¿½ï¿½ï¿½×žï¿½ï¿½ï¿½Bï¿½ï¿½H?ï¿½ï¿½".`ï¿½Sï¿½ï¿½Cï¿½+	ï¿½,ï¿½ï¿½+ï¿½ï¿½>ï¿½dï¿½ï¿½Hï¿½k
9fxBï¿½ï¿½Oï¿½7ï¿½>.k):ï¿½ÞŸï¿½ï¿½f*.(ï¿½ï¿½Y-ï¿½ï¿½ï¿½;ï¿½ï¿½Cï¿½ï¿½{ï¿½ï¿½ï¿½VB"Nbï¿½uï¿½ï¿½!]ï¿½ï¿½`ï¿½Ã….,
ï¿½jï¿½Gp(Ùï¿½
3hï¿½Qï¿½3<ï¿½qï¿½ï¿½ï¿½Y*ï¿½ï¿½aï¿½Iï¿½ï¿½-sï¿½ï¿½qï¿½3ï¿½ï¿½aï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½Cï¿½EWï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½/vï¿½ï¿½ï¿½ï¿½N`QrÂ€Pï¿½ï¿½ï¿½ï¿½ï¿½820ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½l{
ï¿½}xï¿½dï¿½Bï¿½ï¿½e|@ï¿½yr\ï¿½spFï¿½rï¿½ï¿½toÄï¿½<ï¿½ï¿½
ï¿½ï¿½jaï¿½/ï¿½Ð—nx`Dw&ï¿½crï¿½ï¿½ï¿½ï¿½Eï¿½U6ï¿½ï¿½ï¿½ï¿½ï¿½r\ï¿½4gï¿½ ï¿½Eï¿½ï¿½Å…b>ï¿½Nqï¿½ËŠï¿½cï¿½"ï¿½ï¿½Rï¿½qï¿½ï¿½uï¿½ï¿½ï¿½3ï¿½ï¿½\ï¿½_ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½Nï¿½9ï¿½nÄ…sï¿½%Muaï¿½ï¿½rLï¿½ï¿½ï¿½"Ý‡7ï¿½aï¿½mï¿½ï¿½*Bï¿½ï¿½ï¿½$ë²¢ï¿½
Y
ï¿½4ï¿½Wï¿½vï¿½ï¿½Aï¿½<ï¿½2Oï¿½ï¿½ebÂ»ï¿½ï¿½9ï¿½Ü[ï¿½{Pï¿½ï¿½dWï¿½ï¿½ Uï¿½ï¿½ï¿½Mï¿½Iï¿½/ï¿½ï¿½>Tï¿½gf$6>ï¿½]ï¿½ï¿½Oï¿½Þ“ï¿½cï¿½ï¿½ï¿½ï¿½sï¿½pï¿½ï¿½sï¿½hï¿½nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6ï¿½Ñ¾ï¿½ï¿½ï¿½ï¿½ï¿½y5Rï¿½dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½oï¿½)ï¿½ï¿½r*-ï¿½ï¿½ï¿½ï¿½Rï¿½ï¿½ï¿½1^q2ï¿½'ï¿½ï¿½ï¿½[h~`ï¿½fï¿½Qï¿½9.\ï¿½%ï¿½ï¿½0ï¿½ï¿½2Ç¡ï¿½ï¿½Ø¡ 1ï¿½^vï¿½ï¿½#ï¿½ï¿½ï¿½Fï¿½ï¿½TRZBï¿½ï¿½m`*ï¿½W*ï¿½,Ç¨ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½N\Fï¿½U5ï¿½Wï¿½ï¿½[ï¿½Caï¿½ï¿½ï¿½gï¿½~ï¿½ï¿½ï¿½ï¿½sï¿½|ï¿½45ï¿½ï¿½ï¿½BÃï¿½çºº:ï¿½Pï¿½~~cï¿½ï¿½ï¿½Ruu
ï¿½ï¿½ï¿½qDMWï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½!ï¿½_:ï¿½ï¿½J=ï¿½T];ï¿½eï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½Þ™ï¿½XNï¿½
ï¿½ï¿½qï¿½ï¿½].ï¿½9[ï¿½ï¿½ï¿½ï¿½Î¸ï¿½ï¿½hï¿½ï¿½ï¿½pï¿½ï¿½QLï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½i[ì¥ºï¿½j1ï¿½ï¿½ï¿½ï¿½ï¿½Vï¿½ï¿½&ï¿½ï¿½rï¿½ï¿½ï¿½ï¿½nï¿½ï¿½Ê¨ï¿½ï¿½ ï¿½Û³ï¿½Fï¿½Oeâ¼…1ï¿½Ø¨ï¿½ï¿½yCï¿½
0ï¿½ï¿½#Yï¿½ï¿½ï¿½9ï¿½ï¿½0	fï¿½ÅŽï¿½ï¿½ï¿½8ï¿½Mcï¿½Zh8Vfoo'ï¿½4ï¿½ï¿½ï¿½ï¿½ï¿½Ð¨Qchï¿½ï¿½1ï¿½ï¿½ï¿½Cï¿½[[WÇ²FÓ°ï¿½rÚ·{;Gaï¿½Fï¿½Bï¿½ï¿½>p:Prï¿½ï¿½Tï¿½Ýˆï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½\qï¿½(;Äªï¿½ï¿½ï¿½2ï¿½ï¿½ï¿½&ï¿½PHï¿½Qvï¿½ï¿½{wSÍ°a4rï¿½(ï¿½ï¿½ï¿½ï¿½yn<ï¿½4ï¿½ï¿½ï¿½Fï¿½ï¿½]ï¿½wQgGï¿½
ï¿½nï¿½Iï¿½'4?Hï¿½_\ï¿½+ï¿½lï¿½Eï¿½3ï¿½ï¿½ï¿½ï¿½JIï¿½,ï¿½ï¿½Ý¬hï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½*xï¿½Aï¿½ï¿½ï¿½Cï¿½|ï¿½-ï¿½Ó»;ï¿½ï¿½loo/ß²ï¿½WHï¿½ï¿½xî¢˜**Lï¿½
zG{;ï¿½3ï¿½u.'ï¿½ï¿½ï¿½DcC#mß¹ï¿½yï¿½=cï¿½?ï¿½9ï¿½ï¿½'ï¿½3Oï¿½Ì¹ï¿½	ï¿½ï¿½ï¿½ï¿½bHï¿½Hï¿½+ï¿½ï¿½Î¥ï¿½ï¿½ï¿½ZKï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½KK=5ï¿½ï¿½ï¿½8PQï¿½} ï¿½ï¿½|Aï¿½sï¿½Vj^Gï¿½ï¿½ï¿½dÐŽzï¿½ï¿½ï¿½ï¿½ï¿½c;^ï¿½+xfï¿½ï¿½1ï¿½ï¿½/ï¿½ï¿½ï¿½~ï¿½6lï¿½@---TSSM3fï¿½Fgï¿½9ï¿½,Nï¿½	ï¿½ï¿½ï¿½jï¿½dï¿½ï¿½ï¿½nï¿½ï¿½a^ï¿½WEï¿½=ï¿½ ï¿½0ï¿½ï¿½1~ï¿½uï¿½ï¿½ï¿½3ï¿½ï¿½=ï¿½ï¿½<B7ï¿½ï¿½ ï¿½ï¿½+ï¿½ï¿½kÄ•ï¿½ï¿½sï¿½ï¿½eRzï¿½ï¿½}rï¿½ï¿½ï¿½ï¿½Dï¿½Eï¿½Aï¿½5ï¿½
ï¿½KGï¿½ï¿½ï¿½ï¿½ï¿½Bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½[iï¿½[oï¿½ï¿½ï¿½ï¿½fjhlï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Aï¿½gÍ¢ï¿½~ï¿½ï¿½nyï¿½N7ï¿½Ö¬yï¿½Ö¯[Oï¿½9ï¿½=ï¿½ï¿½mQï¿½Kï¿½ï¿½sï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½gï¿½lg~Ç—ï¿½ï¿½ï¿½ï¿½nï¿½ï¿½sï¿½8ï¿½pï¿½Mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½iBï¿½<(ï¿½ï¿½ï¿½Ó¤ï¿½ï¿½ï¿½)x]oï¿½_ï¿½v
Íš}6ï¿½>9ï¿½ï¿½\ï¿½:ï¿½9wï¿½\ï¿½ï¿½ ï¿½<ï¿½_ï¿½ï¿½ï¿½ï¿½kï¿½ï¿½Í¸YS-ï¿½ï¿½ï¿½]@3gÎ¤uï¿½ï¿½Ñ“O>Isï¿½Î¥3ï¿½<ï¿½wï¿½ï¿½ï¿½ï¿½ï¿½6mzï¿½ï¿½Oï¿½Nsï¿½=ï¿½ï¿½vpï¿½-ï¿½ ï¿½pï¿½Û¾cï¿½7ï¿½ï¿½Gaï¿½Pï¿½,Ø˜ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½:ï¿½ï¿½?ï¿½å¸†ï¿½p_ï¿½x1<#:4ï¿½ï¿½ï¿½8 W|ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½ï¿½pG9ï¿½C:S0ï¿½tï¿½ï¿½8ï¿½ï¿½ï¿½\ï¿½J<ï¿½ï¿½ï¿½ï¿½ï¿½)Sï¿½ï¿½)ï¿½ï¿½ï¿½3~Ø¤ï¿½&Nï¿½ ï¿½ï¿½IÝ½{7Mcï¿½mimï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½ï¿½!ï¿½~ï¿½ï¿½ï¿½Â˜ï¿½+uÈƒ0~ï¿½ï¿½ï¿½?ï¿½ï¿½rï¿½ aï¿½bï¿½ï¿½0)oï¿½ï¿½ï¿½Wï¿½ï¿½(ï¿½8f8|ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½kjiÜ¸SXï¿½ï¿½^ï¿½Sï¿½[ï¿½|ï¿½ï¿½Ã¹0Qï¿½Zï¿½ï¿½xXï¿½ï¿½ÍŸTï¿½W]wï¿½uï¿½6ï¿½{Ø‰ï¿½*ï¿½ï¿½ï¿½krï¿½bÞ¼y>ï¿½ï¿½}ï¿½ï¿½ï¿½[ï¿½ï¿½ß‰sï¿½!ï¿½-qï¿½ ï¿½wï¿½ï¿½ï¿½sï¿½8mÜ¸Aï¿½2ï¿½ï¿½aï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½>.[ï¿½Wï¿½>ï¿½ï¿½_ï¿½ï¿½zï¿½Ù§8:ï¿½ï¿½Lï¿½ï¿½[ï¿½ï¿½Â€x0;ï¿½ï¿½ï¿½ NGNï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½.ï¿½6oï¿½$<ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½GÛ·mKï¿½ï¿½ï¿½ï¿½nï¿½{9oï¿½ï¿½ï¿½ï¿½ï¿½gÏ®ï¿½ï¿½sOÑ²ï¿½~ï¿½h|ï¿½ï¿½ï¿½ï¿½quqï¿½Eï¿½pï¿½	ï¿½ï¿½ï¿½6Nï¿½i6ï¿½,ï¿½&rï¿½w~ï¿½[ï¿½ï¿½_vÅ•|:E5ï¿½uï¿½ï¿½ï¿½bWEUu !ï¿½uhã¼´ï¿½ï¿½ï¿½/ï¿½pÑ”Xï¿½#;ï¿½&ï¿½cï¿½ï¿½ï¿½Ò†ï¿½%ÚŽ;ï¿½ï¿½Sè¥‰ï¿½&ï¿½Ô©SyPbIWï¿½Ñ¾>vï¿½4~Â©ï¿½9ï¿½aï¿½(ï¿½@C<Hï¿½ï¿½#mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½P(ï¿½|gÒ¾hï¿½ï¿½
ï¿½ï¿½qï¿½ï¿½
/ï¿½Þ±ï¿½Æ‡>ï¿½ï¿½2ï¿½o@ï¿½8Ü¯ï¿½ï¿½755ï¿½E]Dï¿½ï¿½~:ï¿½ï¿½ï¿½$<M5ï¿½[?ï¿½ï¿½Lï¿½yï¿½`ï¿½xNg|JG×;wÒªï¿½+Yï¿½Ytê©“ï¿½ï¿½z+vÖ®ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½qq1ï¿½ï¿½ï¿½ï¿½áˆŽï¿½oQ1~ï¿½ï¿½Xï¿½|ï¿½ï¿½*lyï¿½Ý»ï¿½ï¿½|ï¿½Mzï¿½ï¿½ï¿½4ï¿½ï¿½Aï¿½ï¿½ï¿½EMï¿½ï¿½%!
ï¿½
ï¿½ï¿½Îï¿½ï¿½ï¿½R^ï¿½`ï¿½Lï¿½r*}ï¿½ï¿½_ï¿½S}Õ°ï¿½ï¿½ï¿½CDï¿½ï¿½ZRR*ï¿½^HZ[[y[m
}ï¿½/ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½beï¿½ï¿½ï¿½ê®ï¿½hï¿½ï¿½-tï¿½y?ï¿½:ï¿½ï¿½ï¿½vÂŽï¿½9ï¿½ï¿½	ï¿½Yï¿½ï¿½xZl×®ï¿½ï¿½ï¿½ï¿½ï¿½Ã¼ï¿½rï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½a:ï¿½ï¿½ï¿½:ï¿½ï¿½ï¿½ï¿½~z/ç¸·Hï¿½ll)[_ï¿½a>ï¿½]]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½uoï¿½ï¿½Õ«N(ï¿½ï¿½tï¿½ï¿½dÔ¨ï¿½ï¿½Å»ï¿½ï¿½>^ï¿½?ï¿½ï¿½=Kï¿½yï¿½ï¿½ï¿½ï¿½`|'lë–­tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½JXï¿½]ï¿½ï¿½ï¿½Dï¿½ï¿½
ï¿½={vï¿½ï¿½Uï¿½ï¿½'ï¿½ï¿½_ ï¿½ï¿½vï¿½ï¿½OJoï¿½Úª)ï¿½ï¿½ï¿½&ï¿½|ï¿½ï¿½ï¿½<ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½Lï¿½|ï¿½#ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½{qAï¿½ï¿½ï¿½fï¿½ï¿½"8pï¿½ï¿½ï¿½Ù´ï¿½}ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½_ï¿½L'ï¿½Dï¿½ï¿½ï¿½U`ï¿½ï¿½*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Sgì‰¨dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Oragï¿½ï¿½/ï¿½'ï¿½e;ï¿½ï¿½ë¼¯ï¿½W.ï¿½ï¿½ï¿½oï¿½mÛ¶ï¿½3|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ôž8Ç©ï¿½\K3>wW!,ï¿½)ï¿½Gï¿½Iï¿½Ã¿sï¿½ï¿½ï¿½JHï¿½1ï¿½ï¿½ï¿½!ï¿½ï¿½ï¿½'ï¿½rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½;sHRï¿½D+ï¿½ï¿½ï¿½c:ï¿½ï¿½&ï¿½Ê ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½ï¿½ï¿½Îï¿½EÅ˜Ôœï¿½2ï¿½ï¿½yï¿½+Sï¿½ï¿½ï¿½ï¿½Upï¿½ï¿½ï¿½*ï¿½9ï¿½Ç½ï¿½rNÌ£ï¿½nczï¿½A\ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½>.Åï¿½ï¿½
ï¿½[ï¿½fï¿½bsï¿½f.ï¿½ï¿½ï¿½#'{ï¿½ï¿½ï¿½ï¿½0ï¿½Gd'ï¿½ï¿½ï¿½ï¿½ï¿½AbDqï¿½tï¿½=ï¿½ï¿½qqï¿½ ï¿½  Aï¿½ï¿½ï¿½h6ï¿½0ï¿½ï¿½:ï¿½uï¿½8eï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½Fv`ï¿½ï¿½nÄ…ï¿½aHï¿½ï¿½8\ê³£ï¿½ï¿½'l

ï¿½ï¿½ï¿½ï¿½ï¿½E\ï¿½Fxdï¿½ï¿½yï¿½ï¿½ï¿½ï¿½ï¿½ï¿½A3h0    IENDï¿½B`ï¿½
--- END OF FILE 2024-11-05/server/resource-picker.png ---


--- START OF FILE 2024-11-05/server/resources.mdx ---
---
title: Resources
type: docs
weight: 20
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to expose
resources to clients. Resources allow servers to share data that provides context to
language models, such as files, database schemas, or application-specific information.
Each resource is uniquely identified by a
[URI](https://datatracker.ietf.org/doc/html/rfc3986).

## User Interaction Model

Resources in MCP are designed to be **application-driven**, with host applications
determining how to incorporate context based on their needs.

For example, applications could:

- Expose resources through UI elements for explicit selection, in a tree or list view
- Allow the user to search through and filter available resources
- Implement automatic context inclusion, based on heuristics or the AI model's selection

![Example of resource context picker](/specification/2024-11-05/server/resource-picker.png)

However, implementations are free to expose resources through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Capabilities

Servers that support resources **MUST** declare the `resources` capability:

```json
{
  "capabilities": {
    "resources": {
      "subscribe": true,
      "listChanged": true
    }
  }
}
```

The capability supports two optional features:

- `subscribe`: whether the client can subscribe to be notified of changes to individual
  resources.
- `listChanged`: whether the server will emit notifications when the list of available
  resources changes.

Both `subscribe` and `listChanged` are optional&mdash;servers can support neither,
either, or both:

```json
{
  "capabilities": {
    "resources": {} // Neither feature supported
  }
}
```

```json
{
  "capabilities": {
    "resources": {
      "subscribe": true // Only subscriptions supported
    }
  }
}
```

```json
{
  "capabilities": {
    "resources": {
      "listChanged": true // Only list change notifications supported
    }
  }
}
```

## Protocol Messages

### Listing Resources

To discover available resources, clients send a `resources/list` request. This operation
supports
[pagination](/specification/2024-11-05/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "resources/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "file:///project/src/main.rs",
        "name": "main.rs",
        "description": "Primary application entry point",
        "mimeType": "text/x-rust"
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Reading Resources

To retrieve resource contents, clients send a `resources/read` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "resources/read",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "contents": [
      {
        "uri": "file:///project/src/main.rs",
        "mimeType": "text/x-rust",
        "text": "fn main() {\n    println!(\"Hello world!\");\n}"
      }
    ]
  }
}
```

### Resource Templates

Resource templates allow servers to expose parameterized resources using
[URI templates](https://datatracker.ietf.org/doc/html/rfc6570). Arguments may be
auto-completed through [the completion API](/specification/2024-11-05/server/utilities/completion).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "resources/templates/list"
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "resourceTemplates": [
      {
        "uriTemplate": "file:///{path}",
        "name": "Project Files",
        "description": "Access files in the project directory",
        "mimeType": "application/octet-stream"
      }
    ]
  }
}
```

### List Changed Notification

When the list of available resources changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/list_changed"
}
```

### Subscriptions

The protocol supports optional subscriptions to resource changes. Clients can subscribe
to specific resources and receive notifications when they change:

**Subscribe Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "resources/subscribe",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

**Update Notification:**

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Resource Discovery
    Client->>Server: resources/list
    Server-->>Client: List of resources

    Note over Client,Server: Resource Access
    Client->>Server: resources/read
    Server-->>Client: Resource contents

    Note over Client,Server: Subscriptions
    Client->>Server: resources/subscribe
    Server-->>Client: Subscription confirmed

    Note over Client,Server: Updates
    Server--)Client: notifications/resources/updated
    Client->>Server: resources/read
    Server-->>Client: Updated contents
```

## Data Types

### Resource

A resource definition includes:

- `uri`: Unique identifier for the resource
- `name`: Human-readable name
- `description`: Optional description
- `mimeType`: Optional MIME type

### Resource Contents

Resources can contain either text or binary data:

#### Text Content

```json
{
  "uri": "file:///example.txt",
  "mimeType": "text/plain",
  "text": "Resource content"
}
```

#### Binary Content

```json
{
  "uri": "file:///example.png",
  "mimeType": "image/png",
  "blob": "base64-encoded-data"
}
```

## Common URI Schemes

The protocol defines several standard URI schemes. This list not
exhaustive&mdash;implementations are always free to use additional, custom URI schemes.

### https://

Used to represent a resource available on the web.

Servers **SHOULD** use this scheme only when the client is able to fetch and load the
resource directly from the web on its ownâ€”that is, it doesnâ€™t need to read the resource
via the MCP server.

For other use cases, servers **SHOULD** prefer to use another URI scheme, or define a
custom one, even if the server will itself be downloading resource contents over the
internet.

### file://

Used to identify resources that behave like a filesystem. However, the resources do not
need to map to an actual physical filesystem.

MCP servers **MAY** identify file:// resources with an
[XDG MIME type](https://specifications.freedesktop.org/shared-mime-info-spec/0.14/ar01s02.html#id-1.3.14),
like `inode/directory`, to represent non-regular files (such as directories) that donâ€™t
otherwise have a standard MIME type.

### git://

Git version control integration.

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Resource not found: `-32002`
- Internal errors: `-32603`

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "error": {
    "code": -32002,
    "message": "Resource not found",
    "data": {
      "uri": "file:///nonexistent.txt"
    }
  }
}
```

## Security Considerations

1. Servers **MUST** validate all resource URIs
2. Access controls **SHOULD** be implemented for sensitive resources
3. Binary data **MUST** be properly encoded
4. Resource permissions **SHOULD** be checked before operations

--- END OF FILE 2024-11-05/server/resources.mdx ---


--- START OF FILE 2024-11-05/server/slash-command.png ---
ï¿½PNG

   
IHDR  %   j   ï¿½Gz  ^iCCPICC Profile  (ï¿½uï¿½;HAï¿½ï¿½ï¿½h0ï¿½"ï¿½ï¿½ï¿½ï¿½b$ï¿½6"ï¿½"XQï¿½ï¿½es^ï¿½K\7'bï¿½ï¿½ï¿½66ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½+Eï¿½Oï¿½ï¿½
ï¿½ï¿½EMï¿½ï¿½ï¿½ï¿½ï¿½ï¿½33ï¿½ï¿½uï¿½-ï¿½Bï¿½ï¿½Ù¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!ï¿½ï¿½Og%ï¿½Ð´y*ï¿½ï¿½ï¿½ï¿½ï¿½#<Rï¿½Gï¿½ï¿½ï¿½ï¿½iï¿½ï¿½W^ï¿½ï¿½;#ï¿½ï¿½ï¿½-/ï¿½3Jï¿½ï¿½rï¿½qaï¿½XÛµï¿½ï¿½âˆ ï¿½ï¿½ï¿½%ï¿½uï¿½ï¿½ï¿½ï¿½sÙ­YÌ¤ï¿½ï¿½ï¿½,ï¿½ï¿½+ï¿½ï¿½lï¿½o6qï¿½ï¿½a_;ï¿½ï¿½Fqiï¿½ï¿½ï¿½ï¿½iï¿½($ï¿½ï¿½8Tï¿½ï¿½Oï¿½>ï¿½ï¿½Ka{Ø„ï¿½<lwï¿½ï¿½hï¿½ï¿½9ï¿½0ï¿½(qã”ªï¿½ï¿½ï¿½;6ï¿½ï¿½;`fï¿½`ï¿½ï¿½%9pï¿½tï¿½4ï¿½ï¿½# t
ÜŽq]ï¿½?ï¿½ï¿½T}ï¿½ï¿½xï¿½ï¿½Aï¿½ï¿½9ï¿½k/ï¿½jï¿½qï¿½Oï¿½vxï¿½ï¿½ï¿½ï¿½'ï¿½9ajï¿½Jï¿½   DeXIfMM *           ï¿½i       &     ï¿½      %ï¿½       j    oIï¿½ï¿½  iTXtXML:com.adobe.xmp     <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="XMP Core 6.0.0">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:tiff="http://ns.adobe.com/tiff/1.0/"
            xmlns:exif="http://ns.adobe.com/exif/1.0/">
         <tiff:Orientation>1</tiff:Orientation>
         <exif:PixelXDimension>293</exif:PixelXDimension>
         <exif:PixelYDimension>106</exif:PixelYDimension>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
l0ï¿½5  lIDATxï¿½]	xUEï¿½>Y YHï¿½ï¿½ï¿½ï¿½HXHï¿½DDdwï¿½Glhmï¿½luï¿½Fï¿½ï¿½ï¿½vz>ï¿½ï¿½vï¿½[g[wTï¿½%HXdï¿½%a'+	[ !ï¿½Adï¿½_ï¿½.ï¿½ï¿½ï¿½GÖ—Ü¼wï¿½ï¿½ï¿½Wuï¿½Ö­[ï¿½×½ï¿½=uNï¿½[^Wï¿½^ï¿½N"ï¿½ï¿½  Xoï¿½ï¿½Cï¿½!ï¿½ï¿½B@HI.A@ï¿½BJï¿½ï¿½ï¿½ï¿½  )ï¿½5 ï¿½B@Hï¿½Rï¿½!ï¿½!%ï¿½Aï¿½R)Yï¿½;ï¿½2ï¿½ï¿½  ï¿½$×€  X
!%Kuï¿½TFï¿½ï¿½ï¿½K! ï¿½dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ `)ï¿½ï¿½,ï¿½RA@ï¿½ï¿½ï¿½+ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½^iï¿½ ï¿½PMï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CE@Hï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CE@Hï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CEï¿½å¤´nï¿½zJKKï¿½1>ï¿½Îï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½p))ï¿½ï¿½ï¿½Ó›oï¿½C.ï¿½ï¿½ï¿½ï¿½ï¿½YNï¿½ï¿½Cï¿½,ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½(.nï¿½ï¿½\pï¿½Gvï¿½ï¿½ï¿½p))ï¿½Zï¿½ï¿½Zï¿½jEï¿½^#$ï¿½ï¿½5%/oo
nï¿½ï¿½i9ï¿½hï¿½ï¿½7ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½A@ï¿½>ï¿½ï¿½ï¿½bAA>ï¿½Ø±ï¿½ï¿½1ï¿½ï¿½ï¿½nï¿½}EEï¿½ï¿½ï¿½lï¿½Â¢+4tHï¿½nm;ï¿½zÜ¸ï¿½4fï¿½hï¿½ï¿½ï¿½qZï¿½ï¿½$ï¿½ï¿½9Gv
ï¿½ï¿½Ò†ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æï¿½ï¿½ï¿½Gï¿½PjJ7ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½5kï¿½ï¿½Ë‹ï¿½B[)Rï¿½pï¿½Ä‰ï¿½c;vï¿½@ï¿½ï¿½ï¿½Fï¿½Õ«W())Emoï¿½ï¿½ï¿½
ï¿½ï¿½3(((ï¿½ï¿½Þ‘ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½ï¿½p)ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ã·PJï¿½ï¿½æ¿¼ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½Ktï¿½:ï¿½ï¿½ï¿½Gï¿½ï¿½Ggyï¿½ï¿½ï¿½wcï¿½yï¿½ï¿½*ï¿½K'ï¿½gï¿½ï¿½yï¿½Eï¿½ï¿½ï¿½%ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½Ñ!ï¿½mï¿½dCï¿½ï¿½ï¿½KH)99ï¿½RSSiï¿½ï¿½+ï¿½ï¿½ï¿½VÒ¼yï¿½ï¿½iS'Snï¿½eE>ï¿½>ï¿½ï¿½&Mï¿½Hï¿½oØï¿½ï¿½ï¿½>ï¿½@ï¿½Éžï¿½ï¿½ï¿½_-WVï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½[oï¿½KO>ï¿½ï¿½hï¿½
3ï¿½ï¿½#ï¿½RZï¿½zï¿½fï¿½9|X9ï¿½Oï¿½Fï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½Ç—BBBï¿½^t/ï¿½ï¿½ï¿½qï¿½3Hï¿½ï¿½wï¿½k×®ï¿½ï¿½ï¿½_ï¿½FFï¿½3gÎª]ï¿½Utï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½u-))ï¿½ï¿½ï¿½[iï¿½È‘ï¿½ï¿½[ï¿½ï¿½ï¿½3ï¿½ Ozï¿½M{Qrrï¿½:Sï¿½V-ï¿½qF9Dï¿½	ï¿½ï¿½Qï¿½ï¿½ï¿½mï¿½Fï¿½ï¿½yï¿½8aï¿½Ã’ï¿½ï¿½Zï¿½fï¿½ï¿½ï¿½ï¿½iPï¿½@5ï¿½iß¾xï¿½Û·/a8&"ï¿½ï¿½@ï¿½kJkØ‹Ö£{
wï¿½lï¿½vmï¿½ï¿½;ï¿½)ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½f>ï¿½ -^ï¿½zï¿½S(ï¿½ï¿½ï¿½ ï¿½VÔªï¿½ï¿½ï¿½ï¿½Iï¿½gï¿½~ï¿½)H0tï¿½ï¿½ï¿½Hï¿½/ï¿½ï¿½]ï¿½ï¿½Nï¿½Uuï¿½ï¿½Oï¿½ï¿½kUï¿½ ï¿½Aï¿½ï¿½URZï¿½j
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½w;ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½Oï¿½ï¿½<5IÙž:wï¿½)S&Qï¿½.]Ô±ï¿½ï¿½}ï¿½|ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½nï¿½Ô´Tï¿½ï¿½ï¿½Ý»ï¿½ï¿½ï¿½WÏžl@oDË¿ï¿½ï¿½ï¿½ï¿½T6g	ï¿½3ï¿½O3ï¿½Ä¶ï¿½  Xï¿½Z#ï¿½ï¿½ï¿½ï¿½Xï¿½09|ï¿½PjÒ¤ï¿½ï¿½V7oï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½5f$ï¿½ï¿½iÓ¦Í´kï¿½ï¿½lï¿½ERï¿½yï¿½tï¿½G
yzï¿½*# ï¿½ï¿½ï¿½ï¿½ï¿½dCï¿½6mJï¿½-xEMï¿½<sï¿½ï¿½ï¿½~ï¿½
Ïƒï¿½ï¿½@ï¿½ï¿½ï¿½n&ï¿½ï¿½2ï¿½ï¿½ï¿½9m|^ï¿½ezï¿½ï¿½Í™ï¿½=ï¿½ï¿½tï¿½|q[ï¿½Ò¢Eï¿½WSvï¿½ï¿½i8EFFÒ»ï¿½iï¿½ï¿½ï¿½
L'ï¿½S
*ï¿½+ï¿½Aï¿½ï¿½Ôš!fï¿½ï¿½uÔ–ï¿½ï¿½QQï¿½N[ï¿½ï¿½_@×®]ï¿½Ý»ï¿½ï¿½'Oï¿½|Ð°2xz ï¿½fï¿½ï¿½ï¿½`ÊŸ  x&ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½9ï¿½Mï¿½6tï¿½ï¿½hÕªï¿½ï¿½ï¿½ï¿½Oï¿½mMï¿½Ðµï¿½kjï¿½^9yï¿½g+
ï¿½3ï¿½BZ-@ï¿½+;;ï¿½ï¿½_ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½F}xï¿½eHp0EDtï¿½Æï¿½\ï¿½+ï¿½ï¿½ACï¿½!Pkï¿½RUï¿½ï¿½ï¿½Û¢ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½Ïœ×žï¿½ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ `ê…”ï¿½ï¿½L>7ï¿½Gï¿½ï¿½>rVA@pï¿½ï¿½Û“ï¿½ï¿½)Nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½P:8ï¿½#ï¿½$M\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4É˜Cï¿½ï¿½|9Oï¿½ï¿½oï¿½/ï¿½ï¿½}ï¿½ï¿½ï¿½Fï¿½'8Cï¿½4ï¿½2ï¿½ï¿½


)??_y
ï¿½ï¿½ï¿½ï¿½ï¿½'q:Iï¿½Aï¿½ï¿½p[Rï¿½ï¿½ï¿½Ô„ï¿½yRï¿½/_ï¿½ï¿½Mï¿½+)uï¿½ï¿½I*ï¿½ï¿½[ï¿½ï¿½&$ï¿½ï¿½ï¿½5ï¿½!5kÖŒ?.ï¿½|ï¿½ï¿½'ï¿½Aï¿½5ï¿½zï¿½ï¿½kï¿½Y'ï¿½j2ï¿½ï¿½ï¿½lHxaWï¿½Nï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½HIkI@q=tï¿½ï¿½Ô¸qï¿½j%
ï¿½@ï¿½ ï¿½ï¿½ï¿½7@ï¿½ï¿½Iï¿½ÚŽÚ—.]T3ï¿½KJJï¿½q9ï¿½  ï¿½ï¿½$%3!iRrï¿½^^vv6]ï¿½Xï¿½%ï¿½oï¿½ï¿½ï¿½ï¿½*#ï¿½vï¿½7ï¿½ï¿½&#ï¿½ï¿½ï¿½ï¿½>
!i$$ï¿½ï¿½ï¿½[ï¿½ï¿½#ï¿½)Yï¿½ï¿½&ï¿½ï¿½ ï¿½p+RÒÒ¡&)ï¿½t	Aï¿½ï¿½ï¿½%)		Yï¿½ï¿½ï¿½ï¿½	!ï¿½ï¿½ï¿½dn4ï¿½ï¿½ï¿½@ï¿½Aï¿½mIÉ¬-ï¿½ï¿½ï¿½5ï¿½yaï¿½%Zï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½	ï¿½ï¿½SU*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½oï¿½ï¿½Ê¡5Î›ï¿½{ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'qï¿½Ü–ï¿½êª¯Nï¿½<ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½ï¿½PRR/
qï¿½ï¿½ï¿½]'ï¿½ï¿½8EVï¿½<nÛ¾ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½}ï¿½EE4ï¿½/ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X.Lï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½n9Oï¿½fï¿½j7vï¿½ï¿½1:pï¿½ï¿½ï¿½%ï¿½Ðƒï¿½å••Ú…ï¿½%ï¿½ï¿½ï¿½ï¿½"|ï¿½ï¿½ï¿½+Ô¡}{ï¿½h]rb.ï¿½kï¿½ï¿½4oï¿½
ï¿½ï¿½	ï¿½ ï¿½ï¿½R%ï¿½ï¿½ï¿½sKï¿½|ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½1}ï¿½ï¿½R%ï¿½ï¿½ï¿½lï¿½"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|jZï¿½ï¿½ï¿½ï¿½!YeoDEï¿½ï¿½lvï¿½w!%'ï¿½BVV6ï¿½Zï¿½ï¿½RRR)_ï¿½ï¿½.AHï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½nï¿½A6ï¿½R.ï¿½Ö¡4uï¿½$ï¿½Ñ½ï¿½ï¿½Ò'cï¿½ï¿½ï¿½ï¿½ï¿½4ï¿½ï¿½ï¿½)==ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½G{ï¿½ï¿½5
ï¿½×¯/ï¿½ï¿½Iï¿½ï¿½Kï¿½\ï¿½ ^ï¿½ï¿½_?nï¿½Lï¿½ï¿½ï¿½_Aï¿½ï¿½ï¿½
/ï¿½Þ‰W;ï¿½ï¿½ï¿½ï¿½ï¿½4Zï¿½r-ï¿½ï¿½?}ï¿½ï¿½ï¿½;ï¿½4nsË–-lï¿½>|ï¿½Ö­ï¿½ï¿½ï¿½ï¿½sï¿½a^ï¿½Ð°0ï¿½Ý«ï¿½7nL9Rï¿½Û²]ï¿½ï¿½wï¿½|6ï¿½ï¿½ï¿½ï¿½ï¿½={ï¿½6ë—¨ï¿½xï¿½ï¿½ï¿½ï¿½å‡„ï¿½ï¿½ï¿½Í ï¿½ï¿½vÓ±ï¿½ï¿½TXTHO?ï¿½kï¿½ï¿½ï¿½Ï¾ï¿½Ó§Nyï¿½Ø±ï¿½|ï¿½ï¿½ï¿½Ï–}ï¿½>ï¿½ÝŸë¹‰2ï¿½fï¿½6ï¿½s
`ï¿½!ï¿½ï¿½xï¿½FÕ·ï¿½ï¿½Aï¿½ï¿½3C9-O>1ï¿½ï¿½ï¿½yï¿½ï¿½bzï¿½ï¿½ï¿½ï¿½dFDï¿½ï¿½)ï¿½'Ú¤a$ï¿½ï¿½[ï¿½"ï¿½ï¿½ï¿½gï¿½ï¿½{Gï¿½ï¿½I'ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½Ô‡ï¿½ï¿½6ï¿½1ï¿½`ï¿½F|,Xï¿½Ð¢uï¿½vï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½R^ï¿½	ï¿™%ï¿½ï¿½t$EEEï¿½ï¿½;ï¿½ï¿½	ï¿½ï¿½9ï¿½bï¿½<ï¿½ï¿½ï¿½ï¿½bzï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ý¯nï¿½l&ï¿½!ï¿½Q@@ ï¿½8ï¿½ï¿½Ãƒ
ï¿½ï¿½Umï¿½ï¿½Cï¿½ï¿½P<ï¿½ï¿½ï¿½Rï¿½{ï¿½ï¿½Ô¡C;^)8ï¿½ï¿½;N%ï¿½%ï¿½ï¿½KUï¿½Bï¿½Xï¿½ï¿½-Zï¿½ï¿½C|ï¿½C#Xï¿½7zï¿½Iï¿½:LPï¿½@&ï¿½(ï¿½ï¿½ï¿½_}ï¿½ï¿½ï¿½nï¿½I-}3ï¿½?ï¿½Ò”ï¿½oØ¤ï¿½>8oï¿½.áª¨ï¿½Ç“ï¿½ï¿½yï¿½ï¿½ï¿½ï¿½ï¿½JH8D[ï¿½mï¿½Awï¿½l3Frï¿½`Ã†
ï¿½ï¿½oï¿½O^ï¿½ï¿½ï¿½ï¿½ï¿½wRï¿½ï¿½Ô¿_ï¿½j+Vï¿½á¥·ï¿½(ï¿½:t0ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½!%%ï¿½ï¿½ï¿½Aï¿½Oï¿½:Cï¿½ï¿½ï¿½t<1ï¿½ï¿½ï¿½Cï¿½ï¿½
ï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½ï¿½Ú‚ï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½o#ï¿½Gï¿½I9ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½r@8ï¿½ï¿½(ï¿½SGjÕªï¿½"ï¿½]ï¿½~Vï¿½ï¿½ï¿½ï¿½vï¿½Ô¦ï¿½ï¿½Ã‡Viï¿½d_ï¿½QuD=Sï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½]ï¿½ï¿½`^ï¿½gÈ;ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½|ï¿½ï¿½}r<1ï¿½jï¿½3
ï¿½hï¿½ï¿½.ï¿½h%ï¿½ZIÉ©tï¿½bï¿½awÆŒitï¿½ï¿½!ï¿½ï¿½Mï¿½ï¿½ï¿½ï¿½Pï¿½|ï¿½@+ï¿½ï¿½ï¿½ï¿½Mï¿½?ï¿½ï¿½qQBï¿½ï¿½á‡•tï¿½ï¿½Q:$Fgï¿½R8mï¿½dï¿½ï¿½ï¿½S3yï¿½DZï¿½ï¿½bÚ¶m'ï¿½;Fï¿½ï¿½ï¿½ï¿½ï¿½08ï¿½ï¿½ï¿½d^6}p9ï¿½Ì‰ï¿½fßµkk	-ï¿½ï¿½W^242Ü˜ï¿½ï¿½Ö»ï¿½ï¿½ï¿½ÔŠoï¿½}á·†ï¿½Ù‹ï¿½xï¿½M^6}ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½Ö­[Uï¿½!|ï¿½ï¿½ï¿½ï¿½Ûµï¿½06oÞªHjï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½i-Aï¿½ï¿½Nï¿½_ï¿½>Å¤ï¿½ï¿½ï¿½Lï¿½ï¿½~ï¿½ï¿½ÖŽï¿½ï¿½ï¿½Tï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½ï¿½?<ï¿½~ï¿½ï¿½oï¿½ï¿½;Ç„ï¿½ï¿½Oï¿½Ic7ï¿½rï¿½ï¿½ï¿½Eï¿½ï¿½?Jï¿½ï¿½N-ï¿½XÚ¶mCï¿½ï¿½ï¿½kï¿½ï¿½ï¿½ï¿½tï¿½ï¿½oï¿½cï¿½ï¿½&.ï¿½sDD=ï¿½ï¿½ï¿½F9+ï¿½ï¿½7ï¿½ï¿½ ï¿½ï¿½ï¿½_ï¿½>Fï¿½+ï¿½1ï¿½pï¿½Eï¿½ï¿½tH1kGZï¿½-Zï¿½ï¿½$ï¿½m&cï¿½#xJï¿½$Ò£ï¿½)a];ï¿½ï¿½ï¿½ï¿½Yï¿½I4'ï¿½ï¿½ï¿½ï¿½1ï¿½&
ï¿½xï¿½ï¿½/ï¿½ï¿½ß‡ï¿½ï¿½.ï¿½6mï¿½ï¿½.#ï¿½ï¿½ï¿½kï¿½ï¿½mï¿½ï¿½ï¿½ï¿½+ï¿½Ïœï¿½Ò‹ï¿½eï¿½ï¿½<ï¿½ï¿½d	k3ï¿½BB^yï¿½rï¿½
ï¿½gÏž%hï¿½gyHfï¿½ ï¿½132NImZï¿½ï¿½ï¿½7|`ï¿½uï¿½ï¿½ÊšG;ï¿½ï¿½Í‚cÔ¹ï¿½ï¿½3'Ó¨Qwï¿½lï¿½oï¿½ï¿½&NWï¿½ï¿½ï¿½ï¿½3'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½á¸¹ï¿½Â˜ï¿½ï¿½ï¿½jï¿½h'ï¿½Dï¿½@^Zï¿½ï¿½lHCï¿½W6<q"]vtï¿½mï¿½DG+RJMMï¿½)ï¿½ï¿½ï¿½Xeï¿½oï¿½|BJzï¿½\ï¿½ï¿½yØ‡!ï¿½a~Reï¿½ï¿½ï¿½ï¿½G
ï¿½f$é§¶ï¿½"ï¿½Î®]ï¿½ï¿½ï¿½ï¿½ï¿½È‡n Gï¿½ï¿½YBCï¿½nï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½wï¿½ï¿½Ù¼Y.Þ·oï¿½ï¿½Øyï¿½ï¿½.ï¿½\.Dï¿½9ï¿½9ï¿½ï¿½]6ï¿½Å	?{)5}ZÆ„ï¿½ï¿½(nï¿½6Cï¿½ï¿½aï¿½ï¿½Ö­+=0cï¿½ï¿½x=Ý )ï¿½"-YWï¿½ï¿½yï¿½ï¿½Vy`ï¿½:}ï¿½ï¿½;ï¿½Â„Ã‚ï¿½ï¿½x!ï¿½ï¿½ï¿½;ï¿½ï¿½9
ï¿½rrlh6ï¿½xï¿½ï¿½5fï¿½ï¿½!n)9ï¿½5ï¿½ï¿½ï¿½,ï¿½ï¿½_ï¿½g;ï¿½!Íš6Sï¿½M_ï¿½Õ‘ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½ï¿½uï¿½
Stï¿½ï¿½ï¿½ï¿½ï¿½!|dï¿½ï¿½ï¿½rqï¿½rï¿½R9ï¿½ï¿½p#ï¿½5ï¿½Ø±ï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½`ï¿½ï¿½ï¿½aaGï¿½ï¿½ ;ï¿½GKï¿½ï¿½K/>ï¿½ï¿½
*ï¿½\e{]Uï¿½ï¿½6Wï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½
BÂ¹0M ï¿½ï¿½L
jA?ï¿½ï¿½ï¿½Wuï¿½'ï¿½BJz7Ð—_~Kï¿½ï¿½4{ï¿½ï¿½lè½ª.ï¿½6<ï¿½0{EZkIYYï¿½ï¿½ï¿½uï¿½	ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½kï¿½ï¿½|Xï¿½ah5ï¿½'ï¿½ï¿½fï¿½!ï¿½ï¿½4Mp&ï¿½[8ï¿½ï¿½ï¿½0CÎž=Çžï¿½<ï¿½ï¿½Cï¿½Þ½zï¿½ï¿½ï¿½Xï¿½ï¿½]Û¶ï¿½ï¿½0ï¿½ï¿½1ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½T^brï¿½'ï¿½LÊ†]pZï¿½ï¿½ï¿½ï¿½ï¿½Ï¯ï¿½	ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Ã§ï¿½ï¿½Nï¿½ï¿½ï¿½<ï¿½3ï¿½Ú¨Qc6ï¿½S	ï¿½ï¿½ï¿½Bï¿½KULkHï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½/ï¿½sï¿½ï¿½ï¿½ï¿½q!%=ï¿½':l ï¿½ï¿½K?7<mï¿½ ï¿½~ï¿½]#x(vï¿½á’ƒbï¿½ï¿½Wï¿½ï¿½{ï¿½Vï¿½={ï¿½ï¿½ï¿½ï¿½,8pï¿½Z
ï¿½ï¿½>ï¿½ï¿½kï¿½)ï¿½ï¿½vï¿½ï¿½
ï¿½q=y{Tf'ï¿½ï¿½5ï¿½É³ï¿½)ï¿½ï¿½ vï¿½ï¿½ï¿½6ï¿½=ï¿½^ÆKË¸~ï¿½ï¿½Ö‡ï¿½ï¿½+ï¿½Ü‰<ï¿½Cï¿½v)}ï¿½ï¿½rJIKeï¿½Rï¿½ï¿½!1mHeOï¿½Q&ï¿½^=#ï¿½bqCÃ–ï¿½ï¿½ï¿½d1ï¿½ï¿½bï¿½ï¿½Æï¿½ï¿½ï¿½`ï¿½ï¿½0ï¿½ï¿½ï¿½Afï¿½ï¿½bÚ‚n3
ï¿½Û§ï¿½aï¿½&vï¿½ï¿½ï¿½,ï¿½-Zï¿½gï¿½4{ï¿½Lï¿½3ZÅ‹YCï¿½ï¿½ï¿½?dBï¿½Qï¿½ï¿½Î?ï¿½ï¿½ï¿½pvpï¿½ï¿½ï¿½ï¿½ï¿½+ï¿½ï¿½e!Ï‚Wï¿½ï¿½	ï¿½ï¿½ï¿½}ï¿½a 0<ï¿½t=[3ï¿½ï¿½[	ï¿½(Jï¿½}ï¿½>ï¿½kdï¿½7vï¿½Þ«<wï¿½~zï¿½)9ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Öµ+ï¿½ï¿½Sxï¿½ï¿½ï¿½pï¿½m:ï¿½Þ¶gï¿½\ï¿½$ï¿½Ú‚.ï¿½~[ï¿½W%7vï¿½zWKÏ‹ï¿½ï¿½fï¿½ï¿½ï¿½F{ï¿½ï¿½cï¿½ï¿½Vc;%5ï¿½ï¿½ï¿½ï¿½VURï¿½q3ï¿½AEï¿½Eï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Yfï¿½ï¿½ï¿½CMï¿½Xï¿½r5a#ï¿½ï¿½ï¿½Ó¦Øœï¿½ï¿½ï¿½ï¿½ï¿½ï¿½WPï¿½{ï¿½ï¿½ï¿½	ï¿½hï¿½ï¿½9Mfyï¿½ï¿½5bï¿½nÓ¦ÍŠï¿½:uï¿½Dï¿½f=dxOï¿½eË¾0fï¿½ï¿½"ï¿½Iï¿½ï¿½WQï¿½ï¿½ï¿½bRï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½ ï¿½7jï¿½Hï¿½acï¿½ï¿½L`Bï¿½ï¿½kï¿½fï¿½cJï¿½oï¿½2ï¿½^'ï¿½ï¿½#ï¿½1ï¿½4Lï¿½xï¿½I	ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½=tï¿½esï¿½ï¿½!ï¿½%<ï¿½ï¿½ï¿½6x#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½V+ï¿½jï¿½2ï¿½Vï¿½a6.ï¿½ï¿½ï¿½Rï¿½Tï¿½Â“fIJ*3^ï¿½ï¿½ï¿½+xÅŠUÔžï¿½ï¿½#Gï¿½yï¿½ï¿½ï¿½;8))Ù˜ï¿½.l%ï¿½-pï¿½ï¿½[ï¿½ï¿½/Zï¿½4ï¿½ï¿½aï¿½ï¿½ï¿½ï¿½ï¿½hï¿½LNï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ub0ï¿½ï¿½ï¿½ï¿½ï¿½Ù‹ï¿½(?ï¿½eï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½É¬ï¿½a:Ú‡ï¿½3++[ï¿½ï¿½ï¿½uuï¿½ï¿½Xï¿½hJz%!ï¿½J-ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½.Ä™wÎ•ï¿½	jï¿½wEç©¬ï¿½ï¿½ï¿½ï¿½ï¿½6ï¿½n8ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½FMaï¿½)C@Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½vï¿½ï¿½ï¿½ÈŽï¿½Ý ;88Rï¿½Aï¿½ï¿½)9@ï¿½ï¿½ï¿½×ï¿½;ï¿½Hï¿½jï¿½O
ï¿½ï¿½:w/7ï¿½wPLï¿½ï¿½ï¿½"ï¿½È¿ï¿½ï¿½ï¿½ï¿½V!rPï¿½5jDï¿½Iï¿½ï¿½>X2ï¿½ï¿½)ï¿½V)Tï¿½ï¿½ï¿½M#IuKï¿½ï¿½qfoï¿½9nï¿½ï¿½Jï¿½Aï¿½nKJï¿½ï¿½o5ï¿½-8ï¿½ï¿½ï¿½l:ï¿½ï¿½ï¿½ï¿½ Pï¿½ï¿½ï¿½M	ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½"1ï¿½_>Wjï¿½ï¿½lï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Rï¿½b.ï¿½Jï¿½ï¿½<Í›~"ï¿½ï¿½ `
ï¿½jï¿½fO8ï¿½iï¿½a2ï¿½ï¿½wï¿½ï¿½ï¿½ï¿½Bï¿½#ï¿½Vï¿½dnï¿½ï¿½$MJpï¿½cï¿½ï¿½ï¿½"ï¿½ï¿½ `]Ü’ï¿½@DMH 'ï¿½ï¿½ï¿½;Kxï¿½Lï¿½GÖ½ ï¿½fï¿½ï¿½ï¿½Ú”@HÚ†Rï¿½ï¿½hï¿½ï¿½ï¿½ï¿½Æ„ï¿½ï¿½ï¿½iï¿½ï¿½Aï¿½ï¿½#%MFï¿½qï¿½ï¿½	ï¿½Bï¿½ï¿½7ï¿½ï¿½ï¿½ 4&ï¿½ï¿½ï¿½ï¿½3Wï¿½]#5<ï¿½#%ÝZï¿½)i1iA:ï¿½Dï¿½Dï¿½:ï¿½ï¿½ï¿½ï¿½ Pï¿½ï¿½%)imIBMHï¿½ï¿½g&$31ï¿½}ï¿½Aï¿½ï¿½ï¿½[ï¿½ï¿½Ñšï¿½ÖŠï¿½Ä„}ï¿½ï¿½ï¿½<:4ï¿½#qA@ï¿½{Ü–ï¿½4ï¿½ï¿½ï¿½ï¿½mIoCSï¿½iï¿½+ï¿½ï¿½ï¿½Pï¿½_Üšï¿½4!4ï¿½ï¿½>ï¿½.ï¿½nï¿½ï¿½ï¿½ï¿½@ï¿½"ï¿½Ö¤h5!A2ï¿½ï¿½=)Akï¿½ï¿½Æ¤`ï¿½?Aï¿½ï¿½p{Rï¿½ÈšIHï¿½9ÍœOï¿½%ï¿½ï¿½Gï¿½cH	ï¿½j2B\kDï¿½4ï¿½ï¿½ï¿½@ï¿½"ï¿½Qï¿½dï¿½Zï¿½ÈŒï¿½ï¿½ï¿½ psfï¿½uï¿½$5F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½3DEï¿½Aï¿½Xs    IENDï¿½B`ï¿½
--- END OF FILE 2024-11-05/server/slash-command.png ---


--- START OF FILE 2024-11-05/server/tools.mdx ---
---
title: Tools
type: docs
weight: 40
---

<Info>**Protocol Revision**: 2024-11-05</Info>

The Model Context Protocol (MCP) allows servers to expose tools that can be invoked by
language models. Tools enable models to interact with external systems, such as querying
databases, calling APIs, or performing computations. Each tool is uniquely identified by
a name and includes metadata describing its schema.

## User Interaction Model

Tools in MCP are designed to be **model-controlled**, meaning that the language model can
discover and invoke tools automatically based on its contextual understanding and the
user's prompts.

However, implementations are free to expose tools through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

<Warning>

For trust & safety and security, there **SHOULD** always
be a human in the loop with the ability to deny tool invocations.

Applications **SHOULD**:

- Provide UI that makes clear which tools are being exposed to the AI model
- Insert clear visual indicators when tools are invoked
- Present confirmation prompts to the user for operations, to ensure a human is in the
  loop

</Warning>

## Capabilities

Servers that support tools **MUST** declare the `tools` capability:

```json
{
  "capabilities": {
    "tools": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the server will emit notifications when the list of
available tools changes.

## Protocol Messages

### Listing Tools

To discover available tools, clients send a `tools/list` request. This operation supports
[pagination](/specification/2024-11-05/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "City name or zip code"
            }
          },
          "required": ["location"]
        }
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Calling Tools

To invoke a tool, clients send a `tools/call` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "get_weather",
    "arguments": {
      "location": "New York"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Current weather in New York:\nTemperature: 72Â°F\nConditions: Partly cloudy"
      }
    ],
    "isError": false
  }
}
```

### List Changed Notification

When the list of available tools changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant LLM
    participant Client
    participant Server

    Note over Client,Server: Discovery
    Client->>Server: tools/list
    Server-->>Client: List of tools

    Note over Client,LLM: Tool Selection
    LLM->>Client: Select tool to use

    Note over Client,Server: Invocation
    Client->>Server: tools/call
    Server-->>Client: Tool result
    Client->>LLM: Process result

    Note over Client,Server: Updates
    Server--)Client: tools/list_changed
    Client->>Server: tools/list
    Server-->>Client: Updated tools
```

## Data Types

### Tool

A tool definition includes:

- `name`: Unique identifier for the tool
- `description`: Human-readable description of functionality
- `inputSchema`: JSON Schema defining expected parameters

### Tool Result

Tool results can contain multiple content items of different types:

#### Text Content

```json
{
  "type": "text",
  "text": "Tool result text"
}
```

#### Image Content

```json
{
  "type": "image",
  "data": "base64-encoded-data",
  "mimeType": "image/png"
}
```

#### Embedded Resources

[Resources](/specification/2024-11-05/server/resources) **MAY** be
embedded, to provide additional context or data, behind a URI that can be subscribed to
or fetched again by the client later:

```json
{
  "type": "resource",
  "resource": {
    "uri": "resource://example",
    "mimeType": "text/plain",
    "text": "Resource content"
  }
}
```

## Error Handling

Tools use two error reporting mechanisms:

1. **Protocol Errors**: Standard JSON-RPC errors for issues like:

   - Unknown tools
   - Invalid arguments
   - Server errors

2. **Tool Execution Errors**: Reported in tool results with `isError: true`:
   - API failures
   - Invalid input data
   - Business logic errors

Example protocol error:

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "error": {
    "code": -32602,
    "message": "Unknown tool: invalid_tool_name"
  }
}
```

Example tool execution error:

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Failed to fetch weather data: API rate limit exceeded"
      }
    ],
    "isError": true
  }
}
```

## Security Considerations

1. Servers **MUST**:

   - Validate all tool inputs
   - Implement proper access controls
   - Rate limit tool invocations
   - Sanitize tool outputs

2. Clients **SHOULD**:
   - Prompt for user confirmation on sensitive operations
   - Show tool inputs to the user before calling the server, to avoid malicious or
     accidental data exfiltration
   - Validate tool results before passing to LLM
   - Implement timeouts for tool calls
   - Log tool usage for audit purposes

--- END OF FILE 2024-11-05/server/tools.mdx ---


--- START OF FILE 2024-11-05/index.mdx ---
---
title: Specification
---

[Model Context Protocol](https://modelcontextprotocol.io) (MCP) is an open protocol that
enables seamless integration between LLM applications and external data sources and
tools. Whether you're building an AI-powered IDE, enhancing a chat interface, or creating
custom AI workflows, MCP provides a standardized way to connect LLMs with the context
they need.

This specification defines the authoritative protocol requirements, based on the
TypeScript schema in
[schema.ts](https://github.com/modelcontextprotocol/specification/blob/main/schema/2024-11-05/schema.ts).

For implementation guides and examples, visit
[modelcontextprotocol.io](https://modelcontextprotocol.io).

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [BCP 14](https://datatracker.ietf.org/doc/html/bcp14)
[[RFC2119](https://datatracker.ietf.org/doc/html/rfc2119)]
[[RFC8174](https://datatracker.ietf.org/doc/html/rfc8174)] when, and only when, they
appear in all capitals, as shown here.

## Overview

MCP provides a standardized way for applications to:

- Share contextual information with language models
- Expose tools and capabilities to AI systems
- Build composable integrations and workflows

The protocol uses [JSON-RPC](https://www.jsonrpc.org/) 2.0 messages to establish
communication between:

- **Hosts**: LLM applications that initiate connections
- **Clients**: Connectors within the host application
- **Servers**: Services that provide context and capabilities

MCP takes some inspiration from the
[Language Server Protocol](https://microsoft.github.io/language-server-protocol/), which
standardizes how to add support for programming languages across a whole ecosystem of
development tools. In a similar way, MCP standardizes how to integrate additional context
and tools into the ecosystem of AI applications.

## Key Details

### Base Protocol

- [JSON-RPC](https://www.jsonrpc.org/) message format
- Stateful connections
- Server and client capability negotiation

### Features

Servers offer any of the following features to clients:

- **Resources**: Context and data, for the user or the AI model to use
- **Prompts**: Templated messages and workflows for users
- **Tools**: Functions for the AI model to execute

Clients may offer the following feature to servers:

- **Sampling**: Server-initiated agentic behaviors and recursive LLM interactions

### Additional Utilities

- Configuration
- Progress tracking
- Cancellation
- Error reporting
- Logging

## Security and Trust & Safety

The Model Context Protocol enables powerful capabilities through arbitrary data access
and code execution paths. With this power comes important security and trust
considerations that all implementors must carefully address.

### Key Principles

1. **User Consent and Control**

   - Users must explicitly consent to and understand all data access and operations
   - Users must retain control over what data is shared and what actions are taken
   - Implementors should provide clear UIs for reviewing and authorizing activities

2. **Data Privacy**

   - Hosts must obtain explicit user consent before exposing user data to servers
   - Hosts must not transmit resource data elsewhere without user consent
   - User data should be protected with appropriate access controls

3. **Tool Safety**

   - Tools represent arbitrary code execution and must be treated with appropriate
     caution
   - Hosts must obtain explicit user consent before invoking any tool
   - Users should understand what each tool does before authorizing its use

4. **LLM Sampling Controls**
   - Users must explicitly approve any LLM sampling requests
   - Users should control:
     - Whether sampling occurs at all
     - The actual prompt that will be sent
     - What results the server can see
   - The protocol intentionally limits server visibility into prompts

### Implementation Guidelines

While MCP itself cannot enforce these security principles at the protocol level,
implementors **SHOULD**:

1. Build robust consent and authorization flows into their applications
2. Provide clear documentation of security implications
3. Implement appropriate access controls and data protections
4. Follow security best practices in their integrations
5. Consider privacy implications in their feature designs

## Learn More

Explore the detailed specification for each protocol component:

<CardGroup cols={5}>
  <Card
    title="Architecture"
    icon="sitemap"
    href="/specification/2024-11-05/architecture"
  />
  <Card
    title="Base Protocol"
    icon="code"
    href="/specification/2024-11-05/basic"
  />
  <Card
    title="Server Features"
    icon="server"
    href="/specification/2024-11-05/server"
  />
  <Card
    title="Client Features"
    icon="user"
    href="/specification/2024-11-05/client"
  />
  <Card title="Contributing" icon="pencil" href="/development/contributing" />
</CardGroup>

--- END OF FILE 2024-11-05/index.mdx ---


--- START OF FILE 2025-03-26/architecture/index.mdx ---
---
title: Architecture
---

The Model Context Protocol (MCP) follows a client-host-server architecture where each
host can run multiple client instances. This architecture enables users to integrate AI
capabilities across applications while maintaining clear security boundaries and
isolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused
on context exchange and sampling coordination between clients and servers.

## Core Components

```mermaid
graph LR
    subgraph "Application Host Process"
        H[Host]
        C1[Client 1]
        C2[Client 2]
        C3[Client 3]
        H --> C1
        H --> C2
        H --> C3
    end

    subgraph "Local machine"
        S1[Server 1<br>Files & Git]
        S2[Server 2<br>Database]
        R1[("Local<br>Resource A")]
        R2[("Local<br>Resource B")]

        C1 --> S1
        C2 --> S2
        S1 <--> R1
        S2 <--> R2
    end

    subgraph "Internet"
        S3[Server 3<br>External APIs]
        R3[("Remote<br>Resource C")]

        C3 --> S3
        S3 <--> R3
    end
```

### Host

The host process acts as the container and coordinator:

- Creates and manages multiple client instances
- Controls client connection permissions and lifecycle
- Enforces security policies and consent requirements
- Handles user authorization decisions
- Coordinates AI/LLM integration and sampling
- Manages context aggregation across clients

### Clients

Each client is created by the host and maintains an isolated server connection:

- Establishes one stateful session per server
- Handles protocol negotiation and capability exchange
- Routes protocol messages bidirectionally
- Manages subscriptions and notifications
- Maintains security boundaries between servers

A host application creates and manages multiple clients, with each client having a 1:1
relationship with a particular server.

### Servers

Servers provide specialized context and capabilities:

- Expose resources, tools and prompts via MCP primitives
- Operate independently with focused responsibilities
- Request sampling through client interfaces
- Must respect security constraints
- Can be local processes or remote services

## Design Principles

MCP is built on several key design principles that inform its architecture and
implementation:

1. **Servers should be extremely easy to build**

   - Host applications handle complex orchestration responsibilities
   - Servers focus on specific, well-defined capabilities
   - Simple interfaces minimize implementation overhead
   - Clear separation enables maintainable code

2. **Servers should be highly composable**

   - Each server provides focused functionality in isolation
   - Multiple servers can be combined seamlessly
   - Shared protocol enables interoperability
   - Modular design supports extensibility

3. **Servers should not be able to read the whole conversation, nor "see into" other
   servers**

   - Servers receive only necessary contextual information
   - Full conversation history stays with the host
   - Each server connection maintains isolation
   - Cross-server interactions are controlled by the host
   - Host process enforces security boundaries

4. **Features can be added to servers and clients progressively**
   - Core protocol provides minimal required functionality
   - Additional capabilities can be negotiated as needed
   - Servers and clients evolve independently
   - Protocol designed for future extensibility
   - Backwards compatibility is maintained

## Capability Negotiation

The Model Context Protocol uses a capability-based negotiation system where clients and
servers explicitly declare their supported features during initialization. Capabilities
determine which protocol features and primitives are available during a session.

- Servers declare capabilities like resource subscriptions, tool support, and prompt
  templates
- Clients declare capabilities like sampling support and notification handling
- Both parties must respect declared capabilities throughout the session
- Additional capabilities can be negotiated through extensions to the protocol

```mermaid
sequenceDiagram
    participant Host
    participant Client
    participant Server

    Host->>+Client: Initialize client
    Client->>+Server: Initialize session with capabilities
    Server-->>Client: Respond with supported capabilities

    Note over Host,Server: Active Session with Negotiated Features

    loop Client Requests
        Host->>Client: User- or model-initiated action
        Client->>Server: Request (tools/resources)
        Server-->>Client: Response
        Client-->>Host: Update UI or respond to model
    end

    loop Server Requests
        Server->>Client: Request (sampling)
        Client->>Host: Forward to AI
        Host-->>Client: AI response
        Client-->>Server: Response
    end

    loop Notifications
        Server--)Client: Resource updates
        Client--)Server: Status changes
    end

    Host->>Client: Terminate
    Client->>-Server: End session
    deactivate Server
```

Each capability unlocks specific protocol features for use during the session. For
example:

- Implemented [server features](/specification/2025-03-26/server) must be advertised in the
  server's capabilities
- Emitting resource subscription notifications requires the server to declare
  subscription support
- Tool invocation requires the server to declare tool capabilities
- [Sampling](/specification/2025-03-26/client) requires the client to declare support in its
  capabilities

This capability negotiation ensures clients and servers have a clear understanding of
supported functionality while maintaining protocol extensibility.

--- END OF FILE 2025-03-26/architecture/index.mdx ---


--- START OF FILE 2025-03-26/basic/utilities/cancellation.mdx ---
---
title: Cancellation
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol (MCP) supports optional cancellation of in-progress requests
through notification messages. Either side can send a cancellation notification to
indicate that a previously-issued request should be terminated.

## Cancellation Flow

When a party wants to cancel an in-progress request, it sends a `notifications/cancelled`
notification containing:

- The ID of the request to cancel
- An optional reason string that can be logged or displayed

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/cancelled",
  "params": {
    "requestId": "123",
    "reason": "User requested cancellation"
  }
}
```

## Behavior Requirements

1. Cancellation notifications **MUST** only reference requests that:
   - Were previously issued in the same direction
   - Are believed to still be in-progress
2. The `initialize` request **MUST NOT** be cancelled by clients
3. Receivers of cancellation notifications **SHOULD**:
   - Stop processing the cancelled request
   - Free associated resources
   - Not send a response for the cancelled request
4. Receivers **MAY** ignore cancellation notifications if:
   - The referenced request is unknown
   - Processing has already completed
   - The request cannot be cancelled
5. The sender of the cancellation notification **SHOULD** ignore any response to the
   request that arrives afterward

## Timing Considerations

Due to network latency, cancellation notifications may arrive after request processing
has completed, and potentially after a response has already been sent.

Both parties **MUST** handle these race conditions gracefully:

```mermaid
sequenceDiagram
   participant Client
   participant Server

   Client->>Server: Request (ID: 123)
   Note over Server: Processing starts
   Client--)Server: notifications/cancelled (ID: 123)
   alt
      Note over Server: Processing may have<br/>completed before<br/>cancellation arrives
   else If not completed
      Note over Server: Stop processing
   end
```

## Implementation Notes

- Both parties **SHOULD** log cancellation reasons for debugging
- Application UIs **SHOULD** indicate when cancellation is requested

## Error Handling

Invalid cancellation notifications **SHOULD** be ignored:

- Unknown request IDs
- Already completed requests
- Malformed notifications

This maintains the "fire and forget" nature of notifications while allowing for race
conditions in asynchronous communication.

--- END OF FILE 2025-03-26/basic/utilities/cancellation.mdx ---


--- START OF FILE 2025-03-26/basic/utilities/ping.mdx ---
---
title: Ping
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol includes an optional ping mechanism that allows either party
to verify that their counterpart is still responsive and the connection is alive.

## Overview

The ping functionality is implemented through a simple request/response pattern. Either
the client or server can initiate a ping by sending a `ping` request.

## Message Format

A ping request is a standard JSON-RPC request with no parameters:

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "method": "ping"
}
```

## Behavior Requirements

1. The receiver **MUST** respond promptly with an empty response:

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {}
}
```

2. If no response is received within a reasonable timeout period, the sender **MAY**:
   - Consider the connection stale
   - Terminate the connection
   - Attempt reconnection procedures

## Usage Patterns

```mermaid
sequenceDiagram
    participant Sender
    participant Receiver

    Sender->>Receiver: ping request
    Receiver->>Sender: empty response
```

## Implementation Considerations

- Implementations **SHOULD** periodically issue pings to detect connection health
- The frequency of pings **SHOULD** be configurable
- Timeouts **SHOULD** be appropriate for the network environment
- Excessive pinging **SHOULD** be avoided to reduce network overhead

## Error Handling

- Timeouts **SHOULD** be treated as connection failures
- Multiple failed pings **MAY** trigger connection reset
- Implementations **SHOULD** log ping failures for diagnostics

--- END OF FILE 2025-03-26/basic/utilities/ping.mdx ---


--- START OF FILE 2025-03-26/basic/utilities/progress.mdx ---
---
title: Progress
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol (MCP) supports optional progress tracking for long-running
operations through notification messages. Either side can send progress notifications to
provide updates about operation status.

## Progress Flow

When a party wants to _receive_ progress updates for a request, it includes a
`progressToken` in the request metadata.

- Progress tokens **MUST** be a string or integer value
- Progress tokens can be chosen by the sender using any means, but **MUST** be unique
  across all active requests.

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "some_method",
  "params": {
    "_meta": {
      "progressToken": "abc123"
    }
  }
}
```

The receiver **MAY** then send progress notifications containing:

- The original progress token
- The current progress value so far
- An optional "total" value
- An optional "message" value

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/progress",
  "params": {
    "progressToken": "abc123",
    "progress": 50,
    "total": 100,
    "message": "Reticulating splines..."
  }
}
```

- The `progress` value **MUST** increase with each notification, even if the total is
  unknown.
- The `progress` and the `total` values **MAY** be floating point.
- The `message` field **SHOULD** provide relevant human readable progress information.

## Behavior Requirements

1. Progress notifications **MUST** only reference tokens that:

   - Were provided in an active request
   - Are associated with an in-progress operation

2. Receivers of progress requests **MAY**:
   - Choose not to send any progress notifications
   - Send notifications at whatever frequency they deem appropriate
   - Omit the total value if unknown

```mermaid
sequenceDiagram
    participant Sender
    participant Receiver

    Note over Sender,Receiver: Request with progress token
    Sender->>Receiver: Method request with progressToken

    Note over Sender,Receiver: Progress updates
    loop Progress Updates
        Receiver-->>Sender: Progress notification (0.2/1.0)
        Receiver-->>Sender: Progress notification (0.6/1.0)
        Receiver-->>Sender: Progress notification (1.0/1.0)
    end

    Note over Sender,Receiver: Operation complete
    Receiver->>Sender: Method response
```

## Implementation Notes

- Senders and receivers **SHOULD** track active progress tokens
- Both parties **SHOULD** implement rate limiting to prevent flooding
- Progress notifications **MUST** stop after completion

--- END OF FILE 2025-03-26/basic/utilities/progress.mdx ---


--- START OF FILE 2025-03-26/basic/authorization.mdx ---
---
title: Authorization
---

<Info>**Protocol Revision**: 2025-03-26</Info>

## Introduction

### Purpose and Scope

The Model Context Protocol provides authorization capabilities at the transport level,
enabling MCP clients to make requests to restricted MCP servers on behalf of resource
owners. This specification defines the authorization flow for HTTP-based transports.

### Protocol Requirements

Authorization is **OPTIONAL** for MCP implementations. When supported:

- Implementations using an HTTP-based transport **SHOULD** conform to this specification.
- Implementations using an STDIO transport **SHOULD NOT** follow this specification, and
  instead retrieve credentials from the environment.
- Implementations using alternative transports **MUST** follow established security best
  practices for their protocol.

### Standards Compliance

This authorization mechanism is based on established specifications listed below, but
implements a selected subset of their features to ensure security and interoperability
while maintaining simplicity:

- [OAuth 2.1 IETF DRAFT](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12)
- OAuth 2.0 Authorization Server Metadata
  ([RFC8414](https://datatracker.ietf.org/doc/html/rfc8414))
- OAuth 2.0 Dynamic Client Registration Protocol
  ([RFC7591](https://datatracker.ietf.org/doc/html/rfc7591))

## Authorization Flow

### Overview

1. MCP auth implementations **MUST** implement OAuth 2.1 with appropriate security
   measures for both confidential and public clients.

2. MCP auth implementations **SHOULD** support the OAuth 2.0 Dynamic Client Registration
   Protocol ([RFC7591](https://datatracker.ietf.org/doc/html/rfc7591)).

3. MCP servers **SHOULD** and MCP clients **MUST** implement OAuth 2.0 Authorization
   Server Metadata ([RFC8414](https://datatracker.ietf.org/doc/html/rfc8414)). Servers
   that do not support Authorization Server Metadata **MUST** follow the default URI
   schema.

### OAuth Grant Types

OAuth specifies different flows or grant types, which are different ways of obtaining an
access token. Each of these targets different use cases and scenarios.

MCP servers **SHOULD** support the OAuth grant types that best align with the intended
audience. For instance:

1. Authorization Code: useful when the client is acting on behalf of a (human) end user.
   - For instance, an agent calls an MCP tool implemented by a SaaS system.
2. Client Credentials: the client is another application (not a human)
   - For instance, an agent calls a secure MCP tool to check inventory at a specific
     store. No need to impersonate the end user.

### Example: authorization code grant

This demonstrates the OAuth 2.1 flow for the authorization code grant type, used for user
auth.

**NOTE**: The following example assumes the MCP server is also functioning as the
authorization server. However, the authorization server may be deployed as its own
distinct service.

A human user completes the OAuth flow through a web browser, obtaining an access token
that identifies them personally and allows the client to act on their behalf.

When authorization is required and not yet proven by the client, servers **MUST** respond
with _HTTP 401 Unauthorized_.

Clients initiate the
[OAuth 2.1 IETF DRAFT](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#name-authorization-code-grant)
authorization flow after receiving the _HTTP 401 Unauthorized_.

The following demonstrates the basic OAuth 2.1 for public clients using PKCE.

```mermaid
sequenceDiagram
    participant B as User-Agent (Browser)
    participant C as Client
    participant M as MCP Server

    C->>M: MCP Request
    M->>C: HTTP 401 Unauthorized
    Note over C: Generate code_verifier and code_challenge
    C->>B: Open browser with authorization URL + code_challenge
    B->>M: GET /authorize
    Note over M: User logs in and authorizes
    M->>B: Redirect to callback URL with auth code
    B->>C: Callback with authorization code
    C->>M: Token Request with code + code_verifier
    M->>C: Access Token (+ Refresh Token)
    C->>M: MCP Request with Access Token
    Note over C,M: Begin standard MCP message exchange
```

### Server Metadata Discovery

For server capability discovery:

- MCP clients _MUST_ follow the OAuth 2.0 Authorization Server Metadata protocol defined
  in [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414).
- MCP server _SHOULD_ follow the OAuth 2.0 Authorization Server Metadata protocol.
- MCP servers that do not support the OAuth 2.0 Authorization Server Metadata protocol,
  _MUST_ support fallback URLs.

The discovery flow is illustrated below:

```mermaid
sequenceDiagram
    participant C as Client
    participant S as Server

    C->>S: GET /.well-known/oauth-authorization-server
    alt Discovery Success
        S->>C: 200 OK + Metadata Document
        Note over C: Use endpoints from metadata
    else Discovery Failed
        S->>C: 404 Not Found
        Note over C: Fall back to default endpoints
    end
    Note over C: Continue with authorization flow
```

#### Server Metadata Discovery Headers

MCP clients _SHOULD_ include the header `MCP-Protocol-Version: <protocol-version>` during
Server Metadata Discovery to allow the MCP server to respond based on the MCP protocol
version.

For example: `MCP-Protocol-Version: 2024-11-05`

#### Authorization Base URL

The authorization base URL **MUST** be determined from the MCP server URL by discarding
any existing `path` component. For example:

If the MCP server URL is `https://api.example.com/v1/mcp`, then:

- The authorization base URL is `https://api.example.com`
- The metadata endpoint **MUST** be at
  `https://api.example.com/.well-known/oauth-authorization-server`

This ensures authorization endpoints are consistently located at the root level of the
domain hosting the MCP server, regardless of any path components in the MCP server URL.

#### Fallbacks for Servers without Metadata Discovery

For servers that do not implement OAuth 2.0 Authorization Server Metadata, clients
**MUST** use the following default endpoint paths relative to the [authorization base
URL](#authorization-base-url):

| Endpoint               | Default Path | Description                          |
| ---------------------- | ------------ | ------------------------------------ |
| Authorization Endpoint | /authorize   | Used for authorization requests      |
| Token Endpoint         | /token       | Used for token exchange & refresh    |
| Registration Endpoint  | /register    | Used for dynamic client registration |

For example, with an MCP server hosted at `https://api.example.com/v1/mcp`, the default
endpoints would be:

- `https://api.example.com/authorize`
- `https://api.example.com/token`
- `https://api.example.com/register`

Clients **MUST** first attempt to discover endpoints via the metadata document before
falling back to default paths. When using default paths, all other protocol requirements
remain unchanged.

### Dynamic Client Registration

MCP clients and servers **SHOULD** support the
[OAuth 2.0 Dynamic Client Registration Protocol](https://datatracker.ietf.org/doc/html/rfc7591)
to allow MCP clients to obtain OAuth client IDs without user interaction. This provides a
standardized way for clients to automatically register with new servers, which is crucial
for MCP because:

- Clients cannot know all possible servers in advance
- Manual registration would create friction for users
- It enables seamless connection to new servers
- Servers can implement their own registration policies

Any MCP servers that _do not_ support Dynamic Client Registration need to provide
alternative ways to obtain a client ID (and, if applicable, client secret). For one of
these servers, MCP clients will have to either:

1. Hardcode a client ID (and, if applicable, client secret) specifically for that MCP
   server, or
2. Present a UI to users that allows them to enter these details, after registering an
   OAuth client themselves (e.g., through a configuration interface hosted by the
   server).

### Authorization Flow Steps

The complete Authorization flow proceeds as follows:

```mermaid
sequenceDiagram
    participant B as User-Agent (Browser)
    participant C as Client
    participant M as MCP Server

    C->>M: GET /.well-known/oauth-authorization-server
    alt Server Supports Discovery
        M->>C: Authorization Server Metadata
    else No Discovery
        M->>C: 404 (Use default endpoints)
    end

    alt Dynamic Client Registration
        C->>M: POST /register
        M->>C: Client Credentials
    end

    Note over C: Generate PKCE Parameters
    C->>B: Open browser with authorization URL + code_challenge
    B->>M: Authorization Request
    Note over M: User /authorizes
    M->>B: Redirect to callback with authorization code
    B->>C: Authorization code callback
    C->>M: Token Request + code_verifier
    M->>C: Access Token (+ Refresh Token)
    C->>M: API Requests with Access Token
```

#### Decision Flow Overview

```mermaid
flowchart TD
    A[Start Auth Flow] --> B{Check Metadata Discovery}
    B -->|Available| C[Use Metadata Endpoints]
    B -->|Not Available| D[Use Default Endpoints]

    C --> G{Check Registration Endpoint}
    D --> G

    G -->|Available| H[Perform Dynamic Registration]
    G -->|Not Available| I[Alternative Registration Required]

    H --> J[Start OAuth Flow]
    I --> J

    J --> K[Generate PKCE Parameters]
    K --> L[Request Authorization]
    L --> M[User Authorization]
    M --> N[Exchange Code for Tokens]
    N --> O[Use Access Token]
```

### Access Token Usage

#### Token Requirements

Access token handling **MUST** conform to
[OAuth 2.1 Section 5](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5)
requirements for resource requests. Specifically:

1. MCP client **MUST** use the Authorization request header field
   [Section 5.1.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5.1.1):

```
Authorization: Bearer <access-token>
```

Note that authorization **MUST** be included in every HTTP request from client to server,
even if they are part of the same logical session.

2. Access tokens **MUST NOT** be included in the URI query string

Example request:

```http
GET /v1/contexts HTTP/1.1
Host: mcp.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

#### Token Handling

Resource servers **MUST** validate access tokens as described in
[Section 5.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5.2).
If validation fails, servers **MUST** respond according to
[Section 5.3](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5.3)
error handling requirements. Invalid or expired tokens **MUST** receive a HTTP 401
response.

### Security Considerations

The following security requirements **MUST** be implemented:

1. Clients **MUST** securely store tokens following OAuth 2.0 best practices
2. Servers **SHOULD** enforce token expiration and rotation
3. All authorization endpoints **MUST** be served over HTTPS
4. Servers **MUST** validate redirect URIs to prevent open redirect vulnerabilities
5. Redirect URIs **MUST** be either localhost URLs or HTTPS URLs

### Error Handling

Servers **MUST** return appropriate HTTP status codes for authorization errors:

| Status Code | Description  | Usage                                      |
| ----------- | ------------ | ------------------------------------------ |
| 401         | Unauthorized | Authorization required or token invalid    |
| 403         | Forbidden    | Invalid scopes or insufficient permissions |
| 400         | Bad Request  | Malformed authorization request            |

### Implementation Requirements

1. Implementations **MUST** follow OAuth 2.1 security best practices
2. PKCE is **REQUIRED** for all clients
3. Token rotation **SHOULD** be implemented for enhanced security
4. Token lifetimes **SHOULD** be limited based on security requirements

### Third-Party Authorization Flow

#### Overview

MCP servers **MAY** support delegated authorization through third-party authorization
servers. In this flow, the MCP server acts as both an OAuth client (to the third-party
auth server) and an OAuth authorization server (to the MCP client).

#### Flow Description

The third-party authorization flow comprises these steps:

1. MCP client initiates standard OAuth flow with MCP server
2. MCP server redirects user to third-party authorization server
3. User authorizes with third-party server
4. Third-party server redirects back to MCP server with authorization code
5. MCP server exchanges code for third-party access token
6. MCP server generates its own access token bound to the third-party session
7. MCP server completes original OAuth flow with MCP client

```mermaid
sequenceDiagram
    participant B as User-Agent (Browser)
    participant C as MCP Client
    participant M as MCP Server
    participant T as Third-Party Auth Server

    C->>M: Initial OAuth Request
    M->>B: Redirect to Third-Party /authorize
    B->>T: Authorization Request
    Note over T: User authorizes
    T->>B: Redirect to MCP Server callback
    B->>M: Authorization code
    M->>T: Exchange code for token
    T->>M: Third-party access token
    Note over M: Generate bound MCP token
    M->>B: Redirect to MCP Client callback
    B->>C: MCP authorization code
    C->>M: Exchange code for token
    M->>C: MCP access token
```

#### Session Binding Requirements

MCP servers implementing third-party authorization **MUST**:

1. Maintain secure mapping between third-party tokens and issued MCP tokens
2. Validate third-party token status before honoring MCP tokens
3. Implement appropriate token lifecycle management
4. Handle third-party token expiration and renewal

#### Security Considerations

When implementing third-party authorization, servers **MUST**:

1. Validate all redirect URIs
2. Securely store third-party credentials
3. Implement appropriate session timeout handling
4. Consider security implications of token chaining
5. Implement proper error handling for third-party auth failures

## Best Practices

#### Local clients as Public OAuth 2.1 Clients

We strongly recommend that local clients implement OAuth 2.1 as a public client:

1. Utilizing code challenges (PKCE) for authorization requests to prevent interception
   attacks
2. Implementing secure token storage appropriate for the local system
3. Following token refresh best practices to maintain sessions
4. Properly handling token expiration and renewal

#### Authorization Metadata Discovery

We strongly recommend that all clients implement metadata discovery. This reduces the
need for users to provide endpoints manually or clients to fallback to the defined
defaults.

#### Dynamic Client Registration

Since clients do not know the set of MCP servers in advance, we strongly recommend the
implementation of dynamic client registration. This allows applications to automatically
register with the MCP server, and removes the need for users to obtain client ids
manually.

--- END OF FILE 2025-03-26/basic/authorization.mdx ---


--- START OF FILE 2025-03-26/basic/index.mdx ---
---
title: Overview
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol consists of several key components that work together:

- **Base Protocol**: Core JSON-RPC message types
- **Lifecycle Management**: Connection initialization, capability negotiation, and
  session control
- **Server Features**: Resources, prompts, and tools exposed by servers
- **Client Features**: Sampling and root directory lists provided by clients
- **Utilities**: Cross-cutting concerns like logging and argument completion

All implementations **MUST** support the base protocol and lifecycle management
components. Other components **MAY** be implemented based on the specific needs of the
application.

These protocol layers establish clear separation of concerns while enabling rich
interactions between clients and servers. The modular design allows implementations to
support exactly the features they need.

## Messages

All messages between MCP clients and servers **MUST** follow the
[JSON-RPC 2.0](https://www.jsonrpc.org/specification) specification. The protocol defines
these types of messages:

### Requests

Requests are sent from the client to the server or vice versa, to initiate an operation.

```typescript
{
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

- Requests **MUST** include a string or integer ID.
- Unlike base JSON-RPC, the ID **MUST NOT** be `null`.
- The request ID **MUST NOT** have been previously used by the requestor within the same
  session.

### Responses

Responses are sent in reply to requests, containing the result or error of the operation.

```typescript
{
  jsonrpc: "2.0";
  id: string | number;
  result?: {
    [key: string]: unknown;
  }
  error?: {
    code: number;
    message: string;
    data?: unknown;
  }
}
```

- Responses **MUST** include the same ID as the request they correspond to.
- **Responses** are further sub-categorized as either **successful results** or
  **errors**. Either a `result` or an `error` **MUST** be set. A response **MUST NOT**
  set both.
- Results **MAY** follow any JSON object structure, while errors **MUST** include an
  error code and message at minimum.
- Error codes **MUST** be integers.

### Notifications

Notifications are sent from the client to the server or vice versa, as a one-way message.
The receiver **MUST NOT** send a response.

```typescript
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

- Notifications **MUST NOT** include an ID.

### Batching

JSON-RPC also defines a means to
[batch multiple requests and notifications](https://www.jsonrpc.org/specification#batch),
by sending them in an array. MCP implementations **MAY** support sending JSON-RPC
batches, but **MUST** support receiving JSON-RPC batches.

## Auth

MCP provides an [Authorization](/specification/2025-03-26/basic/authorization) framework for use with HTTP.
Implementations using an HTTP-based transport **SHOULD** conform to this specification,
whereas implementations using STDIO transport **SHOULD NOT** follow this specification,
and instead retrieve credentials from the environment.

Additionally, clients and servers **MAY** negotiate their own custom authentication and
authorization strategies.

For further discussions and contributions to the evolution of MCPâ€™s auth mechanisms, join
us in
[GitHub Discussions](https://github.com/modelcontextprotocol/specification/discussions)
to help shape the future of the protocol!

## Schema

The full specification of the protocol is defined as a
[TypeScript schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26/schema.ts).
This is the source of truth for all protocol messages and structures.

There is also a
[JSON Schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26/schema.json),
which is automatically generated from the TypeScript source of truth, for use with
various automated tooling.

--- END OF FILE 2025-03-26/basic/index.mdx ---


--- START OF FILE 2025-03-26/basic/lifecycle.mdx ---
---
title: Lifecycle
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol (MCP) defines a rigorous lifecycle for client-server
connections that ensures proper capability negotiation and state management.

1. **Initialization**: Capability negotiation and protocol version agreement
2. **Operation**: Normal protocol communication
3. **Shutdown**: Graceful termination of the connection

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Initialization Phase
    activate Client
    Client->>+Server: initialize request
    Server-->>Client: initialize response
    Client--)Server: initialized notification

    Note over Client,Server: Operation Phase
    rect rgb(200, 220, 250)
        note over Client,Server: Normal protocol operations
    end

    Note over Client,Server: Shutdown
    Client--)-Server: Disconnect
    deactivate Server
    Note over Client,Server: Connection closed
```

## Lifecycle Phases

### Initialization

The initialization phase **MUST** be the first interaction between client and server.
During this phase, the client and server:

- Establish protocol version compatibility
- Exchange and negotiate capabilities
- Share implementation details

The client **MUST** initiate this phase by sending an `initialize` request containing:

- Protocol version supported
- Client capabilities
- Client implementation information

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-03-26",
    "capabilities": {
      "roots": {
        "listChanged": true
      },
      "sampling": {}
    },
    "clientInfo": {
      "name": "ExampleClient",
      "version": "1.0.0"
    }
  }
}
```

The initialize request **MUST NOT** be part of a JSON-RPC
[batch](https://www.jsonrpc.org/specification#batch), as other requests and notifications
are not possible until initialization has completed. This also permits backwards
compatibility with prior protocol versions that do not explicitly support JSON-RPC
batches.

The server **MUST** respond with its own capabilities and information:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2025-03-26",
    "capabilities": {
      "logging": {},
      "prompts": {
        "listChanged": true
      },
      "resources": {
        "subscribe": true,
        "listChanged": true
      },
      "tools": {
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "ExampleServer",
      "version": "1.0.0"
    },
    "instructions": "Optional instructions for the client"
  }
}
```

After successful initialization, the client **MUST** send an `initialized` notification
to indicate it is ready to begin normal operations:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized"
}
```

- The client **SHOULD NOT** send requests other than
  [pings](/specification/2025-03-26/basic/utilities/ping) before the server has responded to the
  `initialize` request.
- The server **SHOULD NOT** send requests other than
  [pings](/specification/2025-03-26/basic/utilities/ping) and
  [logging](/specification/2025-03-26/server/utilities/logging) before receiving the `initialized`
  notification.

#### Version Negotiation

In the `initialize` request, the client **MUST** send a protocol version it supports.
This **SHOULD** be the _latest_ version supported by the client.

If the server supports the requested protocol version, it **MUST** respond with the same
version. Otherwise, the server **MUST** respond with another protocol version it
supports. This **SHOULD** be the _latest_ version supported by the server.

If the client does not support the version in the server's response, it **SHOULD**
disconnect.

#### Capability Negotiation

Client and server capabilities establish which optional protocol features will be
available during the session.

Key capabilities include:

| Category | Capability     | Description                                                                               |
| -------- | -------------- | ----------------------------------------------------------------------------------------- |
| Client   | `roots`        | Ability to provide filesystem [roots](/specification/2025-03-26/client/roots)             |
| Client   | `sampling`     | Support for LLM [sampling](/specification/2025-03-26/client/sampling) requests            |
| Client   | `experimental` | Describes support for non-standard experimental features                                  |
| Server   | `prompts`      | Offers [prompt templates](/specification/2025-03-26/server/prompts)                       |
| Server   | `resources`    | Provides readable [resources](/specification/2025-03-26/server/resources)                 |
| Server   | `tools`        | Exposes callable [tools](/specification/2025-03-26/server/tools)                          |
| Server   | `logging`      | Emits structured [log messages](/specification/2025-03-26/server/utilities/logging)       |
| Server   | `completions`  | Supports argument [autocompletion](/specification/2025-03-26/server/utilities/completion) |
| Server   | `experimental` | Describes support for non-standard experimental features                                  |

Capability objects can describe sub-capabilities like:

- `listChanged`: Support for list change notifications (for prompts, resources, and
  tools)
- `subscribe`: Support for subscribing to individual items' changes (resources only)

### Operation

During the operation phase, the client and server exchange messages according to the
negotiated capabilities.

Both parties **SHOULD**:

- Respect the negotiated protocol version
- Only use capabilities that were successfully negotiated

### Shutdown

During the shutdown phase, one side (usually the client) cleanly terminates the protocol
connection. No specific shutdown messages are definedâ€”instead, the underlying transport
mechanism should be used to signal connection termination:

#### stdio

For the stdio [transport](/specification/2025-03-26/basic/transports), the client **SHOULD** initiate
shutdown by:

1. First, closing the input stream to the child process (the server)
2. Waiting for the server to exit, or sending `SIGTERM` if the server does not exit
   within a reasonable time
3. Sending `SIGKILL` if the server does not exit within a reasonable time after `SIGTERM`

The server **MAY** initiate shutdown by closing its output stream to the client and
exiting.

#### HTTP

For HTTP [transports](/specification/2025-03-26/basic/transports), shutdown is indicated by closing the
associated HTTP connection(s).

## Timeouts

Implementations **SHOULD** establish timeouts for all sent requests, to prevent hung
connections and resource exhaustion. When the request has not received a success or error
response within the timeout period, the sender **SHOULD** issue a [cancellation
notification](/specification/2025-03-26/basic/utilities/cancellation) for that request and stop waiting for
a response.

SDKs and other middleware **SHOULD** allow these timeouts to be configured on a
per-request basis.

Implementations **MAY** choose to reset the timeout clock when receiving a [progress
notification](/specification/2025-03-26/basic/utilities/progress) corresponding to the request, as this
implies that work is actually happening. However, implementations **SHOULD** always
enforce a maximum timeout, regardless of progress notifications, to limit the impact of a
misbehaving client or server.

## Error Handling

Implementations **SHOULD** be prepared to handle these error cases:

- Protocol version mismatch
- Failure to negotiate required capabilities
- Request [timeouts](#timeouts)

Example initialization error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Unsupported protocol version",
    "data": {
      "supported": ["2024-11-05"],
      "requested": "1.0.0"
    }
  }
}
```

--- END OF FILE 2025-03-26/basic/lifecycle.mdx ---


--- START OF FILE 2025-03-26/basic/transports.mdx ---
---
title: Transports
---

<Info>**Protocol Revision**: 2025-03-26</Info>

MCP uses JSON-RPC to encode messages. JSON-RPC messages **MUST** be UTF-8 encoded.

The protocol currently defines two standard transport mechanisms for client-server
communication:

1. [stdio](#stdio), communication over standard in and standard out
2. [Streamable HTTP](#streamable-http)

Clients **SHOULD** support stdio whenever possible.

It is also possible for clients and servers to implement
[custom transports](#custom-transports) in a pluggable fashion.

## stdio

In the **stdio** transport:

- The client launches the MCP server as a subprocess.
- The server reads JSON-RPC messages from its standard input (`stdin`) and sends messages
  to its standard output (`stdout`).
- Messages may be JSON-RPC requests, notifications, responsesâ€”or a JSON-RPC
  [batch](https://www.jsonrpc.org/specification#batch) containing one or more requests
  and/or notifications.
- Messages are delimited by newlines, and **MUST NOT** contain embedded newlines.
- The server **MAY** write UTF-8 strings to its standard error (`stderr`) for logging
  purposes. Clients **MAY** capture, forward, or ignore this logging.
- The server **MUST NOT** write anything to its `stdout` that is not a valid MCP message.
- The client **MUST NOT** write anything to the server's `stdin` that is not a valid MCP
  message.

```mermaid
sequenceDiagram
    participant Client
    participant Server Process

    Client->>+Server Process: Launch subprocess
    loop Message Exchange
        Client->>Server Process: Write to stdin
        Server Process->>Client: Write to stdout
        Server Process--)Client: Optional logs on stderr
    end
    Client->>Server Process: Close stdin, terminate subprocess
    deactivate Server Process
```

## Streamable HTTP

<Info>

This replaces the [HTTP+SSE
transport](/specification/2024-11-05/basic/transports#http-with-sse) from
protocol version 2024-11-05. See the [backwards compatibility](#backwards-compatibility)
guide below.

</Info>

In the **Streamable HTTP** transport, the server operates as an independent process that
can handle multiple client connections. This transport uses HTTP POST and GET requests.
Server can optionally make use of
[Server-Sent Events](https://en.wikipedia.org/wiki/Server-sent_events) (SSE) to stream
multiple server messages. This permits basic MCP servers, as well as more feature-rich
servers supporting streaming and server-to-client notifications and requests.

The server **MUST** provide a single HTTP endpoint path (hereafter referred to as the
**MCP endpoint**) that supports both POST and GET methods. For example, this could be a
URL like `https://example.com/mcp`.

#### Security Warning

When implementing Streamable HTTP transport:

1. Servers **MUST** validate the `Origin` header on all incoming connections to prevent DNS rebinding attacks
2. When running locally, servers **SHOULD** bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)
3. Servers **SHOULD** implement proper authentication for all connections

Without these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.

### Sending Messages to the Server

Every JSON-RPC message sent from the client **MUST** be a new HTTP POST request to the
MCP endpoint.

1. The client **MUST** use HTTP POST to send JSON-RPC messages to the MCP endpoint.
2. The client **MUST** include an `Accept` header, listing both `application/json` and
   `text/event-stream` as supported content types.
3. The body of the POST request **MUST** be one of the following:
   - A single JSON-RPC _request_, _notification_, or _response_
   - An array [batching](https://www.jsonrpc.org/specification#batch) one or more
     _requests and/or notifications_
   - An array [batching](https://www.jsonrpc.org/specification#batch) one or more
     _responses_
4. If the input consists solely of (any number of) JSON-RPC _responses_ or
   _notifications_:
   - If the server accepts the input, the server **MUST** return HTTP status code 202
     Accepted with no body.
   - If the server cannot accept the input, it **MUST** return an HTTP error status code
     (e.g., 400 Bad Request). The HTTP response body **MAY** comprise a JSON-RPC _error
     response_ that has no `id`.
5. If the input contains any number of JSON-RPC _requests_, the server **MUST** either
   return `Content-Type: text/event-stream`, to initiate an SSE stream, or
   `Content-Type: application/json`, to return one JSON object. The client **MUST**
   support both these cases.
6. If the server initiates an SSE stream:
   - The SSE stream **SHOULD** eventually include one JSON-RPC _response_ per each
     JSON-RPC _request_ sent in the POST body. These _responses_ **MAY** be
     [batched](https://www.jsonrpc.org/specification#batch).
   - The server **MAY** send JSON-RPC _requests_ and _notifications_ before sending a
     JSON-RPC _response_. These messages **SHOULD** relate to the originating client
     _request_. These _requests_ and _notifications_ **MAY** be
     [batched](https://www.jsonrpc.org/specification#batch).
   - The server **SHOULD NOT** close the SSE stream before sending a JSON-RPC _response_
     per each received JSON-RPC _request_, unless the [session](#session-management)
     expires.
   - After all JSON-RPC _responses_ have been sent, the server **SHOULD** close the SSE
     stream.
   - Disconnection **MAY** occur at any time (e.g., due to network conditions).
     Therefore:
     - Disconnection **SHOULD NOT** be interpreted as the client cancelling its request.
     - To cancel, the client **SHOULD** explicitly send an MCP `CancelledNotification`.
     - To avoid message loss due to disconnection, the server **MAY** make the stream
       [resumable](#resumability-and-redelivery).

### Listening for Messages from the Server

1. The client **MAY** issue an HTTP GET to the MCP endpoint. This can be used to open an
   SSE stream, allowing the server to communicate to the client, without the client first
   sending data via HTTP POST.
2. The client **MUST** include an `Accept` header, listing `text/event-stream` as a
   supported content type.
3. The server **MUST** either return `Content-Type: text/event-stream` in response to
   this HTTP GET, or else return HTTP 405 Method Not Allowed, indicating that the server
   does not offer an SSE stream at this endpoint.
4. If the server initiates an SSE stream:
   - The server **MAY** send JSON-RPC _requests_ and _notifications_ on the stream. These
     _requests_ and _notifications_ **MAY** be
     [batched](https://www.jsonrpc.org/specification#batch).
   - These messages **SHOULD** be unrelated to any concurrently-running JSON-RPC
     _request_ from the client.
   - The server **MUST NOT** send a JSON-RPC _response_ on the stream **unless**
     [resuming](#resumability-and-redelivery) a stream associated with a previous client
     request.
   - The server **MAY** close the SSE stream at any time.
   - The client **MAY** close the SSE stream at any time.

### Multiple Connections

1. The client **MAY** remain connected to multiple SSE streams simultaneously.
2. The server **MUST** send each of its JSON-RPC messages on only one of the connected
   streams; that is, it **MUST NOT** broadcast the same message across multiple streams.
   - The risk of message loss **MAY** be mitigated by making the stream
     [resumable](#resumability-and-redelivery).

### Resumability and Redelivery

To support resuming broken connections, and redelivering messages that might otherwise be
lost:

1. Servers **MAY** attach an `id` field to their SSE events, as described in the
   [SSE standard](https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation).
   - If present, the ID **MUST** be globally unique across all streams within that
     [session](#session-management)â€”or all streams with that specific client, if session
     management is not in use.
2. If the client wishes to resume after a broken connection, it **SHOULD** issue an HTTP
   GET to the MCP endpoint, and include the
   [`Last-Event-ID`](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-last-event-id-header)
   header to indicate the last event ID it received.
   - The server **MAY** use this header to replay messages that would have been sent
     after the last event ID, _on the stream that was disconnected_, and to resume the
     stream from that point.
   - The server **MUST NOT** replay messages that would have been delivered on a
     different stream.

In other words, these event IDs should be assigned by servers on a _per-stream_ basis, to
act as a cursor within that particular stream.

### Session Management

An MCP "session" consists of logically related interactions between a client and a
server, beginning with the [initialization phase](/specification/2025-03-26/basic/lifecycle). To support
servers which want to establish stateful sessions:

1. A server using the Streamable HTTP transport **MAY** assign a session ID at
   initialization time, by including it in an `Mcp-Session-Id` header on the HTTP
   response containing the `InitializeResult`.
   - The session ID **SHOULD** be globally unique and cryptographically secure (e.g., a
     securely generated UUID, a JWT, or a cryptographic hash).
   - The session ID **MUST** only contain visible ASCII characters (ranging from 0x21 to
     0x7E).
2. If an `Mcp-Session-Id` is returned by the server during initialization, clients using
   the Streamable HTTP transport **MUST** include it in the `Mcp-Session-Id` header on
   all of their subsequent HTTP requests.
   - Servers that require a session ID **SHOULD** respond to requests without an
     `Mcp-Session-Id` header (other than initialization) with HTTP 400 Bad Request.
3. The server **MAY** terminate the session at any time, after which it **MUST** respond
   to requests containing that session ID with HTTP 404 Not Found.
4. When a client receives HTTP 404 in response to a request containing an
   `Mcp-Session-Id`, it **MUST** start a new session by sending a new `InitializeRequest`
   without a session ID attached.
5. Clients that no longer need a particular session (e.g., because the user is leaving
   the client application) **SHOULD** send an HTTP DELETE to the MCP endpoint with the
   `Mcp-Session-Id` header, to explicitly terminate the session.
   - The server **MAY** respond to this request with HTTP 405 Method Not Allowed,
     indicating that the server does not allow clients to terminate sessions.

### Sequence Diagram

```mermaid
sequenceDiagram
    participant Client
    participant Server

    note over Client, Server: initialization

    Client->>+Server: POST InitializeRequest
    Server->>-Client: InitializeResponse<br>Mcp-Session-Id: 1868a90c...

    Client->>+Server: POST InitializedNotification<br>Mcp-Session-Id: 1868a90c...
    Server->>-Client: 202 Accepted

    note over Client, Server: client requests
    Client->>+Server: POST ... request ...<br>Mcp-Session-Id: 1868a90c...

    alt single HTTP response
      Server->>Client: ... response ...
    else server opens SSE stream
      loop while connection remains open
          Server-)Client: ... SSE messages from server ...
      end
      Server-)Client: SSE event: ... response ...
    end
    deactivate Server

    note over Client, Server: client notifications/responses
    Client->>+Server: POST ... notification/response ...<br>Mcp-Session-Id: 1868a90c...
    Server->>-Client: 202 Accepted

    note over Client, Server: server requests
    Client->>+Server: GET<br>Mcp-Session-Id: 1868a90c...
    loop while connection remains open
        Server-)Client: ... SSE messages from server ...
    end
    deactivate Server

```

### Backwards Compatibility

Clients and servers can maintain backwards compatibility with the deprecated [HTTP+SSE
transport](/specification/2024-11-05/basic/transports#http-with-sse) (from
protocol version 2024-11-05) as follows:

**Servers** wanting to support older clients should:

- Continue to host both the SSE and POST endpoints of the old transport, alongside the
  new "MCP endpoint" defined for the Streamable HTTP transport.
  - It is also possible to combine the old POST endpoint and the new MCP endpoint, but
    this may introduce unneeded complexity.

**Clients** wanting to support older servers should:

1. Accept an MCP server URL from the user, which may point to either a server using the
   old transport or the new transport.
2. Attempt to POST an `InitializeRequest` to the server URL, with an `Accept` header as
   defined above:
   - If it succeeds, the client can assume this is a server supporting the new Streamable
     HTTP transport.
   - If it fails with an HTTP 4xx status code (e.g., 405 Method Not Allowed or 404 Not
     Found):
     - Issue a GET request to the server URL, expecting that this will open an SSE stream
       and return an `endpoint` event as the first event.
     - When the `endpoint` event arrives, the client can assume this is a server running
       the old HTTP+SSE transport, and should use that transport for all subsequent
       communication.

## Custom Transports

Clients and servers **MAY** implement additional custom transport mechanisms to suit
their specific needs. The protocol is transport-agnostic and can be implemented over any
communication channel that supports bidirectional message exchange.

Implementers who choose to support custom transports **MUST** ensure they preserve the
JSON-RPC message format and lifecycle requirements defined by MCP. Custom transports
**SHOULD** document their specific connection establishment and message exchange patterns
to aid interoperability.

--- END OF FILE 2025-03-26/basic/transports.mdx ---


--- START OF FILE 2025-03-26/client/roots.mdx ---
---
title: Roots
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol (MCP) provides a standardized way for clients to expose
filesystem "roots" to servers. Roots define the boundaries of where servers can operate
within the filesystem, allowing them to understand which directories and files they have
access to. Servers can request the list of roots from supporting clients and receive
notifications when that list changes.

## User Interaction Model

Roots in MCP are typically exposed through workspace or project configuration interfaces.

For example, implementations could offer a workspace/project picker that allows users to
select directories and files the server should have access to. This can be combined with
automatic workspace detection from version control systems or project files.

However, implementations are free to expose roots through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Capabilities

Clients that support roots **MUST** declare the `roots` capability during
[initialization](/specification/2025-03-26/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "roots": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the client will emit notifications when the list of roots
changes.

## Protocol Messages

### Listing Roots

To retrieve roots, servers send a `roots/list` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "roots/list"
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "roots": [
      {
        "uri": "file:///home/user/projects/myproject",
        "name": "My Project"
      }
    ]
  }
}
```

### Root List Changes

When roots change, clients that support `listChanged` **MUST** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/roots/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Server
    participant Client

    Note over Server,Client: Discovery
    Server->>Client: roots/list
    Client-->>Server: Available roots

    Note over Server,Client: Changes
    Client--)Server: notifications/roots/list_changed
    Server->>Client: roots/list
    Client-->>Server: Updated roots
```

## Data Types

### Root

A root definition includes:

- `uri`: Unique identifier for the root. This **MUST** be a `file://` URI in the current
  specification.
- `name`: Optional human-readable name for display purposes.

Example roots for different use cases:

#### Project Directory

```json
{
  "uri": "file:///home/user/projects/myproject",
  "name": "My Project"
}
```

#### Multiple Repositories

```json
[
  {
    "uri": "file:///home/user/repos/frontend",
    "name": "Frontend Repository"
  },
  {
    "uri": "file:///home/user/repos/backend",
    "name": "Backend Repository"
  }
]
```

## Error Handling

Clients **SHOULD** return standard JSON-RPC errors for common failure cases:

- Client does not support roots: `-32601` (Method not found)
- Internal errors: `-32603`

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Roots not supported",
    "data": {
      "reason": "Client does not have roots capability"
    }
  }
}
```

## Security Considerations

1. Clients **MUST**:

   - Only expose roots with appropriate permissions
   - Validate all root URIs to prevent path traversal
   - Implement proper access controls
   - Monitor root accessibility

2. Servers **SHOULD**:
   - Handle cases where roots become unavailable
   - Respect root boundaries during operations
   - Validate all paths against provided roots

## Implementation Guidelines

1. Clients **SHOULD**:

   - Prompt users for consent before exposing roots to servers
   - Provide clear user interfaces for root management
   - Validate root accessibility before exposing
   - Monitor for root changes

2. Servers **SHOULD**:
   - Check for roots capability before usage
   - Handle root list changes gracefully
   - Respect root boundaries in operations
   - Cache root information appropriately

--- END OF FILE 2025-03-26/client/roots.mdx ---


--- START OF FILE 2025-03-26/client/sampling.mdx ---
---
title: Sampling
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to request LLM
sampling ("completions" or "generations") from language models via clients. This flow
allows clients to maintain control over model access, selection, and permissions while
enabling servers to leverage AI capabilities&mdash;with no server API keys necessary.
Servers can request text, audio, or image-based interactions and optionally include
context from MCP servers in their prompts.

## User Interaction Model

Sampling in MCP allows servers to implement agentic behaviors, by enabling LLM calls to
occur _nested_ inside other MCP server features.

Implementations are free to expose sampling through any interface pattern that suits
their needs&mdash;the protocol itself does not mandate any specific user interaction
model.

<Warning>

For trust & safety and security, there **SHOULD** always
be a human in the loop with the ability to deny sampling requests.

Applications **SHOULD**:

- Provide UI that makes it easy and intuitive to review sampling requests
- Allow users to view and edit prompts before sending
- Present generated responses for review before delivery

</Warning>

## Capabilities

Clients that support sampling **MUST** declare the `sampling` capability during
[initialization](/specification/2025-03-26/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "sampling": {}
  }
}
```

## Protocol Messages

### Creating Messages

To request a language model generation, servers send a `sampling/createMessage` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "What is the capital of France?"
        }
      }
    ],
    "modelPreferences": {
      "hints": [
        {
          "name": "claude-3-sonnet"
        }
      ],
      "intelligencePriority": 0.8,
      "speedPriority": 0.5
    },
    "systemPrompt": "You are a helpful assistant.",
    "maxTokens": 100
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "role": "assistant",
    "content": {
      "type": "text",
      "text": "The capital of France is Paris."
    },
    "model": "claude-3-sonnet-20240307",
    "stopReason": "endTurn"
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Server
    participant Client
    participant User
    participant LLM

    Note over Server,Client: Server initiates sampling
    Server->>Client: sampling/createMessage

    Note over Client,User: Human-in-the-loop review
    Client->>User: Present request for approval
    User-->>Client: Review and approve/modify

    Note over Client,LLM: Model interaction
    Client->>LLM: Forward approved request
    LLM-->>Client: Return generation

    Note over Client,User: Response review
    Client->>User: Present response for approval
    User-->>Client: Review and approve/modify

    Note over Server,Client: Complete request
    Client-->>Server: Return approved response
```

## Data Types

### Messages

Sampling messages can contain:

#### Text Content

```json
{
  "type": "text",
  "text": "The message content"
}
```

#### Image Content

```json
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/jpeg"
}
```

#### Audio Content

```json
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

### Model Preferences

Model selection in MCP requires careful abstraction since servers and clients may use
different AI providers with distinct model offerings. A server cannot simply request a
specific model by name since the client may not have access to that exact model or may
prefer to use a different provider's equivalent model.

To solve this, MCP implements a preference system that combines abstract capability
priorities with optional model hints:

#### Capability Priorities

Servers express their needs through three normalized priority values (0-1):

- `costPriority`: How important is minimizing costs? Higher values prefer cheaper models.
- `speedPriority`: How important is low latency? Higher values prefer faster models.
- `intelligencePriority`: How important are advanced capabilities? Higher values prefer
  more capable models.

#### Model Hints

While priorities help select models based on characteristics, `hints` allow servers to
suggest specific models or model families:

- Hints are treated as substrings that can match model names flexibly
- Multiple hints are evaluated in order of preference
- Clients **MAY** map hints to equivalent models from different providers
- Hints are advisory&mdash;clients make final model selection

For example:

```json
{
  "hints": [
    { "name": "claude-3-sonnet" }, // Prefer Sonnet-class models
    { "name": "claude" } // Fall back to any Claude model
  ],
  "costPriority": 0.3, // Cost is less important
  "speedPriority": 0.8, // Speed is very important
  "intelligencePriority": 0.5 // Moderate capability needs
}
```

The client processes these preferences to select an appropriate model from its available
options. For instance, if the client doesn't have access to Claude models but has Gemini,
it might map the sonnet hint to `gemini-1.5-pro` based on similar capabilities.

## Error Handling

Clients **SHOULD** return errors for common failure cases:

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -1,
    "message": "User rejected sampling request"
  }
}
```

## Security Considerations

1. Clients **SHOULD** implement user approval controls
2. Both parties **SHOULD** validate message content
3. Clients **SHOULD** respect model preference hints
4. Clients **SHOULD** implement rate limiting
5. Both parties **MUST** handle sensitive data appropriately

--- END OF FILE 2025-03-26/client/sampling.mdx ---


--- START OF FILE 2025-03-26/server/utilities/completion.mdx ---
---
title: Completion
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to offer
argument autocompletion suggestions for prompts and resource URIs. This enables rich,
IDE-like experiences where users receive contextual suggestions while entering argument
values.

## User Interaction Model

Completion in MCP is designed to support interactive user experiences similar to IDE code
completion.

For example, applications may show completion suggestions in a dropdown or popup menu as
users type, with the ability to filter and select from available options.

However, implementations are free to expose completion through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Capabilities

Servers that support completions **MUST** declare the `completions` capability:

```json
{
  "capabilities": {
    "completions": {}
  }
}
```

## Protocol Messages

### Requesting Completions

To get completion suggestions, clients send a `completion/complete` request specifying
what is being completed through a reference type:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "code_review"
    },
    "argument": {
      "name": "language",
      "value": "py"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "completion": {
      "values": ["python", "pytorch", "pyside"],
      "total": 10,
      "hasMore": true
    }
  }
}
```

### Reference Types

The protocol supports two types of completion references:

| Type           | Description                 | Example                                             |
| -------------- | --------------------------- | --------------------------------------------------- |
| `ref/prompt`   | References a prompt by name | `{"type": "ref/prompt", "name": "code_review"}`     |
| `ref/resource` | References a resource URI   | `{"type": "ref/resource", "uri": "file:///{path}"}` |

### Completion Results

Servers return an array of completion values ranked by relevance, with:

- Maximum 100 items per response
- Optional total number of available matches
- Boolean indicating if additional results exist

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client: User types argument
    Client->>Server: completion/complete
    Server-->>Client: Completion suggestions

    Note over Client: User continues typing
    Client->>Server: completion/complete
    Server-->>Client: Refined suggestions
```

## Data Types

### CompleteRequest

- `ref`: A `PromptReference` or `ResourceReference`
- `argument`: Object containing:
  - `name`: Argument name
  - `value`: Current value

### CompleteResult

- `completion`: Object containing:
  - `values`: Array of suggestions (max 100)
  - `total`: Optional total matches
  - `hasMore`: Additional results flag

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Method not found: `-32601` (Capability not supported)
- Invalid prompt name: `-32602` (Invalid params)
- Missing required arguments: `-32602` (Invalid params)
- Internal errors: `-32603` (Internal error)

## Implementation Considerations

1. Servers **SHOULD**:

   - Return suggestions sorted by relevance
   - Implement fuzzy matching where appropriate
   - Rate limit completion requests
   - Validate all inputs

2. Clients **SHOULD**:
   - Debounce rapid completion requests
   - Cache completion results where appropriate
   - Handle missing or partial results gracefully

## Security

Implementations **MUST**:

- Validate all completion inputs
- Implement appropriate rate limiting
- Control access to sensitive suggestions
- Prevent completion-based information disclosure

--- END OF FILE 2025-03-26/server/utilities/completion.mdx ---


--- START OF FILE 2025-03-26/server/utilities/logging.mdx ---
---
title: Logging
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to send
structured log messages to clients. Clients can control logging verbosity by setting
minimum log levels, with servers sending notifications containing severity levels,
optional logger names, and arbitrary JSON-serializable data.

## User Interaction Model

Implementations are free to expose logging through any interface pattern that suits their
needs&mdash;the protocol itself does not mandate any specific user interaction model.

## Capabilities

Servers that emit log message notifications **MUST** declare the `logging` capability:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

## Log Levels

The protocol follows the standard syslog severity levels specified in
[RFC 5424](https://datatracker.ietf.org/doc/html/rfc5424#section-6.2.1):

| Level     | Description                      | Example Use Case           |
| --------- | -------------------------------- | -------------------------- |
| debug     | Detailed debugging information   | Function entry/exit points |
| info      | General informational messages   | Operation progress updates |
| notice    | Normal but significant events    | Configuration changes      |
| warning   | Warning conditions               | Deprecated feature usage   |
| error     | Error conditions                 | Operation failures         |
| critical  | Critical conditions              | System component failures  |
| alert     | Action must be taken immediately | Data corruption detected   |
| emergency | System is unusable               | Complete system failure    |

## Protocol Messages

### Setting Log Level

To configure the minimum log level, clients **MAY** send a `logging/setLevel` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "logging/setLevel",
  "params": {
    "level": "info"
  }
}
```

### Log Message Notifications

Servers send log messages using `notifications/message` notifications:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/message",
  "params": {
    "level": "error",
    "logger": "database",
    "data": {
      "error": "Connection failed",
      "details": {
        "host": "localhost",
        "port": 5432
      }
    }
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Configure Logging
    Client->>Server: logging/setLevel (info)
    Server-->>Client: Empty Result

    Note over Client,Server: Server Activity
    Server--)Client: notifications/message (info)
    Server--)Client: notifications/message (warning)
    Server--)Client: notifications/message (error)

    Note over Client,Server: Level Change
    Client->>Server: logging/setLevel (error)
    Server-->>Client: Empty Result
    Note over Server: Only sends error level<br/>and above
```

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Invalid log level: `-32602` (Invalid params)
- Configuration errors: `-32603` (Internal error)

## Implementation Considerations

1. Servers **SHOULD**:

   - Rate limit log messages
   - Include relevant context in data field
   - Use consistent logger names
   - Remove sensitive information

2. Clients **MAY**:
   - Present log messages in the UI
   - Implement log filtering/search
   - Display severity visually
   - Persist log messages

## Security

1. Log messages **MUST NOT** contain:

   - Credentials or secrets
   - Personal identifying information
   - Internal system details that could aid attacks

2. Implementations **SHOULD**:
   - Rate limit messages
   - Validate all data fields
   - Control log access
   - Monitor for sensitive content

--- END OF FILE 2025-03-26/server/utilities/logging.mdx ---


--- START OF FILE 2025-03-26/server/utilities/pagination.mdx ---
---
title: Pagination
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol (MCP) supports paginating list operations that may return
large result sets. Pagination allows servers to yield results in smaller chunks rather
than all at once.

Pagination is especially important when connecting to external services over the
internet, but also useful for local integrations to avoid performance issues with large
data sets.

## Pagination Model

Pagination in MCP uses an opaque cursor-based approach, instead of numbered pages.

- The **cursor** is an opaque string token, representing a position in the result set
- **Page size** is determined by the server, and clients **MUST NOT** assume a fixed page
  size

## Response Format

Pagination starts when the server sends a **response** that includes:

- The current page of results
- An optional `nextCursor` field if more results exist

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {
    "resources": [...],
    "nextCursor": "eyJwYWdlIjogM30="
  }
}
```

## Request Format

After receiving a cursor, the client can _continue_ paginating by issuing a request
including that cursor:

```json
{
  "jsonrpc": "2.0",
  "method": "resources/list",
  "params": {
    "cursor": "eyJwYWdlIjogMn0="
  }
}
```

## Pagination Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: List Request (no cursor)
    loop Pagination Loop
      Server-->>Client: Page of results + nextCursor
      Client->>Server: List Request (with cursor)
    end
```

## Operations Supporting Pagination

The following MCP operations support pagination:

- `resources/list` - List available resources
- `resources/templates/list` - List resource templates
- `prompts/list` - List available prompts
- `tools/list` - List available tools

## Implementation Guidelines

1. Servers **SHOULD**:

   - Provide stable cursors
   - Handle invalid cursors gracefully

2. Clients **SHOULD**:

   - Treat a missing `nextCursor` as the end of results
   - Support both paginated and non-paginated flows

3. Clients **MUST** treat cursors as opaque tokens:
   - Don't make assumptions about cursor format
   - Don't attempt to parse or modify cursors
   - Don't persist cursors across sessions

## Error Handling

Invalid cursors **SHOULD** result in an error with code -32602 (Invalid params).

--- END OF FILE 2025-03-26/server/utilities/pagination.mdx ---


--- START OF FILE 2025-03-26/server/index.mdx ---
---
title: Overview
---

<Info>**Protocol Revision**: 2025-03-26</Info>

Servers provide the fundamental building blocks for adding context to language models via
MCP. These primitives enable rich interactions between clients, servers, and language
models:

- **Prompts**: Pre-defined templates or instructions that guide language model
  interactions
- **Resources**: Structured data or content that provides additional context to the model
- **Tools**: Executable functions that allow models to perform actions or retrieve
  information

Each primitive can be summarized in the following control hierarchy:

| Primitive | Control                | Description                                        | Example                         |
| --------- | ---------------------- | -------------------------------------------------- | ------------------------------- |
| Prompts   | User-controlled        | Interactive templates invoked by user choice       | Slash commands, menu options    |
| Resources | Application-controlled | Contextual data attached and managed by the client | File contents, git history      |
| Tools     | Model-controlled       | Functions exposed to the LLM to take actions       | API POST requests, file writing |

Explore these key primitives in more detail below:

<CardGroup cols={3}>
  <Card
    title="Prompts"
    icon="message"
    href="/specification/2025-03-26/server/prompts"
  />
  <Card
    title="Resources"
    icon="file-lines"
    href="/specification/2025-03-26/server/resources"
  />
  <Card
    title="Tools"
    icon="wrench"
    href="/specification/2025-03-26/server/tools"
  />
</CardGroup>

--- END OF FILE 2025-03-26/server/index.mdx ---


--- START OF FILE 2025-03-26/server/prompts.mdx ---
---
title: Prompts
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to expose prompt
templates to clients. Prompts allow servers to provide structured messages and
instructions for interacting with language models. Clients can discover available
prompts, retrieve their contents, and provide arguments to customize them.

## User Interaction Model

Prompts are designed to be **user-controlled**, meaning they are exposed from servers to
clients with the intention of the user being able to explicitly select them for use.

Typically, prompts would be triggered through user-initiated commands in the user
interface, which allows users to naturally discover and invoke available prompts.

For example, as slash commands:

![Example of prompt exposed as slash command](/specification/2025-03-26/server/slash-command.png)

However, implementors are free to expose prompts through any interface pattern that suits
their needs&mdash;the protocol itself does not mandate any specific user interaction
model.

## Capabilities

Servers that support prompts **MUST** declare the `prompts` capability during
[initialization](/specification/2025-03-26/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "prompts": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the server will emit notifications when the list of
available prompts changes.

## Protocol Messages

### Listing Prompts

To retrieve available prompts, clients send a `prompts/list` request. This operation
supports [pagination](/specification/2025-03-26/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "prompts/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "prompts": [
      {
        "name": "code_review",
        "description": "Asks the LLM to analyze code quality and suggest improvements",
        "arguments": [
          {
            "name": "code",
            "description": "The code to review",
            "required": true
          }
        ]
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Getting a Prompt

To retrieve a specific prompt, clients send a `prompts/get` request. Arguments may be
auto-completed through [the completion API](/specification/2025-03-26/server/utilities/completion).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "prompts/get",
  "params": {
    "name": "code_review",
    "arguments": {
      "code": "def hello():\n    print('world')"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "description": "Code review prompt",
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "Please review this Python code:\ndef hello():\n    print('world')"
        }
      }
    ]
  }
}
```

### List Changed Notification

When the list of available prompts changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/prompts/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Discovery
    Client->>Server: prompts/list
    Server-->>Client: List of prompts

    Note over Client,Server: Usage
    Client->>Server: prompts/get
    Server-->>Client: Prompt content

    opt listChanged
      Note over Client,Server: Changes
      Server--)Client: prompts/list_changed
      Client->>Server: prompts/list
      Server-->>Client: Updated prompts
    end
```

## Data Types

### Prompt

A prompt definition includes:

- `name`: Unique identifier for the prompt
- `description`: Optional human-readable description
- `arguments`: Optional list of arguments for customization

### PromptMessage

Messages in a prompt can contain:

- `role`: Either "user" or "assistant" to indicate the speaker
- `content`: One of the following content types:

#### Text Content

Text content represents plain text messages:

```json
{
  "type": "text",
  "text": "The text content of the message"
}
```

This is the most common content type used for natural language interactions.

#### Image Content

Image content allows including visual information in messages:

```json
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/png"
}
```

The image data **MUST** be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where visual context is important.

#### Audio Content

Audio content allows including audio information in messages:

```json
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

The audio data MUST be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where audio context is important.

#### Embedded Resources

Embedded resources allow referencing server-side resources directly in messages:

```json
{
  "type": "resource",
  "resource": {
    "uri": "resource://example",
    "mimeType": "text/plain",
    "text": "Resource content"
  }
}
```

Resources can contain either text or binary (blob) data and **MUST** include:

- A valid resource URI
- The appropriate MIME type
- Either text content or base64-encoded blob data

Embedded resources enable prompts to seamlessly incorporate server-managed content like
documentation, code samples, or other reference materials directly into the conversation
flow.

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Invalid prompt name: `-32602` (Invalid params)
- Missing required arguments: `-32602` (Invalid params)
- Internal errors: `-32603` (Internal error)

## Implementation Considerations

1. Servers **SHOULD** validate prompt arguments before processing
2. Clients **SHOULD** handle pagination for large prompt lists
3. Both parties **SHOULD** respect capability negotiation

## Security

Implementations **MUST** carefully validate all prompt inputs and outputs to prevent
injection attacks or unauthorized access to resources.

--- END OF FILE 2025-03-26/server/prompts.mdx ---


--- START OF FILE 2025-03-26/server/resource-picker.png ---
ï¿½PNG

   
IHDR   ï¿½   ï¿½   ï¿½Ä¶  `iCCPICC Profile  (ï¿½uï¿½;HAï¿½ï¿½h$Dï¿½ï¿½H!Qï¿½*ï¿½ï¿½ï¿½rF,ï¿½ XQï¿½ï¿½Kï¿½ï¿½dï¿½wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6bciï¿½ï¿½BÒ‰ï¿½ï¿½"ï¿½ï¿½B4ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½3ï¿½ ï¿½%ï¿½gï¿½	ium]ï¿½!
?Âšnï¿½ï¿½ï¿½.P	ï¿½ï¿½ï¿½ï¿½ï¿½z7&fÍ¤cRï¿½rp68$oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½~Pï¿½tï¿½mï¿½ï¿½ï¿½;6|Hï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½-ï¿½5kï¿½2Iï¿½{ï¿½^ï¿½rï¿½ï¿½Ä‘lï¿½oï¿½qï¿½ï¿½Ö¿vï¿½ï¿½ï¿½Eï¿½0ï¿½0Rï¿½Ã¤ï¿½ï¿½
ï¿½P ÓŸ"ï¿½?}Jï¿½/ï¿½2ï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½Â¤ï¿½ï¿½Qï¿½ï¿½qDï¿½eLR*ï¿½Þ¿ï¿½ï¿½zGï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%Pï¿½ï¿½×®7z\7Lï¿½ï¿½ï¿½u=uï¿½ï¿½ï¿½[ï¿½@Ï›ã¼Ž ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½qï¿½@ï¿½#Pï¿½|.Laï¿½vY'   beXIfMM *           ï¿½i       &     ï¿½ï¿½       Pï¿½       ï¿½ï¿½       ï¿½    ASCII   Screenshot9UD  =iTXtXML:com.adobe.xmp     <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="XMP Core 6.0.0">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:exif="http://ns.adobe.com/exif/1.0/"
            xmlns:tiff="http://ns.adobe.com/tiff/1.0/">
         <exif:PixelYDimension>181</exif:PixelYDimension>
         <exif:UserComment>Screenshot</exif:UserComment>
         <exif:PixelXDimension>174</exif:PixelXDimension>
         <tiff:Orientation>1</tiff:Orientation>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
oPï¿½=  3HIDATxï¿½}ï¿½Õ‘nMMï¿½fA(ï¿½0BFH"ï¿½dlï¿½ï¿½ï¿½ï¿½omdï¿½ï¿½ï¿½9ï¿½. ï¿½kï¿½g>{ï¿½kï¿½
ï¿½È€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½EAHï¿½ï¿½rï¿½H3ï¿½hï¿½hï¿½ï¿½ï¿½ï¿½ï¿½Ü¾}cï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½V×©:uï¿½Ô©S]}ï¿½oß¢ï¿½ï¿½Sï¿½Qï¿½rï¿½Xï¿½eï¿½ï¿½1ï¿½ï¿½Þ‘ï¿½EDï¿½,ï¿½_ï¿½RQï¿½ ï¿½ï¿½ï¿½Wï¿½Hzdï¿½L,P,N+ï¿½?2ï¿½ï¿½ï¿½ï¿½x"ï¿½ï¿½ï¿½i%ï¿½f
ï¿½ï¿½Pï¿½^]]Mï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Bï¿½wï¿½*%+ï¿½ï¿½fï¿½Lï¿½ï¿½ wï¿½ï¿½i:]}ï¿½Uqï¿½oXOï¿½>ï¿½;ï¿½ï¿½ï¿½[izï¿½4ï¿½ï¿½ï¿½wï¿½ï¿½C@ï¿½ï¿½;ï¿½ï¿½.ï¿½[ï¿½>kï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½hï¿½ï¿½IT\TL}ï¿½iï¿½Õ¯~ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6å—¿ï¿½5=ï¿½ï¿½v9çœ³éš«ï¿½ï¿½;vï¿½ï¿½Iï¿½ï¿½7ï¿½ï¿½-ï¿½ï¿½ï¿½ï¿½6Û cAï¿½ï¿½ï¿½
Zï¿½Nï¿½ï¿½ï¿½kï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½
ï¿½æš«hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~''ï¿½ï¿½UWï¿½Oï¿½sï¿½Rï¿½-iï¿½%ï¿½ï¿½ï¿½!ï¿½ï¿½ï¿½XW\~-ï¿½Åƒï¿½ï¿½~ï¿½ï¿½wï¿½ï¿½ï¿½ï¿½ï¿½|9mÝ¶=ï¿½ï¿½1cï¿½Ò‹/ï¿½H+Vï¿½ï¿½ï¿½ï¿½Ú½ï¿½=ï¿½ï¿½È‘#ï¿½c[L_ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>!ï¿½ï¿½ï¿½]Kç·ï¿½ wÌ˜1ï¿½ï¿½Ö›ï¿½/~ï¿½ï¿½=ï¿½ï¿½@!ï¿½nï¿½ï¿½Îªï¿½*8ï¿½)=Dï¿½ï¿½pÐ›nï¿½ï¿½+ï¿½N#zï¿½
"<ï¿½z.ï¿½.ï¿½ï¿½Wnï¿½5kï¿½Òµ<ï¿½Cï¿½ï¿½uz0nï¿½XZï¿½ï¿½
zsï¿½ï¿½Jï¿½ï¿½Gï¿½ï¿½]D]]ï¿½Bï¿½|,ï¿½ï¿½ï¿½ï¿½ï¿½r
}ï¿½ï¿½Rï¿½?ï¿½ï¿½ï¿½ï¿½N+Jï¿½+.ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4oï¿½\Ú¶mï¿½ï¿½ï¿½ ;wî¤†ï¿½ï¿½ï¿½=Wï¿½ï¿½wï¿½Fwï¿½ï¿½}ï¿½ï¿½ï¿½oï¿½)ï¿½Nï¿½ï¿½oï¿½I<ï¿½ï¿½ï¿½%ï¿½Lï¿½:Eï¿½ï¿½ï¿½H;/ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8pï¿½ï¿½m JFï¿½lï¿½9.ï¿½Ù¹nÎš(^SSMï¿½ï¿½ï¿½ï¿½ï¿½dï¿½-rï¿½WGï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bÖ‘ï¿½Dï¿½_ï¿½ï¿½ujDeÔŸwÞ¹ï¿½Uï¿½ï¿½Aï¿½m`ï¿½ï¿½ï¿½Ó§ï¿½/ï¿½ï¿½ï¿½xï¿½v[ï¿½ï¿½ï¿½aÃ†ï¿½ï¿½ï¿½_Kï¿½ï¿½ï¿½ï¿½yï¿½ï¿½sï¿½Csï¿½Ì¦qï¿½ï¿½qï¿½ï¿½ï¿½z0ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½|{ï¿½ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½	/ï¿½8Ï|/=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½Oï¿½mï¿½1ï¿½Aï¿½ï¿½4oï¿½<qï¿½W^yï¿½ï¿½{ï¿½o4ï¿½ï¿½VUEXTpï¿½9sï¿½ï¿½ï¿½É“%yï¿½ï¿½ï¿½i5/ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½hÏžï¿½4fï¿½hï¿½ï¿½ï¿½ï¿½ï¿½{~(iï¿½ï¿½ï¿½ï¿½yA\ï¿½ï¿½ï¿½ï¿½ï¿½`>nï¿½ï¿½Kï¿½ï¿½3ï¿½R'ï¿½;Ð¥Xï¿½)ï¿½ï¿½cï¿½ï¿½xH"Ú¦+ï¿½~|pz8
"3rTï¿½!ï¿½ï¿½Oï¿½ï¿½)?ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½Aï¿½~ï¿½Cï¿½ï¿½ï¿½|ï¿½
Gï¿½ï¿½ï¿½4ï¿½ï¿½ï¿½ï¿½O[ï¿½DWg-ï¿½?ï¿½>ï¿½ï¿½%tï¿½ï¿½ï¿½"Qï¿½bagjgï¿½ï¿½Gï¿½*ï¿½ï¿½K_ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½}ï½’ï¿½xï¿½
Ú·oï¿½ï¿½!Ò®]ï¿½Vï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½ï¿½~{mÙ²ï¿½^}Mï¿½6Uï¿½Qï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½#nÙºï¿½ï¿½0ï¿½yï¿½fBï¿½EyGd8<ï¿½ï¿½ï¿½_ï¿½	Nï¿½h-|ÌœÙ”ï¿½ï¿½ï¿½&ï¿½eBHï¿½ï¿½ï¿½M%W`Ä†Jï¿½ï¿½d#
ï¿½~ï¿½ï¿½BM/ï¿½ tï¿½uï¿½cï¿½ï¿½hï¿½ï¿½ï¿½Nï¿½o_ï¿½ï¿½:ï¿½`ï¿½ï¿½ï¿½Q>]#ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½-{ï¿½ï¿½ï¿½É·ï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½.à¨¸ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½ï¿½fï¿½ï¿½ß¡/ï¿½k4ï¿½ï¿½sï¿½ï¿½.ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½>"ï¿½|ï¿½ï¿½Iï¿½"ï¿½ï¿½ï¿½Î¦Mï¿½hï¿½"ï¿½*î¸»ï¿½ï¿½JKJï¿½ï¿½HwOï¿½fcï¿½Ä‰tï¿½I'ï¿½%lï¿½ï¿½Å´uï¿½6ï¿½%ï¿½}ï¿½ï¿½ï¿½qMPï¿½ï¿½9Xjaå¸ˆï¿½,ï¿½7Çµï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½:/ï¿½×­[*ï¿½ï¿½Q4Smï¿½ï¿½p|ï¿½ï¿½9ï¿½ï¿½D?É‘cï¿½ï¿½ä°›ï¿½wttï¿½iï¿½ï¿½~ï¿½ï¿½ï¿½i,ç²‹ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½bpÂ¦3ï¿½Zï¿½ï¿½#äŠ½ï¿½ï¿½ï¿½^|ï¿½%zï¿½ï¿½ï¿½ï¿½ï¿½qï¿½xï¿½É¿P
çµ¼-ï¿½Qï¿½ï¿½?ï¿½ï¿½ÚšZzï¿½hï¿½ï¿½ï¿½ï¿½ï¿½>vï¿½ï¿½ï¿½Úµï¿½Qï¿½v^uZÐ‚wWsXdï¿½ï¿½sï¿½ ï¿½%ï¿½ï¿½%+ï¿½ï¿½~FBJï¿½
Nï¿½Mï¿½#kï¿½vï¿½ï¿½ï¿½3ï¿½Å¿ï¿½ï¿½/ï¿½ï¿½nï¿½ï¿½tEï¿½)wï¿½ï¿½Eï¿½ï¿½+n\ï¿½ï¿½?ï¿½ï¿½*++]ï¿½]ï¿½v'ï¿½ï¿½rï¿½gï¿½Rï¿½ï¿½ï¿½ß–S	_ï¿½ï¿½WHï¿½0~ï¿½Iï¿½446ï¿½ï¿½ï¿½ï¿½ï¿½ 4ï¿½iï¿½ï¿½/ï¿½ï¿½Ø¸ï¿½Ë¦ï¿½A]ï¿½a9-ï¿½ï¿½ï¿½ï¿½l ï¿½ï¿½,ï¿½=Fï¿½ï¿½gï¿½u
^8Nï¿½pï¿½dï¿½#"2ï¿½ï¿½ï¿½ï¿½Ô¡ï¿½tà©œï¿½6]ï¿½ï¿½.*ï¿½ï¿½ï¿½Iï¿½Nï¿½Ygï¿½ï¿½N*Ò€3Nï¿½hï¿½ï¿½;ï¿½ï¿½uï¿½2ï¿½Tjï¿½s\ï¿½Oï¿½Û½8mFï¿½ZerRGOw7ï¿½ï¿½ï¿½ï¿½dï¿½@ï¿½fÏžï¿½gï¿½9ï¿½=Â§ï¿½ï¿½è¬³Î’(Ð±ï¿½>ï¿½,ï¿½Ó“O
;ï¿½ï¿½Qï¿½ï¿½ï¿½bï¿½tï¿½xï¿½'jï¿½ï¿½ï¿½ï¿½ï¿½q:ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½yï¿½mhï¿½oWKï¿½ï¿½ï¿½2ï¿½~ï¿½@ï¿½7UQï¿½iï¿½wWï¿½DZï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½	mWï¿½pP@ï¿½ï¿½ï¿½-ï¿½Ö·ï¿½{ï¿½qï¿½%ï¿½Ð±"Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½sï¿½%ï¿½!ï¿½ï¿½ï¿½Uï¿½ptÐµï¿½Ò›ï¿½7ï¿½ï¿½Qï¿½r
>wï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½|ï¿½ï¿½v~9..~&Lï¿½@ï¿½ï¿½=ï¿½ï¿½ï¿½kï¿½ï¿½ï¿½/ï¿½Vï¿½ï¿½|>uï¿½:ï¿½ï¿½ï¿½ï¿½ï¿½g-_Pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½rï¿½fï¿½Fï¿½pnï¿½ï¿½ï¿½ï¿½0oï¿½!Õ¸ï¿½ï¿½2iï¿½Dzooï¿½ï¿½ï¿½H
ï¿½td7ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½Xï¿½Ò….ï¿½?>ï¿½È¯ï¿½ï¿½ï¿½?Bï¿½Gï¿½fï¿½C6lï¿½ï¿½ï¿½z/ï¿½uï¿½8yï¿½ï¿½ï¿½ï¿½@ï¿½nlhï¿½ï¿½ï¿½p.ï¿½ï¿½R:ï¿½Çˆvmï¿½?Ò˜ï¿½ï¿½rï¿½ï¿½wHï¿½{ï¿½<ï¿½Sï¿½ï¿½gï¿½ï¿½}ï¿½fï¿½~8+\vï¿½ï¿½4mï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½Úªï¿½ï¿½ï¿½ï¿½ï¿½PGGxï¿½EMMï¿½tl'MMï¿½%ï¿½ï¿½ï¿½apXï¿½ï¿½Î¾!ï¿½Ó¢wï¿½ï¿½ï¿½ï¿½|	ï¿½tï¿½Sï¿½ï¿½#ï¿½ï¿½ï¿½Mï¿½Lï¿½ï¿½cï¿½ï¿½ï¿½ï¿½Uï¿½ï¿½mï¿½ï¿½ï¿½(ï¿½U:ï¿½ï¿½ï¿½QT"[]ï¿½<Iï¿½ï¿½>ï¿½ï¿½ï¿½$nAbaï¿½p ikï¿½ï¿½,ï¿½ZQQÉ»ï¿½Oï¿½ï¿½#Gï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½o]m$]`ï¿½ï¿½ï¿½ï¿½ï¿½Fï¿½*ï¿½ï¿½ Yï¿½}Vï¿½ï¿½ï¿½qï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½FLï¿½?ï¿½ï¿½}6ï¿½ï¿½%ï¿½Pï¿½Lï¿½ï¿½ï¿½#Yï¿½ï¿½luNï¿½ï¿½ï¿½o#ï¿½)ï¿½ï¿½rï¿½`ï¿½ï¿½ï¿½?~ï¿½ï¿½Q>Rï¿½Äµ@Bï¿½ï¿½ï¿½ï¿½r\lï¿½`ï¿½ï¿½?
ï¿½'ï¿½ï¿½ï¿½ï¿½=9ï¿½ï¿½ï¿½FVï¿½\ï¿½;kï¿½@ï¿½Mfï¿½4rï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½ï¿½ Nï¿½ï¿½ï¿½í‹»sï¿½.ï¿½`Z 7ï¿½8ï¿½ï¿½33ï¿½gqq0*ï¿½ï¿½ï¿½rï¿½Qn.ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½w0g,ï¿½[,Pï¿½h+NÄÇ™Ç¢ï¿½ï¿½?ï¿½xï¿½8ï¿½ï¿½iï¿½Aï¿½iï¿½49.TKï¿½};ï¿½Aï¿½ï¿½r\ï¿½YWoï¿½9ï¿½ï¿½ï¿½ï¿½ì¸©s[?zoï¿½Qï¿½hï¿½ï¿½/ï¿½O8ï¿½E.ï¿½ï¿½<ï¿½ï¿½O'ï¿½ï¿½DZï¿½ï¿½ï¿½cï¿½ï¿½?Åï¿½ï¿½Ñ·ï¿½Dhï¿½W#k6ï¿½0?Nï¿½ï¿½+gï¿½Tï¿½@2ï¿½ï¿½ï¿½ï¿½ï¿½qï¿½rï¿½dï¿½ï¿½&ï¿½=Fï¿½ï¿½ï¿½hKKï¿½\ï¿½ï¿½ï¿½D(dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½}ï¿½ï¿½^?ï¿½ï¿½*++ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½]ï¿½@D^ï¿½ï¿½o^ï¿½ï¿½&mï¿½ï¿½ï¿½NpGï¿½ÏƒÜ§ï¿½Dï¿½ï¿½$ï¿½ï¿½Ç‹ï¿½ä†…ï¿½_ï¿½(ï¿½ï¿½ï¿½ï¿½Tï¿½[Sï¿½~ï¿½ï¿½ï¿½eï¿½xyï¿½ï¿½ï¿½<ï¿½$yBYï¿½ï¿½y\ï¿½7ï¿½ï¿½f!9Dï¿½pï¿½
ï¿½eï¿½ï¿½ï¿½Zï¿½;Wï¿½ï¿½ï¿½>Å®Cï¿½ï¿½V0ï¿½
ï¿½ï¿½Dï¿½ï¿½ï¿½Yï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½B CPï¿½aë»lï¿½ï¿½ï¿½ï¿½d#e";ï¿½ï¿½S(9ï¿½ï¿½>ï¿½aï¿½ï¿½dï¿½ï¿½ï¿½ï¿½`dï¿½ï¿½ï¿½ iï¿½'tï¿½ï¿½iï¿½TtD\ï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½D8ï¿½ï¿½gï¿½ï¿½ï¿½ï¿½Oz;Xï¿½ï¿½ï¿½,ï¿½Nï¿½Qm7!#ï¿½ï¿½ï¿½ï¿½ï¿½qZs!fG\Gï¿½ï¿½ï¿½ï¿½ï¿½ZtEï¿½ï¿½F0SXï¿½ï¿½Ü„C"ï¿½ï¿½ï¿½Aï¿½ï¿½-ï¿½ï¿½ï¿½;ï¿½ï¿½,_ï¿½ï¿½k~Ì«ï¿½4
ï¿½ï¿½Qï¿½-Ç•ï¿½Df$ï¿½ï¿½]Lï¿½Eï¿½ï¿½ï¿½ï¿½ ï¿½Ô¨7%ï¿½7ï¿½Qï¿½ï¿½â¢ Sï¿½uÊ¥x&<Ù´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½LxTï¿½ï¿½ï¿½ï¿½]nï¿½WÌ¥zfï¿½sjctï¿½ï¿½Xï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç¤aAï¿½Xï¿½x|ï¿½Kn
6ï¿½9rï¿½d/7ï¿½>.{B'ï¿½rï¿½?ï¿½ï¿½t	ï¿½Ö|ï¿½
0ï¿½ï¿½.ï¿½C HqÚ«ï¿½ï¿½99'-^ï¿½^e6Ó‚ï¿½xTF&<fï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½MRï¿½,Æ¤2ï¿½ï¿½7ï¿½>ï¿½ï¿½xï¿½ï¿½ï¿½&ï¿½Ñ¹89>DyÅ…b>ï¿½
9ï¿½IWkï¿½?ï¿½ï¿½ï¿½ï¿½JJï¿½0ï¿½Gï¿½L:ï¿½fï¿½/ Q	bï¿½Rï¿½ï¿½ï¿½Mï¿½DlØ 0ï¿½ï¿½ï¿½Rï¿½&ï¿½hï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½Ü›ï¿½ï¿½ï¿½?ï¿½hï¿½ï¿½+'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½æ¸eï¿½ï¿½ï¿½KPbAï¿½JCnBï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½Jï¿½x,ï¿½ï¿½aï¿½09.7:ï¿½ï¿½ï¿½L@ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<!+Tï¿½!'ï¿½ï¿½ï¿½ï¿½ï¿½ar\g|ï¿½8ï¿½@6xï¿½sSï¿½ï¿½9ï¿½~ï¿½|oï¿½ï¿½GWKhï¿½Tï¿½Éµï¿½!#×¾Oï¿½vyï¿½quï¿½`ï¿½xWï¿½Hï¿½.ï¿½Bï¿½ï¿½,Y,:ï¿½0dï¿½Ô¨ï¿½ 0}<2ï¿½ï¿½/ï¿½Hï¿½%ï¿½ï¿½ï¿½+2ï¿½4aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,zï¿½ï¿½JMCFï¿½Nhï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½q3ï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½3Xxï¿½	=ï¿½ï¿½ï¿½ï¿½Í³
ï¿½ï¿½ï¿½Gs7VÑ€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!Ë²3-?Eï¿½ï¿½(=ï¿½ï¿½ï¿½uÅ£ï¿½dï¿½oï¿½9ï¿½ï¿½ï¿½Bï¿½ ï¿½8~ï¿½eï¿½
ï¿½ï¿½H×ŸÎ/ï¿½ÆºÚ¼LJG}:ï¿½dtï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½\ï¿½ï¿½gï¿½Qï¿½-ï¿½oï¿½ï¿½ï¿½gï¿½,N×¯ï¿½{nï¿½B8ï¿½Q$O::ï¿½Oï¿½8_ï¿½}Wï¿½Nï¿½ï¿½ï¿½Ulï¿½ï¿½ï¿½&ï¿½ï¿½Qvï¿½ï¿½gï¿½ï¿½__Bï¿½^r)-ï¿½ï¿½ï¿½ï¿½ï¿½/ï¿½Iï¿½Cï¿½2ï¿½ï¿½3ï¿½Iï¿½GTï¿½ï¿½ï¿½'ï¿½ï¿½Bï¿½yï¿½ï¿½;ï¿½ivXrï¿½ï¿½ï¿½[Lï¿½ï¿½ï¿½gMï¿½E?Ë–-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aGCï¿½ï¿½?ï¿½ï¿½A:ï¿½pï¿½ï¿½Å’ï¿½zï¿½ï¿½Ò¥K%Â£%.ï¿½uN^}ï¿½ï¿½Eï¿½ï¿½ï¿½}\ï¿½ï¿½ï¿½8t1ï¿½ï¿½ï¿½|ï¿½!ï¿½ï¿½ï¿½yï¿½vï¿½9sï¿½ï¿½ï¿½eï¿½ï¿½ï¿½lï¿½Q7ï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½zï¿½QCï¿½ï¿½>ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{6\ï¿½i"L9ï¿½ï¿½ï¿½ï¿½t4ï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ì´œï¿½"ï¿½ ï¿½"Ç½ï¿½ï¿½ï¿½ï¿½ï¿½9?)$Cï¿½Cyï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½y5ï¿½ï¿½ï¿½ièŽ£ï¿½QOZpï¿½ï¿½ï¿½ï¿½EZ8ï¿½uÑ8-ç·ˆï¿½ï¿½ï¿½Dï¿½0ï¿½}Xï¿½Aï¿½	ï¿½ï¿½ï¿½;ï¿½b $Hï¿½ï¿½ï¿½zï¿½ï¿½<ï¿½}9ï¿½;ï¿½ï¿½ï¿½NÎ˜ï¿½ï¿½ï¿½ï¿½Wï¿½5gï¿½Û‘vï¿½ã´ˆï¿½Ïiï»Ÿï¿½sï¿½kï¿½tï¿½ï¿½'ï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½>S\ï¿½ï¿½qï¿½mm>ï¿½}9ï¿½V{['Gï¿½4ß€0}ï¿½-ï¿½fï¿½1ï¿½ÂŽr ï¿½ï¿½JNï¿½M8ï¿½ï¿½Ï‘vï¿½wï¿½ÒªUï¿½ï¿½8#ï¿½ï¿½sï¿½tcJï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½{qmï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½Ç™ï¿½ï¿½ï¿½ï¿½jï¿½#ï¿½#.Jlï¿½6(.aPÂï¿½50 ï¿½ï¿½ï¿½Vï¿½ ï¿½Eï¿½ï¿½ï¿½iï¿½ï¿½ï¿½-ï¿½ï¿½ï¿½qï¿½ï¿½ï¿½ï¿½^cï¿½ï¿½ï¿½ï¿½:"ï¿½ï¿½@ï¿½}\]&ï¿½dMï¿½ï¿½Vhï¿½ï¿½ï¿½ï¿½ï¿½\N0QWï¿½Zï¿½ï¿½nï¿½]ï¿½:iï¿½ï¿½ï¿½KgÈ±KØ¸-ï¿½=ï¿½ï¿½ï¿½ï¿½zï¿½ï¿½mï¿½s`ï¿½ï¿½6vï¿½Wï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Xeï¿½ï¿½OÖ‡ï¿½ï¿½ï¿½J&Cï¿½Qï¿½9nï¿½Xï¿½ï¿½ ï¿½wï¿½ !;>ï¿½rziyï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½È‘ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½&G<Å½ï¿½Kï¿½+ï¿½ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½:ï¿½ï¿½sï¿½ï·¿ï¿½mN~ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6aï¿½ï¿½ï¿½ï¿½+^N	ï¿½ï¿½AEï¿½k/ï¿½+ï¿½ï¿½ï¿½ï¿½EMMï¿½8F!Lï¿½ï¿½ï¿½aMu5ï¿½wï¿½Yï¿½& Ò¢Hf<ï¿½=ï¿½%ï¿½z\Bï¿½ï¿½*ï¿½n`r56ï¿½ï¿½ï¿½)Kw<ru\ÙŽ)ï¿½ï¿½>rï¿½fï¿½ï¿½ï¿½ï¿½Ã€5ï¿½Uï¿½;.Æ…"ï¿½.CIï¿½&ï¿½ï¿½"ï¿½ï¿½qï¿½YCï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½1TQ5ï¿½ï¿½ï¿½oï¿½:ï¿½ï¿½ï¿½<.ï¿½ï¿½.ï¿½|aï¿½an8ì“¯ï¿½Ã¦TN-ï¿½Lï¿½{a0ï¿½ï¿½Vï¿½ï¿½ï¿½Îµï¿½pï¿½$ï¿½8ï¿½HQï¿½ï¿½ï¿½ï¿½Aï¿½Ê²ï¿½Ã–kï¿½ï¿½~ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½Ç•ï¿½Ú¯ï¿½ï¿½`Sï¿½T|Xï¿½0ï¿½ï¿½dï¿½Ê¬+&>ï¿½*ï¿½Bï¿½[u4ï¿½ï¿½gzï¿½ï¿½Ï±ï¿½ï¿½zï¿½yï¿½ï¿½Qï¿½ï¿½ï¿½&N_[ï¿½}Ì¼ï¿½ï¿½kZÉ³ï¿½cP(ï¿½Xï¿½Lï¿½5ï¿½ï¿½ï¿½sï¿½ï¿½<ï¿½ï¿½ï¿½ 
ï¿½ï¿½uï¿½ï¿½Wï¿½Cï¿½ï¿½ï¿½ãkï¿½ï¿½ï¿½8ï¿½ï¿½NNd
B_wï¿½8+ï¿½ qï¿½ï¿½z+ï¿½ï¿½ï¿½$ï¿½"*A,`ï¿½,ï¿½ï¿½ï¿½<ï¿½ÍŒ.ï¿½ï¿½ï¿½'Ó¬@ï¿½ï¿½Nï¿½ï¿½ï¿½@ï¿½8ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½j:]Dï¿½ï¿½<ï¿½+ï¿½mVï¿½(ï¿½ï¿½6ï¿½(ï¿½xï¿½ï¿½ï¿½f*Wï¿½i_^\ï¿½>ï¿½ï¿½Qï¿½d}{r\g@ï¿½Zï¿½sï¿½4Pq/Lï¿½Kï¿½ï¿½ï¿½Uï¿½Aï¿½W"ï¿½ï¿½Þš0qï¿½65ï¿½ï¿½Oï¿½]Ï‰3B|ï¿½b1ï¿½ï¿½H)1'1r
ï¿½Pï¿½xï¿½ï¿½*ï¿½ï¿½Imï¿½ï¿½%ï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½jxï¿½iï¿½*ï¿½ï¿½mkï¿½ï¿½sfï¿½*U%wï¿½ï¿½APï¿½ï¿½ï¿½ï¿½ï¿½Ag-ï¿½$ï¿½éŽ¡ï¿½ï¿½;V>?ï¿½Jï¿½ï¿½ ï¿½Wl~ï¿½m\ï¿½ï¿½ï¿½ï¿½Ü¯ï¿½ï¿½ï¿½Û¸ê±—8J&<ï¿½3ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç“ï¿½7ï¿½ï¿½
cï¿½aï¿½ï¿½.Í˜	ax6ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*ï¿½pï¿½>ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½ypï¿½ï¿½t2ï¿½ï¿½3ï¿½#Sï¿½X&ï¿½ï¿½v2iï¿½ï¿½ ï¿½
Cï¿½Ä²Lï¿½ï¿½1ï¿½x)ï¿½x&|ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½,ï¿½ï¿½
Û™Vï¿½qï¿½ï¿½ï¿½vï¿½n.ï¿½ï¿½v C!X ï¿½ï¿½qÓ*vNï¿½ï¿½lï¿½ï¿½VQmï¿½Y@ï¿½ï¿½E|5ï¿½ï¿½ï¿½ ï¿½ï¿½zï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç•ï¿½Vï¿½+É½ï¿½hï¿½ï¿½ï¿½K{ï¿½ï¿½ï¿½;U%bï¿½ï¿½#ï¿½7ï¿½ï¿½ï¿½ï¿½jï¿½jï¿½ï¿½jï¿½WTpï¿½ï¿½Gï¿½R?.ï¿½ï¿½ï¿½Imï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½3^nWï¿½ï¿½n,ï¿½ï¿½Ð°ï¿½gï¿½D\ï¿½}C9#qx
ï¿½ï¿½mï¿½
ï¿½13ï¿½ï¿½ï¿½@#Fï¿½Sooï¿½ï¿½wRwOï¿½ï¿½ï¿½rc"<ï¿½[^VFUÃªï¿½ï¿½!ï¿½ï¿½ï¿½Ctï¿½ï¿½ï¿½ï¿½Xfï¿½Å—e ï¿½ï¿½Ð¡kï¿½ÐŸÇ­ï¿½ï¿½ï¿½ï¿½ï¿½r;v4ï¿½tjï¿½8ï¿½:+ï¿½5iï¿½ï¿½%ï¿½Å´gï¿½>vîž¤|ï¿½ï¿½ï¿½@ï¿½ï¿½9ï¿½Ï’5[N+ï¿½+hï¿½ï¿½qtï¿½ï¿½ï¿½ï¿½ï¿½a7Â¦3ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½,#ï¿½~#~ï¿½zï¿½ï¿½Kï¿½ï¿½ï¿½|ï¿½Ï¡ï¿½ï¿½ ï¿½ï¿½ï¿½qï¿½ï¿½8lï¿½KW\ï¿½ï¿½ï¿½ï¿½c8ï¿½vwï¿½1Û‚6h;vï¿½(G#[ï¿½ï¿½Pkï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½=Lï¿½ï¿½Sï¿½Ãšï¿½ï¿½ï¿½Yï¿½uï¿½Aï¿½@ï¿½]ï¿½8ï¿½ï¿½ï¿½ï¿½Ñœï¿½Vï¿½ï¿½yGï¿½ï¿½ï¿½ï¿½Wr^!ï¿½ï¿½ï¿½mï¿½hcXï¿½={ï¿½ï¿½<.bï¿½ï¿½=ï¿½5ï¿½ï¿½ï¿½-ï¿½ï¿½Ø¾}|ï¿½ï¿½ï¿½Bï¿½ZZZï¿½Ý†ï¿½Bï¿½ï¿½myVA#nï¿½ï¿½ï¿½g>sï¿½ï¿½"nï¿½
ï¿½ï¿½jï¿½ï¿½ï¿½+ï¿½ï¿½5ï¿½^ï¿½Úµ{/ï¿½xï¿½ï¿½8ï¿½ï¿½sÎ¤ï¿½Æï¿½G{"ï¿½sØ‰ï¿½ï¿½Vï¿½mï¿½ï¿½ï¿½oï¿½Yqï¿½dï¿½ï¿½bvï¿½Lï¿½*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½7ï¿½Cï¿½5"rï¿½ï¿½
ï¿½ï¿½ï¿½pÚ¹gï¿½ï¿½:/ï¿½u+^]ï¿½Ó‚d7bÑ¢ï¿½ï¿½m7ï¿½ï¿½Gï¿½ï¿½Y@ï¿½ï¿½ï¿½ï¿½Sï¿½ï¿½~p7ï¿½Í£ÎŸw^(zï¿½ï¿½QCï¿½ï¿½eï¿½ï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½V(ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½6ï¿½2ï¿½Yï¿½uZï¿½ï¿½ï¿½[ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,, ï¿½ï¿½ï¿½ï—”ï¿½ï¿½ï¿½gS1ï¿½ï¿½=?ï¿½Û‘`ï¿½ï¿½gï¿½?zï¿½9nï¿½ï¿½ï¿½,ï¿½#ï¿½jï¿½VÔï¿½iï¿½ï¿½o ï¿½ï¿½%xï¿½ï¿½'ï¿½Dï¿½ï¿½ï¿½ï¿½___o3ï¿½Ó¿ï¿½|3Nï¿½tï¿½=ï¿½g3pï¿½Xï¿½/ï¿½ï¿½"ï¿½ï¿½ï¿½@ï¿½ï¿½s\^ï¿½ï¿½ï¿½d1ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½yï¿½9n
ï¿½ï¿½-7ï¿½_Þ£Î‹ï¿½ï¿½n~ï¿½Lw#ï¿½ï¿½y.ï¿½ZQï¿½ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Muï¿½9ï¿½y=lï¿½ï¿½5bDï¿½ï¿½`8.ï¿½Gï¿½8/G^L(ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½nï¿½ï¿½ï¿½%ï¿½ï¿½ï¿½ï¿½,ï¿½ 8hï¿½+ï¿½ï¿½Gï¿½9ï¿½ï¿½ï¿½t'ï¿½Mk;ï¿½ï¿½ï¿½r^<ï¿½0eï¿½ï¿½usï¿½ ï¿½Ö¯x#ï¿½'<xï¿½ï¿½o~Mï¿½ï¿½ï¿½Bw#.ï¿½Õ‰ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½g"ï¿½Fï¿½ï¿½ï¿½kï¿½ï¿½:ßˆï¿½-/ï¿½ï¿½Nï¿½Ç %+gï¿½uN2RTï¿½ï¿½ï¿½Tï¿½nï¿½ï¿½ï¿½8ç½›ï¿½#/ï¿½ï¿½ï¿½ï¿½?6ï¿½3xï¿½ï¿½Jï¿½ï¿½qï¿½0ï¿½jVï¿½F^Å½Ð—ï¿½M5ï¿½*lEï¿½ï¿½ï¿½ÚŽï¿½ï¿½Q
ï¿½ï¿½wï¿½Vï¿½ï¿½Î«ï¿½
kï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½ï¿½<Xï¿½Dï¿½[0É’6ï¿½G^3Ï©ï¿½ß¨ï¿½ï¿½^?Iï¿½^ï¿½ï¿½ï¿½qï¿½ï¿½B\Nï¿½ï¿½+ï¿½
ï¿½gï¿½ï¿½#ï¿½j9xï¿½ï¿½ï¿½y?7`ï¿½ï¿½bï¿½ï¿½
T[[PRï¿½<hï¿½ï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½ï¿½uï¿½Mkï¿½ï¿½ï¿½ï¿½9Pï¿½ï¿½	ï¿½ï¿½ï¿½ï¿½q|ï¿½ï¿½}gï¿½6zyyiï¿½ï¿½ï¿½ï¿½ï¿½sR!]@Xï¿½R:;;ï¿½nWYi)ï¿½ï¿½ï¿½ï¿½n
%ï¿½O8-ï¿½ï¿½xï¿½m_Î¼QÄ™ï¿½Hï¿½ï¿½ï¿½ï¿½apRï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wÅŠï¿½ï¿½ï¿½Ï¿iï¿½ï¿½9ï¿½ï¿½|Aï¿½Fq\,ï¿½ï¿½ï¿½ERWWï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ð‹ï¿½ï¿½ï¿½
ï¿½TR\ï¿½ï¿½ï¿½ï¿½i'L<ï¿½ï¿½ï¿½Û©ï¿½~8Kï¿½JPdï¿½ï¿½Gï¿½wï¿½ï¿½?ï¿½O/ï¿½ï¿½ï¿½ï¿½3ï¿½RÍ·wï¿½sï¿½%ï¿½"ï¿½ï¿½ï¿½b`ï¿½ï¿½y#9ÂŸï¿½9ï¿½Ã‘2tï¿½ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½Wï¿½Ïš5Kï¿½vÂ„ï¿½ï¿½ï¿½ï¿½3ï¿½ï¿½q\3ï¿½ï¿½ï¿½ï¿½Gï¿½+^ï¿½ï¿½á¼™Î¿ï¿½ï¿½ï¿½?ï¿½ï¿½Ãï¿½ï¿½Tqï¿½p<ï¿½xï¿½ï¿½aï¿½Ó9Bï¿½ï¿½ï¿½ï¿½(ï¿½fï¿½xï¿½ï¿½ï¿½ï¿½#ï¿½Dï¿½Vï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½ï¿½"/;ï¿½D\xnï¿½ï¿½_ï¿½ï¿½ï¿½2ÇŽNï¿½uÂ¹8ï¿½|ï¿½F}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½DNï¿½iVï¿½\ï¿½>-ï¿½ï¿½ï¿½{]ï¿½Ê§ï¿½ï¿½pï¿½=ï¿½3je9ï¿½ï¿½Oï¿½Qï¿½ï¿½ï¿½ï¿½>ï¿½Yï¿½ï¿½ï¿½qï¿½ï¿½qï¿½1ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½7ï¿½Gï¿½ï¿½ï¿½nï¿½yï¿½]wGÍˆAï¿½Ãœï¿½qï¿½Wï¿½Ë¼oï¿½mï¿½ï¿½ï¿½ï¿½C~ï¿½ï¿½wï¿½SÏ¿8ï¿½o;ï¿½Jwï¿½qU9KYq<OEWï¿½ï¿½PÕŠï¿½ï¿½Z@ï¿½;ï¿½ï¿½Oï¿½ï¿½gï¿½gï¿½ï¿½?ï¿½#ï¿½\ï¿½ï¿½ï¿½O{ï¿½Î™ï¿½nï¿½ï¿½ï¿½(Wzï¿½ï¿½OJ7ï¿½Fï¿½Cï¿½pï¿½RÞ¢ï¿½ve/oSb{ï¿½ï¿½{#2pD\\ï¿½`gï¿½ï¿½ï¿½Wï¿½Cï¿½qÍ¾4ï¿½21ï¿½ï¿½LÂ‘ï¿½-ï¿½Gï¿½JkuFuï¿½
~!ï¿½j;ï¿½ï¿½ ï¿½-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'ï¿½7ï¿½ï¿½6YNï¿½ï¿½
Mï¿½ï¿½ï¿½ï¿½vï¿½ceï¿½ï¿½4+(^hKHEï¿½ï¿½ï¿½Ç€Z Nï¿½ï¿½ï¿½ï¿½fï¿½hï¿½?D^Lï¿½wï¿½ï¿½tï¿½ï¿½ï¿½ï¿½<ï¿½`ï¿½dï¿½ï¿½ï¿½$#3ï¿½iiVï¿½i[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½N
ï¿½Q=ï¿½s\ï¿½=Öˆï¿½ï¿½;8(ï¿½F\ãœˆï¿½ï¿½ï¿½P#ï¿½ï¿½^ï¿½HWï¿½Ô•ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½gu:ï¿½Gï¿½:ï¿½ï¿½=Vï¿½lï¿½;Sï¿½<ï¿½ï¿½ï¿½mVï¿½ Wï¿½kï¿½8`ï¿½rï¿½S-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½qï¿½GÜ“ï¿½"ï¿½ï¿½+IO9ï¿½ï¿½jï¿½Md;ß™ï¿½;ï¿½ï¿½ï¿½ï¿½QqRï¿½rï¿½ï¿½ÚŠï¿½"-w\ï¿½ECï¿½ï¿½6ï¿½xï¿½ï¿½r\ï¿½lï¿½ï¿½IqIï¿½%(>dg,R\,tï¿½ï¿½ï¿½yTFwï¿½ï¿½ï¿½ <ï¿½ï¿½!mï¿½8ï¿½ï¿½\ï¿½?ï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½69á¬¤ï¿½ur['ï¿½ï¿½Hï¿½,ï¿½ï¿½7ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½qï¿½ï¿½ï¿½?Iï¿½ï¿½s\ï¿½,.r5ï¿½ï¿½ï¿½k0:ï¿½Eeï¿½Z ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ç¸ºï¿½ï¿½F\'vï¿½ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½=ï¿½ï¿½;o'ï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½&ï¿½ï¿½gï¿½ï¿½ï¿½}s\^'ï¿½Zï¿½yaJï¿½Quæ ´ï¿½<ï¿½eï¿½ï¿½ï¿½-ï¿½g;ß™ï¿½{r\dï¿½ï¿½Eq/T.o=:EQï¿½ï¿½9ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½:2MQï¿½jF3ahÌ›ï¿½ï¿½1ï¿½ï¿½;ï¿½*8Î NaC5ï¿½cï¿½+ï¿½GGï¿½ÒƒBï¿½Bï¿½vï¿½pï¿½ï¿½mï¿½ï¿½ï¿½}bï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½cSuï¿½@×¥* ru:oï¿½ï¿½ï¿½;g~Lï¿½Sï¿½ï¿½ï¿½ï¿½Z7ï¿½ï¿½ï¿½qï¿½ï¿½Cï¿½ï¿½?ï¿½ ï¿½
ï¿½Å¸ï¿½ï¿½ï¿½8ï¿½ ï¿½ï¿½ï¿½ï¿½×Ÿï¿½ï¿½>ï¿½zï¿½ï¿½MCB_qÔï¿½+ï¿½ï¿½$ï¿½ï¿½4ï¿½5ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½Qï¿½ï¿½H<ï¿½ï¿½Kï¿½T&iï¿½ï¿½ï¿½:ï¿½B
ï¿½ï¿½;CV3ï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½w>\ï¿½<==Ö€;uï¿½xï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½;ï¿½QGWï¿½wï¿½ZÚºiË®6ï¿½ï¿½ï¿½~ï¿½jHvï¿½kï¿½ï¿½fï¿½ï¿½wï¿½^ï¿½ï¿½7-xï¿½Qgwuï¿½ï¿½ï¿½|<ï¿½ï¿½/ï¿½ï¿½<ï¿½ï¿½GÚï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½stï¿½Sï¿½Oï¿½qï¿½ï¿½x4ï¿½ï¿½ï¿½ï¿½ï¿½Ï¡1ï¿½É.ï¿½ï¿½Thï¿½ï¿½ï¿½ï¿½Apå‡¾ï¿½ï¿½ï¿½ï¿½ï¿½VÓºï¿½ï¿½,ï¿½e~ï¿½Eï¿½ï¿½-9ï¿½Úï¿½ï¿½?{ï¿½ï¿½_ï¿½ï¿½ï¿½'ï¿½V&ï¿½W.ï¿½(8>^Yï¿½L?|x
:ï¿½C#ï¿½Wï¿½ï¿½[Ï£)'ï¿½S[g}ï¿½gï¿½Ñ³ï¿½ï¿½ÞŠï¿½ï¿½ï¿½ï¿½x}ð²©´|ï¿½ï¿½ï¿½ï¿½^ï¿½ï¿½tï¿½ï¿½ï¿½|ï¿½ï¿½ï¿½#W6ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½ï¿½^ï¿½0ï¿½ï¿½e!ï¿½zRï¿½ï¿½vï¿½nï¿½ï¿½
Úºï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Dï¿½fï¿½+ï¿½1ï¿½ï¿½/_ï¿½6HÞ’ï¿½ï¿½{ï¿½
ï¿½w"ï¿½ï¿½ï¿½&ÆšOï¿½
q3ï¿½ï¿½vfWï¿½
&	]ze
ï¿½ï¿½ï¿½Ñ‹ï¿½ï¿½xï¿½{ï¿½ï¿½ï¿½}pï¿½ï¿½ï¿½ï¿½.ï¿½?ï¿½>{ï¿½ï¿½3}$;qï¿½^ï¿½ï¿½ï¿½ï¿½â´¥%ï¿½ï¿½`ï¿½Cï¿½ï¿½ï¿½ï¿½kï¿½yï¿½aw4~i;Õ³ï¿½ï¿½[ï¿½ï¿½ï¿½?ï¿½#zï¿½ï¿½ï¿½ï¿½gï¿½Eï¿½`ï¿½ï¿½dï¿½ï¿½?ï¿½@^{ï¿½Yï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½+ï¿½k1Eï¿½ï¿½`'=ï¿½ï¿½&^ï¿½Eï¿½ï¿½ï¿½,N;wï¿½hï¿½ï¿½ï¿½ï¿½ï¿½VÓ½ï¿½YK+ï¿½5}0ì§±ï¿½5ï¿½d1ï¿½ï¿½$:ï¿½ï¿½Wï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½-ï¿½+WQï¿½Oï¿½ÅŠï¿½`ï¿½ï¿½}ï¿½)|Í¦ï¿½8ï¿½ï¿½ï¿½ï¿½h2ï¿½=sUUï¿½Ñ¿ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½5ï¿½ï¿½0GÖ²2^Qï¿½jï¿½\0ï¿½>ï¿½x=ï¿½ï¿½Vï¿½ï¿½ï¿½_ï¿½g^ï¿½Eï¿½ï¿½ï¿½lï¿½ï¿½KÛ¤ï¿½ï¿½ï¿½
ÇŸï¿½Qsï¿½ï¿½fzbï¿½6ï¿½ï¿½qBï¿½ï¿½?xï¿½ï¿½T_SFï¿½-ï¿½ï¿½8ï¿½'ï¿½Wï¿½ï¿½lï¿½ï¿½ß¶qï¿½~ï¿½ï¿½zuï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½zsï¿½Aï¿½ï¿½oï¿½<ï¿½ï¿½Ó—Ã´zï¿½ï¿½=ï¿½qPì‡ˆï¿½y	2ï¿½0cï¿½ï¿½ï¿½rï¿½ï¿½pï¿½k(ï¿½JWï¿½eï¿½Gï¿½Ö‰ï¿½ï¿½ï¿½ï¿½ï¿½DUfvSï¿½dß ~/ï¿½:ï¿½zï¿½Ëžï¿½ï¿½fï¿½wï¿½_I;ï¿½!D0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4v>Dï¿½ï¿½ï¿½ï¿½NKï¿½ï¿½ï¿½]ï¿½Ìœ2\ï¿½oï¿½d^È‡ï¿½vï¿½ï¿½.7ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Î†ï¿½ï¿½4ï¿½Fï¿½ï¿½ï¿½ï¿½`ï¿½Oï¿½ï¿½ï¿½uï¿½4}Bï¿½È›zï¿½yï¿½*roï¿½ï¿½?ï¿½[IXï¿½Uï¿½ï¿½|ï¿½iï¿½1äºƒe?ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Uï¿½;^jï¿½å®Bï¿½ï¿½K8+Ñ¶ï¿½ï¿½zMï¿½sï¿½6ï¿½ï¿½ï¿½_&9ï¿½mï¿½ï¿½ï¿½'6ï¿½)yï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½ï¿½Zï¿½a?]:b<=ï¿½ï¿½nj=ï¿½-N=ï¿½xï¿½o_H5ï¿½ï¿½Wï¿½9ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|Ñ‡2ï¿½|ï¿½ï¿½&
ï¿½oAtï¿½ï¿½ï¿½ï¿½ï¿½ï¿½N|ï¿½Dï¿½ï¸„&ï¿½ï¿½ï¿½/ï¿½ï¿½èƒ‹ï¿½ï¿½ï¿½ï¿½ï¿½3ï¿½ï¿½_ï¿½ï¿½ï¿½0ï¿½[ï¿½ï¿½Lï¿½ï¿½ï¿½\pcitï¿½ï¿½ï¿½ ï¿½ï¿½F>1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½g>ï¿½rï¿½3gï¿½tï¿½,ï¿½rï¿½Â‰ï¿½è³›ï¿½?yï¿½~ï¿½ï¿½zï¿½Ä»ï¿½=ï¿½ï¿½ÞŠn6ï¿½ï¿½l ï¿½ï¿½ï¿½ï¿½ÎŸDï¿½<ï¿½ï¿½ï¿½ï¿½ï¿½iGï¿½ï¿½ï¿½ï¿½/ï¿½ï¿½Ç¯>ï¿½f8ï¿½"ï¿½ï¿½L&ï¿½8ï¿½]{ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½w$~aï¿½^ï¿½ï¿½=ï¿½(ï¿½ï¿½ï¿½ï¿½b/U"6?ï¿½Qï¿½ï¿½!ï¿½ÅºPï¿½7+.Wï¿½ï¿½Ø±ï¿½"
'ï¿½ï¿½p0 ï¿½Wo:ï¿½ï¿½}ï¿½kreï¿½ï¿½{ï¿½sgï¿½ï¿½]ï¿½@ï¿½:ï¿½{ï¿½//ï¿½ï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½ï¿½W3ï¿½ï¿½"3ï¿½ï¿½4Swï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/+vï¿½ï¿½ï¿½ï¿½Mï¿½ï¿½ï¿½4zeï¿½q:ï¿½ï¿½h)ï¿½M.ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½8ï¿½ï¿½Bï¿½Fï¿½ï¿½ï¿½?ï¿½dï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½l?ï¿½iï¿½ï¿½
ï¿½ï¿½ï¿½Fï¿½ï¿½+nï¿½.?uzï¿½Pï¿½ï¿½ZÉ¹ï¿½_ï¿½ï¿½a:cï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½G:ï¿½ÒCï¿½PWEï¿½Uï¿½ï¿½Kï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½}4zDï¿½DHIJ-z*ï¿½~ï¿½ï¿½ï¿½ï¿½Ó¨ï¿½Õœ&ï¿½Bï¿½ï¿½ï¿½rï¿½ï¿½Fï¿½ï¿½ï¿½Y9ï¿½ï¿½\ï¿½ï¿½
\ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½Aï¿½$ï¿½ï¿½Jï¿½ï¿½}ï¿½;[ï¿½ï¿½ï¿½ï¿½CMmï¿½cï¿½qDï¿½ï¿½ÙŠï¿½bï¿½-ï¿½Ç«*ï¿½y'ï¿½Fï¿½ï¿½ï¿½{ï¿½ï¿½Fï¿½ï¿½Mtï¿½F?ï¿½ï¿½eLCï¿½ï¿½0ï¿½ï¿½ï¿½%ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½Hï¿½ï¿½~ï¿½Y&ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½r\6]vï¿½]ï¿½Zï¿½ï¿½XIJï¿½ï¿½$0çˆ£wï¿½VsQ1ï¿½cs ï¿½ï¿½=ï¿½Vï¿½ï¿½Xï¿½ï¿½ï¿½r\ï¿½$r(ï¿½ï¿½[iï¿½t6Xcï¿½Bï¿½ï¿½ï¿½Wï¿½
ï¿½ï¿½WKXï¿½ï¿½8ï¿½ï¿½ï¿½'ï¿½ï¿½lLï¿½ï¿½
ï¿½ï¿½'Â†ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½x"'Kxï¿½ï¿½PMRHï¿½ï¿½ï¿½Mï¿½ï¿½=ï¿½ï¿½GO5#Iï¿½o .ï¿½ï¿½ï¿½/l{ï¿½ï¿½
1y	9ï¿½BYï¿½Åµ]}Kï¿½ï¿½ï¿½Â±q0ï¿½ï¿½Q
ï¿½>q'Jgï¿½ï¿½ï¿½ï¿½qCï¿½Pï¿½0ï¿½Øˆï¿½ï¿½2ï¿½~ï¿½ï¿½Zï¿½Ü¨ï¿½ï¿½F6ï¿½xï¿½â¹©ï¿½ï¿½ï¿½ï¿½Yï¿½pï¿½ï¿½ï¿½ï¿½jï¿½^ï¿½ZÅœï¿½lhn+y/ï¿½'(ï¿½ï¿½ï¿½ï¿½,qï¿½1ï¿½ÛŸï¿½n,Yï¿½ï¿½pï¿½|ï¿½ï¿½iO:ï¿½ï¿½ï¿½×žï¿½ï¿½ï¿½Bï¿½ï¿½H?ï¿½ï¿½".`ï¿½Sï¿½ï¿½Cï¿½+	ï¿½,ï¿½ï¿½+ï¿½ï¿½>ï¿½dï¿½ï¿½Hï¿½k
9fxBï¿½ï¿½Oï¿½7ï¿½>.k):ï¿½ÞŸï¿½ï¿½f*.(ï¿½ï¿½Y-ï¿½ï¿½ï¿½;ï¿½ï¿½Cï¿½ï¿½{ï¿½ï¿½ï¿½VB"Nbï¿½uï¿½ï¿½!]ï¿½ï¿½`ï¿½Ã….,
ï¿½jï¿½Gp(Ùï¿½
3hï¿½Qï¿½3<ï¿½qï¿½ï¿½ï¿½Y*ï¿½ï¿½aï¿½Iï¿½ï¿½-sï¿½ï¿½qï¿½3ï¿½ï¿½aï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½Cï¿½EWï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½/vï¿½ï¿½ï¿½ï¿½N`QrÂ€Pï¿½ï¿½ï¿½ï¿½ï¿½820ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½l{
ï¿½}xï¿½dï¿½Bï¿½ï¿½e|@ï¿½yr\ï¿½spFï¿½rï¿½ï¿½toÄï¿½<ï¿½ï¿½
ï¿½ï¿½jaï¿½/ï¿½Ð—nx`Dw&ï¿½crï¿½ï¿½ï¿½ï¿½Eï¿½U6ï¿½ï¿½ï¿½ï¿½ï¿½r\ï¿½4gï¿½ ï¿½Eï¿½ï¿½Å…b>ï¿½Nqï¿½ËŠï¿½cï¿½"ï¿½ï¿½Rï¿½qï¿½ï¿½uï¿½ï¿½ï¿½3ï¿½ï¿½\ï¿½_ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½Nï¿½9ï¿½nÄ…sï¿½%Muaï¿½ï¿½rLï¿½ï¿½ï¿½"Ý‡7ï¿½aï¿½mï¿½ï¿½*Bï¿½ï¿½ï¿½$ë²¢ï¿½
Y
ï¿½4ï¿½Wï¿½vï¿½ï¿½Aï¿½<ï¿½2Oï¿½ï¿½ebÂ»ï¿½ï¿½9ï¿½Ü[ï¿½{Pï¿½ï¿½dWï¿½ï¿½ Uï¿½ï¿½ï¿½Mï¿½Iï¿½/ï¿½ï¿½>Tï¿½gf$6>ï¿½]ï¿½ï¿½Oï¿½Þ“ï¿½cï¿½ï¿½ï¿½ï¿½sï¿½pï¿½ï¿½sï¿½hï¿½nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6ï¿½Ñ¾ï¿½ï¿½ï¿½ï¿½ï¿½y5Rï¿½dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½oï¿½)ï¿½ï¿½r*-ï¿½ï¿½ï¿½ï¿½Rï¿½ï¿½ï¿½1^q2ï¿½'ï¿½ï¿½ï¿½[h~`ï¿½fï¿½Qï¿½9.\ï¿½%ï¿½ï¿½0ï¿½ï¿½2Ç¡ï¿½ï¿½Ø¡ 1ï¿½^vï¿½ï¿½#ï¿½ï¿½ï¿½Fï¿½ï¿½TRZBï¿½ï¿½m`*ï¿½W*ï¿½,Ç¨ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½N\Fï¿½U5ï¿½Wï¿½ï¿½[ï¿½Caï¿½ï¿½ï¿½gï¿½~ï¿½ï¿½ï¿½ï¿½sï¿½|ï¿½45ï¿½ï¿½ï¿½BÃï¿½çºº:ï¿½Pï¿½~~cï¿½ï¿½ï¿½Ruu
ï¿½ï¿½ï¿½qDMWï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½!ï¿½_:ï¿½ï¿½J=ï¿½T];ï¿½eï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½Þ™ï¿½XNï¿½
ï¿½ï¿½qï¿½ï¿½].ï¿½9[ï¿½ï¿½ï¿½ï¿½Î¸ï¿½ï¿½hï¿½ï¿½ï¿½pï¿½ï¿½QLï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½i[ì¥ºï¿½j1ï¿½ï¿½ï¿½ï¿½ï¿½Vï¿½ï¿½&ï¿½ï¿½rï¿½ï¿½ï¿½ï¿½nï¿½ï¿½Ê¨ï¿½ï¿½ ï¿½Û³ï¿½Fï¿½Oeâ¼…1ï¿½Ø¨ï¿½ï¿½yCï¿½
0ï¿½ï¿½#Yï¿½ï¿½ï¿½9ï¿½ï¿½0	fï¿½ÅŽï¿½ï¿½ï¿½8ï¿½Mcï¿½Zh8Vfoo'ï¿½4ï¿½ï¿½ï¿½ï¿½ï¿½Ð¨Qchï¿½ï¿½1ï¿½ï¿½ï¿½Cï¿½[[WÇ²FÓ°ï¿½rÚ·{;Gaï¿½Fï¿½Bï¿½ï¿½>p:Prï¿½ï¿½Tï¿½Ýˆï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½\qï¿½(;Äªï¿½ï¿½ï¿½2ï¿½ï¿½ï¿½&ï¿½PHï¿½Qvï¿½ï¿½{wSÍ°a4rï¿½(ï¿½ï¿½ï¿½ï¿½yn<ï¿½4ï¿½ï¿½ï¿½Fï¿½ï¿½]ï¿½wQgGï¿½
ï¿½nï¿½Iï¿½'4?Hï¿½_\ï¿½+ï¿½lï¿½Eï¿½3ï¿½ï¿½ï¿½ï¿½JIï¿½,ï¿½ï¿½Ý¬hï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½*xï¿½Aï¿½ï¿½ï¿½Cï¿½|ï¿½-ï¿½Ó»;ï¿½ï¿½loo/ß²ï¿½WHï¿½ï¿½xî¢˜**Lï¿½
zG{;ï¿½3ï¿½u.'ï¿½ï¿½ï¿½DcC#mß¹ï¿½yï¿½=cï¿½?ï¿½9ï¿½ï¿½'ï¿½3Oï¿½Ì¹ï¿½	ï¿½ï¿½ï¿½ï¿½bHï¿½Hï¿½+ï¿½ï¿½Î¥ï¿½ï¿½ï¿½ZKï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½KK=5ï¿½ï¿½ï¿½8PQï¿½} ï¿½ï¿½|Aï¿½sï¿½Vj^Gï¿½ï¿½ï¿½dÐŽzï¿½ï¿½ï¿½ï¿½ï¿½c;^ï¿½+xfï¿½ï¿½1ï¿½ï¿½/ï¿½ï¿½ï¿½~ï¿½6lï¿½@---TSSM3fï¿½Fgï¿½9ï¿½,Nï¿½	ï¿½ï¿½ï¿½jï¿½dï¿½ï¿½ï¿½nï¿½ï¿½a^ï¿½WEï¿½=ï¿½ ï¿½0ï¿½ï¿½1~ï¿½uï¿½ï¿½ï¿½3ï¿½ï¿½=ï¿½ï¿½<B7ï¿½ï¿½ ï¿½ï¿½+ï¿½ï¿½kÄ•ï¿½ï¿½sï¿½ï¿½eRzï¿½ï¿½}rï¿½ï¿½ï¿½ï¿½Dï¿½Eï¿½Aï¿½5ï¿½
ï¿½KGï¿½ï¿½ï¿½ï¿½ï¿½Bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½[iï¿½[oï¿½ï¿½ï¿½ï¿½fjhlï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Aï¿½gÍ¢ï¿½~ï¿½ï¿½nyï¿½N7ï¿½Ö¬yï¿½Ö¯[Oï¿½9ï¿½=ï¿½ï¿½mQï¿½Kï¿½ï¿½sï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½gï¿½lg~Ç—ï¿½ï¿½ï¿½ï¿½nï¿½ï¿½sï¿½8ï¿½pï¿½Mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½iBï¿½<(ï¿½ï¿½ï¿½Ó¤ï¿½ï¿½ï¿½)x]oï¿½_ï¿½v
Íš}6ï¿½>9ï¿½ï¿½\ï¿½:ï¿½9wï¿½\ï¿½ï¿½ ï¿½<ï¿½_ï¿½ï¿½ï¿½ï¿½kï¿½ï¿½Í¸YS-ï¿½ï¿½ï¿½]@3gÎ¤uï¿½ï¿½Ñ“O>Isï¿½Î¥3ï¿½<ï¿½wï¿½ï¿½ï¿½ï¿½ï¿½6mzï¿½ï¿½Oï¿½Nsï¿½=ï¿½ï¿½vpï¿½-ï¿½ ï¿½pï¿½Û¾cï¿½7ï¿½ï¿½Gaï¿½Pï¿½,Ø˜ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½:ï¿½ï¿½?ï¿½å¸†ï¿½p_ï¿½x1<#:4ï¿½ï¿½ï¿½8 W|ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½ï¿½pG9ï¿½C:S0ï¿½tï¿½ï¿½8ï¿½ï¿½ï¿½\ï¿½J<ï¿½ï¿½ï¿½ï¿½ï¿½)Sï¿½ï¿½)ï¿½ï¿½ï¿½3~Ø¤ï¿½&Nï¿½ ï¿½ï¿½IÝ½{7Mcï¿½mimï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½ï¿½!ï¿½~ï¿½ï¿½ï¿½Â˜ï¿½+uÈƒ0~ï¿½ï¿½ï¿½?ï¿½ï¿½rï¿½ aï¿½bï¿½ï¿½0)oï¿½ï¿½ï¿½Wï¿½ï¿½(ï¿½8f8|ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½kjiÜ¸SXï¿½ï¿½^ï¿½Sï¿½[ï¿½|ï¿½ï¿½Ã¹0Qï¿½Zï¿½ï¿½xXï¿½ï¿½ÍŸTï¿½W]wï¿½uï¿½6ï¿½{Ø‰ï¿½*ï¿½ï¿½ï¿½krï¿½bÞ¼y>ï¿½ï¿½}ï¿½ï¿½ï¿½[ï¿½ï¿½ß‰sï¿½!ï¿½-qï¿½ ï¿½wï¿½ï¿½ï¿½sï¿½8mÜ¸Aï¿½2ï¿½ï¿½aï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½>.[ï¿½Wï¿½>ï¿½ï¿½_ï¿½ï¿½zï¿½Ù§8:ï¿½ï¿½Lï¿½ï¿½[ï¿½ï¿½Â€x0;ï¿½ï¿½ï¿½ NGNï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½.ï¿½6oï¿½$<ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½GÛ·mKï¿½ï¿½ï¿½ï¿½nï¿½{9oï¿½ï¿½ï¿½ï¿½ï¿½gÏ®ï¿½ï¿½sOÑ²ï¿½~ï¿½h|ï¿½ï¿½ï¿½ï¿½quqï¿½Eï¿½pï¿½	ï¿½ï¿½ï¿½6Nï¿½i6ï¿½,ï¿½&rï¿½w~ï¿½[ï¿½ï¿½_vÅ•|:E5ï¿½uï¿½ï¿½ï¿½bWEUu !ï¿½uhã¼´ï¿½ï¿½ï¿½/ï¿½pÑ”Xï¿½#;ï¿½&ï¿½cï¿½ï¿½ï¿½Ò†ï¿½%ÚŽ;ï¿½ï¿½Sè¥‰ï¿½&ï¿½Ô©SyPbIWï¿½Ñ¾>vï¿½4~Â©ï¿½9ï¿½aï¿½(ï¿½@C<Hï¿½ï¿½#mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½P(ï¿½|gÒ¾hï¿½ï¿½
ï¿½ï¿½qï¿½ï¿½
/ï¿½Þ±ï¿½Æ‡>ï¿½ï¿½2ï¿½o@ï¿½8Ü¯ï¿½ï¿½755ï¿½E]Dï¿½ï¿½~:ï¿½ï¿½ï¿½$<M5ï¿½[?ï¿½ï¿½Lï¿½yï¿½`ï¿½xNg|JG×;wÒªï¿½+Yï¿½Ytê©“ï¿½ï¿½z+vÖ®ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½qq1ï¿½ï¿½ï¿½ï¿½áˆŽï¿½oQ1~ï¿½ï¿½Xï¿½|ï¿½ï¿½*lyï¿½Ý»ï¿½ï¿½|ï¿½Mzï¿½ï¿½ï¿½4ï¿½ï¿½Aï¿½ï¿½ï¿½EMï¿½ï¿½%!
ï¿½
ï¿½ï¿½Îï¿½ï¿½ï¿½R^ï¿½`ï¿½Lï¿½r*}ï¿½ï¿½_ï¿½S}Õ°ï¿½ï¿½ï¿½CDï¿½ï¿½ZRR*ï¿½^HZ[[y[m
}ï¿½/ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½beï¿½ï¿½ï¿½ê®ï¿½hï¿½ï¿½-tï¿½y?ï¿½:ï¿½ï¿½ï¿½vÂŽï¿½9ï¿½ï¿½	ï¿½Yï¿½ï¿½xZl×®ï¿½ï¿½ï¿½ï¿½ï¿½Ã¼ï¿½rï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½a:ï¿½ï¿½ï¿½:ï¿½ï¿½ï¿½ï¿½~z/ç¸·Hï¿½ll)[_ï¿½a>ï¿½]]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½uoï¿½ï¿½Õ«N(ï¿½ï¿½tï¿½ï¿½dÔ¨ï¿½ï¿½Å»ï¿½ï¿½>^ï¿½?ï¿½ï¿½=Kï¿½yï¿½ï¿½ï¿½ï¿½`|'lë–­tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½JXï¿½]ï¿½ï¿½ï¿½Dï¿½ï¿½
ï¿½={vï¿½ï¿½Uï¿½ï¿½'ï¿½ï¿½_ ï¿½ï¿½vï¿½ï¿½OJoï¿½Úª)ï¿½ï¿½ï¿½&ï¿½|ï¿½ï¿½ï¿½<ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½Lï¿½|ï¿½#ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½{qAï¿½ï¿½ï¿½fï¿½ï¿½"8pï¿½ï¿½ï¿½Ù´ï¿½}ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½_ï¿½L'ï¿½Dï¿½ï¿½ï¿½U`ï¿½ï¿½*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Sgì‰¨dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Oragï¿½ï¿½/ï¿½'ï¿½e;ï¿½ï¿½ë¼¯ï¿½W.ï¿½ï¿½ï¿½oï¿½mÛ¶ï¿½3|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ôž8Ç©ï¿½\K3>wW!,ï¿½)ï¿½Gï¿½Iï¿½Ã¿sï¿½ï¿½ï¿½JHï¿½1ï¿½ï¿½ï¿½!ï¿½ï¿½ï¿½'ï¿½rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½;sHRï¿½D+ï¿½ï¿½ï¿½c:ï¿½ï¿½&ï¿½Ê ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½ï¿½ï¿½Îï¿½EÅ˜Ôœï¿½2ï¿½ï¿½yï¿½+Sï¿½ï¿½ï¿½ï¿½Upï¿½ï¿½ï¿½*ï¿½9ï¿½Ç½ï¿½rNÌ£ï¿½nczï¿½A\ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½>.Åï¿½ï¿½
ï¿½[ï¿½fï¿½bsï¿½f.ï¿½ï¿½ï¿½#'{ï¿½ï¿½ï¿½ï¿½0ï¿½Gd'ï¿½ï¿½ï¿½ï¿½ï¿½AbDqï¿½tï¿½=ï¿½ï¿½qqï¿½ ï¿½  Aï¿½ï¿½ï¿½h6ï¿½0ï¿½ï¿½:ï¿½uï¿½8eï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½Fv`ï¿½ï¿½nÄ…ï¿½aHï¿½ï¿½8\ê³£ï¿½ï¿½'l

ï¿½ï¿½ï¿½ï¿½ï¿½E\ï¿½Fxdï¿½ï¿½yï¿½ï¿½ï¿½ï¿½ï¿½ï¿½A3h0    IENDï¿½B`ï¿½
--- END OF FILE 2025-03-26/server/resource-picker.png ---


--- START OF FILE 2025-03-26/server/resources.mdx ---
---
title: Resources
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to expose
resources to clients. Resources allow servers to share data that provides context to
language models, such as files, database schemas, or application-specific information.
Each resource is uniquely identified by a
[URI](https://datatracker.ietf.org/doc/html/rfc3986).

## User Interaction Model

Resources in MCP are designed to be **application-driven**, with host applications
determining how to incorporate context based on their needs.

For example, applications could:

- Expose resources through UI elements for explicit selection, in a tree or list view
- Allow the user to search through and filter available resources
- Implement automatic context inclusion, based on heuristics or the AI model's selection

![Example of resource context picker](/specification/2025-03-26/server/resource-picker.png)

However, implementations are free to expose resources through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Capabilities

Servers that support resources **MUST** declare the `resources` capability:

```json
{
  "capabilities": {
    "resources": {
      "subscribe": true,
      "listChanged": true
    }
  }
}
```

The capability supports two optional features:

- `subscribe`: whether the client can subscribe to be notified of changes to individual
  resources.
- `listChanged`: whether the server will emit notifications when the list of available
  resources changes.

Both `subscribe` and `listChanged` are optional&mdash;servers can support neither,
either, or both:

```json
{
  "capabilities": {
    "resources": {} // Neither feature supported
  }
}
```

```json
{
  "capabilities": {
    "resources": {
      "subscribe": true // Only subscriptions supported
    }
  }
}
```

```json
{
  "capabilities": {
    "resources": {
      "listChanged": true // Only list change notifications supported
    }
  }
}
```

## Protocol Messages

### Listing Resources

To discover available resources, clients send a `resources/list` request. This operation
supports [pagination](/specification/2025-03-26/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "resources/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "file:///project/src/main.rs",
        "name": "main.rs",
        "description": "Primary application entry point",
        "mimeType": "text/x-rust"
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Reading Resources

To retrieve resource contents, clients send a `resources/read` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "resources/read",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "contents": [
      {
        "uri": "file:///project/src/main.rs",
        "mimeType": "text/x-rust",
        "text": "fn main() {\n    println!(\"Hello world!\");\n}"
      }
    ]
  }
}
```

### Resource Templates

Resource templates allow servers to expose parameterized resources using
[URI templates](https://datatracker.ietf.org/doc/html/rfc6570). Arguments may be
auto-completed through [the completion API](/specification/2025-03-26/server/utilities/completion).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "resources/templates/list"
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "resourceTemplates": [
      {
        "uriTemplate": "file:///{path}",
        "name": "Project Files",
        "description": "Access files in the project directory",
        "mimeType": "application/octet-stream"
      }
    ]
  }
}
```

### List Changed Notification

When the list of available resources changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/list_changed"
}
```

### Subscriptions

The protocol supports optional subscriptions to resource changes. Clients can subscribe
to specific resources and receive notifications when they change:

**Subscribe Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "resources/subscribe",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

**Update Notification:**

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Resource Discovery
    Client->>Server: resources/list
    Server-->>Client: List of resources

    Note over Client,Server: Resource Access
    Client->>Server: resources/read
    Server-->>Client: Resource contents

    Note over Client,Server: Subscriptions
    Client->>Server: resources/subscribe
    Server-->>Client: Subscription confirmed

    Note over Client,Server: Updates
    Server--)Client: notifications/resources/updated
    Client->>Server: resources/read
    Server-->>Client: Updated contents
```

## Data Types

### Resource

A resource definition includes:

- `uri`: Unique identifier for the resource
- `name`: Human-readable name
- `description`: Optional description
- `mimeType`: Optional MIME type
- `size`: Optional size in bytes

### Resource Contents

Resources can contain either text or binary data:

#### Text Content

```json
{
  "uri": "file:///example.txt",
  "mimeType": "text/plain",
  "text": "Resource content"
}
```

#### Binary Content

```json
{
  "uri": "file:///example.png",
  "mimeType": "image/png",
  "blob": "base64-encoded-data"
}
```

## Common URI Schemes

The protocol defines several standard URI schemes. This list not
exhaustive&mdash;implementations are always free to use additional, custom URI schemes.

### https://

Used to represent a resource available on the web.

Servers **SHOULD** use this scheme only when the client is able to fetch and load the
resource directly from the web on its ownâ€”that is, it doesnâ€™t need to read the resource
via the MCP server.

For other use cases, servers **SHOULD** prefer to use another URI scheme, or define a
custom one, even if the server will itself be downloading resource contents over the
internet.

### file://

Used to identify resources that behave like a filesystem. However, the resources do not
need to map to an actual physical filesystem.

MCP servers **MAY** identify file:// resources with an
[XDG MIME type](https://specifications.freedesktop.org/shared-mime-info-spec/0.14/ar01s02.html#id-1.3.14),
like `inode/directory`, to represent non-regular files (such as directories) that donâ€™t
otherwise have a standard MIME type.

### git://

Git version control integration.

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Resource not found: `-32002`
- Internal errors: `-32603`

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "error": {
    "code": -32002,
    "message": "Resource not found",
    "data": {
      "uri": "file:///nonexistent.txt"
    }
  }
}
```

## Security Considerations

1. Servers **MUST** validate all resource URIs
2. Access controls **SHOULD** be implemented for sensitive resources
3. Binary data **MUST** be properly encoded
4. Resource permissions **SHOULD** be checked before operations

--- END OF FILE 2025-03-26/server/resources.mdx ---


--- START OF FILE 2025-03-26/server/slash-command.png ---
ï¿½PNG

   
IHDR  %   j   ï¿½Gz  ^iCCPICC Profile  (ï¿½uï¿½;HAï¿½ï¿½ï¿½h0ï¿½"ï¿½ï¿½ï¿½ï¿½b$ï¿½6"ï¿½"XQï¿½ï¿½es^ï¿½K\7'bï¿½ï¿½ï¿½66ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½+Eï¿½Oï¿½ï¿½
ï¿½ï¿½EMï¿½ï¿½ï¿½ï¿½ï¿½ï¿½33ï¿½ï¿½uï¿½-ï¿½Bï¿½ï¿½Ù¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!ï¿½ï¿½Og%ï¿½Ð´y*ï¿½ï¿½ï¿½ï¿½ï¿½#<Rï¿½Gï¿½ï¿½ï¿½ï¿½iï¿½ï¿½W^ï¿½ï¿½;#ï¿½ï¿½ï¿½-/ï¿½3Jï¿½ï¿½rï¿½qaï¿½XÛµï¿½ï¿½âˆ ï¿½ï¿½ï¿½%ï¿½uï¿½ï¿½ï¿½ï¿½sÙ­YÌ¤ï¿½ï¿½ï¿½,ï¿½ï¿½+ï¿½ï¿½lï¿½o6qï¿½ï¿½a_;ï¿½ï¿½Fqiï¿½ï¿½ï¿½ï¿½iï¿½($ï¿½ï¿½8Tï¿½ï¿½Oï¿½>ï¿½ï¿½Ka{Ø„ï¿½<lwï¿½ï¿½hï¿½ï¿½9ï¿½0ï¿½(qã”ªï¿½ï¿½ï¿½;6ï¿½ï¿½;`fï¿½`ï¿½ï¿½%9pï¿½tï¿½4ï¿½ï¿½# t
ÜŽq]ï¿½?ï¿½ï¿½T}ï¿½ï¿½xï¿½ï¿½Aï¿½ï¿½9ï¿½k/ï¿½jï¿½qï¿½Oï¿½vxï¿½ï¿½ï¿½ï¿½'ï¿½9ajï¿½Jï¿½   DeXIfMM *           ï¿½i       &     ï¿½      %ï¿½       j    oIï¿½ï¿½  iTXtXML:com.adobe.xmp     <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="XMP Core 6.0.0">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:tiff="http://ns.adobe.com/tiff/1.0/"
            xmlns:exif="http://ns.adobe.com/exif/1.0/">
         <tiff:Orientation>1</tiff:Orientation>
         <exif:PixelXDimension>293</exif:PixelXDimension>
         <exif:PixelYDimension>106</exif:PixelYDimension>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
l0ï¿½5  lIDATxï¿½]	xUEï¿½>Y YHï¿½ï¿½ï¿½ï¿½HXHï¿½DDdwï¿½Glhmï¿½luï¿½Fï¿½ï¿½ï¿½vz>ï¿½ï¿½vï¿½[g[wTï¿½%HXdï¿½%a'+	[ !ï¿½Adï¿½_ï¿½.ï¿½ï¿½ï¿½GÖ—Ü¼wï¿½ï¿½ï¿½Wuï¿½Ö­[ï¿½×½ï¿½=uNï¿½[^Wï¿½^ï¿½N"ï¿½ï¿½  Xoï¿½ï¿½Cï¿½!ï¿½ï¿½B@HI.A@ï¿½BJï¿½ï¿½ï¿½ï¿½  )ï¿½5 ï¿½B@Hï¿½Rï¿½!ï¿½!%ï¿½Aï¿½R)Yï¿½;ï¿½2ï¿½ï¿½  ï¿½$×€  X
!%Kuï¿½TFï¿½ï¿½ï¿½K! ï¿½dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ `)ï¿½ï¿½,ï¿½RA@ï¿½ï¿½ï¿½+ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½^iï¿½ ï¿½PMï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CE@Hï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CE@Hï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CEï¿½å¤´nï¿½zJKKï¿½1>ï¿½Îï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½p))ï¿½ï¿½ï¿½Ó›oï¿½C.ï¿½ï¿½ï¿½ï¿½ï¿½YNï¿½ï¿½Cï¿½,ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½(.nï¿½ï¿½\pï¿½Gvï¿½ï¿½ï¿½p))ï¿½Zï¿½ï¿½Zï¿½jEï¿½^#$ï¿½ï¿½5%/oo
nï¿½ï¿½i9ï¿½hï¿½ï¿½7ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½A@ï¿½>ï¿½ï¿½ï¿½bAA>ï¿½Ø±ï¿½ï¿½1ï¿½ï¿½ï¿½nï¿½}EEï¿½ï¿½ï¿½lï¿½Â¢+4tHï¿½nm;ï¿½zÜ¸ï¿½4fï¿½hï¿½ï¿½ï¿½qZï¿½ï¿½$ï¿½ï¿½9Gv
ï¿½ï¿½Ò†ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æï¿½ï¿½ï¿½Gï¿½PjJ7ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½5kï¿½ï¿½Ë‹ï¿½B[)Rï¿½pï¿½Ä‰ï¿½c;vï¿½@ï¿½ï¿½ï¿½Fï¿½Õ«W())Emoï¿½ï¿½ï¿½
ï¿½ï¿½3(((ï¿½ï¿½Þ‘ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½ï¿½p)ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ã·PJï¿½ï¿½æ¿¼ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½Ktï¿½:ï¿½ï¿½ï¿½Gï¿½ï¿½Ggyï¿½ï¿½ï¿½wcï¿½yï¿½ï¿½*ï¿½K'ï¿½gï¿½ï¿½yï¿½Eï¿½ï¿½ï¿½%ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½Ñ!ï¿½mï¿½dCï¿½ï¿½ï¿½KH)99ï¿½RSSiï¿½ï¿½+ï¿½ï¿½ï¿½VÒ¼yï¿½ï¿½iS'Snï¿½eE>ï¿½>ï¿½ï¿½&Mï¿½Hï¿½oØï¿½ï¿½ï¿½>ï¿½@ï¿½Éžï¿½ï¿½ï¿½_-WVï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½[oï¿½KO>ï¿½ï¿½hï¿½
3ï¿½ï¿½#ï¿½RZï¿½zï¿½fï¿½9|X9ï¿½Oï¿½Fï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½Ç—BBBï¿½^t/ï¿½ï¿½ï¿½qï¿½3Hï¿½ï¿½wï¿½k×®ï¿½ï¿½ï¿½_ï¿½FFï¿½3gÎª]ï¿½Utï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½u-))ï¿½ï¿½ï¿½[iï¿½È‘ï¿½ï¿½[ï¿½ï¿½ï¿½3ï¿½ Ozï¿½M{Qrrï¿½:Sï¿½V-ï¿½qF9Dï¿½	ï¿½ï¿½Qï¿½ï¿½ï¿½mï¿½Fï¿½ï¿½yï¿½8aï¿½Ã’ï¿½ï¿½Zï¿½fï¿½ï¿½ï¿½ï¿½iPï¿½@5ï¿½iß¾xï¿½Û·/a8&"ï¿½ï¿½@ï¿½kJkØ‹Ö£{
wï¿½lï¿½vmï¿½ï¿½;ï¿½)ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½f>ï¿½ -^ï¿½zï¿½S(ï¿½ï¿½ï¿½ ï¿½VÔªï¿½ï¿½ï¿½ï¿½Iï¿½gï¿½~ï¿½)H0tï¿½ï¿½ï¿½Hï¿½/ï¿½ï¿½]ï¿½ï¿½Nï¿½Uuï¿½ï¿½Oï¿½ï¿½kUï¿½ ï¿½Aï¿½ï¿½URZï¿½j
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½w;ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½Oï¿½ï¿½<5IÙž:wï¿½)S&Qï¿½.]Ô±ï¿½ï¿½}ï¿½|ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½nï¿½Ô´Tï¿½ï¿½ï¿½Ý»ï¿½ï¿½ï¿½WÏžl@oDË¿ï¿½ï¿½ï¿½ï¿½T6g	ï¿½3ï¿½O3ï¿½Ä¶ï¿½  Xï¿½Z#ï¿½ï¿½ï¿½ï¿½Xï¿½09|ï¿½PjÒ¤ï¿½ï¿½V7oï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½5f$ï¿½ï¿½iÓ¦Í´kï¿½ï¿½lï¿½ERï¿½yï¿½tï¿½G
yzï¿½*# ï¿½ï¿½ï¿½ï¿½ï¿½dCï¿½6mJï¿½-xEMï¿½<sï¿½ï¿½ï¿½~ï¿½
Ïƒï¿½ï¿½@ï¿½ï¿½ï¿½n&ï¿½ï¿½2ï¿½ï¿½ï¿½9m|^ï¿½ezï¿½ï¿½Í™ï¿½=ï¿½ï¿½tï¿½|q[ï¿½Ò¢Eï¿½WSvï¿½ï¿½i8EFFÒ»ï¿½iï¿½ï¿½ï¿½
L'ï¿½S
*ï¿½+ï¿½Aï¿½ï¿½Ôš!fï¿½ï¿½uÔ–ï¿½ï¿½QQï¿½N[ï¿½ï¿½_@×®]ï¿½Ý»ï¿½ï¿½'Oï¿½|Ð°2xz ï¿½fï¿½ï¿½ï¿½`ÊŸ  x&ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½9ï¿½Mï¿½6tï¿½ï¿½hÕªï¿½ï¿½ï¿½ï¿½Oï¿½mMï¿½Ðµï¿½kjï¿½^9yï¿½g+
ï¿½3ï¿½BZ-@ï¿½+;;ï¿½ï¿½_ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½F}xï¿½eHp0EDtï¿½Æï¿½\ï¿½+ï¿½ï¿½ACï¿½!Pkï¿½RUï¿½ï¿½ï¿½Û¢ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½Ïœ×žï¿½ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ `ê…”ï¿½ï¿½L>7ï¿½Gï¿½ï¿½>rVA@pï¿½ï¿½Û“ï¿½ï¿½)Nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½P:8ï¿½#ï¿½$M\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4É˜Cï¿½ï¿½|9Oï¿½ï¿½oï¿½/ï¿½ï¿½}ï¿½ï¿½ï¿½Fï¿½'8Cï¿½4ï¿½2ï¿½ï¿½


)??_y
ï¿½ï¿½ï¿½ï¿½ï¿½'q:Iï¿½Aï¿½ï¿½p[Rï¿½ï¿½ï¿½Ô„ï¿½yRï¿½/_ï¿½ï¿½Mï¿½+)uï¿½ï¿½I*ï¿½ï¿½[ï¿½ï¿½&$ï¿½ï¿½ï¿½5ï¿½!5kÖŒ?.ï¿½|ï¿½ï¿½'ï¿½Aï¿½5ï¿½zï¿½ï¿½kï¿½Y'ï¿½j2ï¿½ï¿½ï¿½lHxaWï¿½Nï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½HIkI@q=tï¿½ï¿½Ô¸qï¿½j%
ï¿½@ï¿½ ï¿½ï¿½ï¿½7@ï¿½ï¿½Iï¿½ÚŽÚ—.]T3ï¿½KJJï¿½q9ï¿½  ï¿½ï¿½$%3!iRrï¿½^^vv6]ï¿½Xï¿½%ï¿½oï¿½ï¿½ï¿½ï¿½*#ï¿½vï¿½7ï¿½ï¿½&#ï¿½ï¿½ï¿½ï¿½>
!i$$ï¿½ï¿½ï¿½[ï¿½ï¿½#ï¿½)Yï¿½ï¿½&ï¿½ï¿½ ï¿½p+RÒÒ¡&)ï¿½t	Aï¿½ï¿½ï¿½%)		Yï¿½ï¿½ï¿½ï¿½	!ï¿½ï¿½ï¿½dn4ï¿½ï¿½ï¿½@ï¿½Aï¿½mIÉ¬-ï¿½ï¿½ï¿½5ï¿½yaï¿½%Zï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½	ï¿½ï¿½SU*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½oï¿½ï¿½Ê¡5Î›ï¿½{ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'qï¿½Ü–ï¿½êª¯Nï¿½<ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½ï¿½PRR/
qï¿½ï¿½ï¿½]'ï¿½ï¿½8EVï¿½<nÛ¾ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½}ï¿½EE4ï¿½/ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X.Lï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½n9Oï¿½fï¿½j7vï¿½ï¿½1:pï¿½ï¿½ï¿½%ï¿½Ðƒï¿½å••Ú…ï¿½%ï¿½ï¿½ï¿½ï¿½"|ï¿½ï¿½ï¿½+Ô¡}{ï¿½h]rb.ï¿½kï¿½ï¿½4oï¿½
ï¿½ï¿½	ï¿½ ï¿½ï¿½R%ï¿½ï¿½ï¿½sKï¿½|ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½1}ï¿½ï¿½R%ï¿½ï¿½ï¿½lï¿½"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|jZï¿½ï¿½ï¿½ï¿½!YeoDEï¿½ï¿½lvï¿½w!%'ï¿½BVV6ï¿½Zï¿½ï¿½RRR)_ï¿½ï¿½.AHï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½nï¿½A6ï¿½R.ï¿½Ö¡4uï¿½$ï¿½Ñ½ï¿½ï¿½Ò'cï¿½ï¿½ï¿½ï¿½ï¿½4ï¿½ï¿½ï¿½)==ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½G{ï¿½ï¿½5
ï¿½×¯/ï¿½ï¿½Iï¿½ï¿½Kï¿½\ï¿½ ^ï¿½ï¿½_?nï¿½Lï¿½ï¿½ï¿½_Aï¿½ï¿½ï¿½
/ï¿½Þ‰W;ï¿½ï¿½ï¿½ï¿½ï¿½4Zï¿½r-ï¿½ï¿½?}ï¿½ï¿½ï¿½;ï¿½4nsË–-lï¿½>|ï¿½Ö­ï¿½ï¿½ï¿½ï¿½sï¿½a^ï¿½Ð°0ï¿½Ý«ï¿½7nL9Rï¿½Û²]ï¿½ï¿½wï¿½|6ï¿½ï¿½ï¿½ï¿½ï¿½={ï¿½6ë—¨ï¿½xï¿½ï¿½ï¿½ï¿½å‡„ï¿½ï¿½ï¿½Í ï¿½ï¿½vÓ±ï¿½ï¿½TXTHO?ï¿½kï¿½ï¿½ï¿½Ï¾ï¿½Ó§Nyï¿½Ø±ï¿½|ï¿½ï¿½ï¿½Ï–}ï¿½>ï¿½ÝŸë¹‰2ï¿½fï¿½6ï¿½s
`ï¿½!ï¿½ï¿½xï¿½FÕ·ï¿½ï¿½Aï¿½ï¿½3C9-O>1ï¿½ï¿½ï¿½yï¿½ï¿½bzï¿½ï¿½ï¿½ï¿½dFDï¿½ï¿½)ï¿½'Ú¤a$ï¿½ï¿½[ï¿½"ï¿½ï¿½ï¿½gï¿½ï¿½{Gï¿½ï¿½I'ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½Ô‡ï¿½ï¿½6ï¿½1ï¿½`ï¿½F|,Xï¿½Ð¢uï¿½vï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½R^ï¿½	ï¿™%ï¿½ï¿½t$EEEï¿½ï¿½;ï¿½ï¿½	ï¿½ï¿½9ï¿½bï¿½<ï¿½ï¿½ï¿½ï¿½bzï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ý¯nï¿½l&ï¿½!ï¿½Q@@ ï¿½8ï¿½ï¿½Ãƒ
ï¿½ï¿½Umï¿½ï¿½Cï¿½ï¿½P<ï¿½ï¿½ï¿½Rï¿½{ï¿½ï¿½Ô¡C;^)8ï¿½ï¿½;N%ï¿½%ï¿½ï¿½KUï¿½Bï¿½Xï¿½ï¿½-Zï¿½ï¿½C|ï¿½C#Xï¿½7zï¿½Iï¿½:LPï¿½@&ï¿½(ï¿½ï¿½ï¿½_}ï¿½ï¿½ï¿½nï¿½I-}3ï¿½?ï¿½Ò”ï¿½oØ¤ï¿½>8oï¿½.áª¨ï¿½Ç“ï¿½ï¿½yï¿½ï¿½ï¿½ï¿½ï¿½JH8D[ï¿½mï¿½Awï¿½l3Frï¿½`Ã†
ï¿½ï¿½oï¿½O^ï¿½ï¿½ï¿½ï¿½ï¿½wRï¿½ï¿½Ô¿_ï¿½j+Vï¿½á¥·ï¿½(ï¿½:t0ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½!%%ï¿½ï¿½ï¿½Aï¿½Oï¿½:Cï¿½ï¿½ï¿½t<1ï¿½ï¿½ï¿½Cï¿½ï¿½
ï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½ï¿½Ú‚ï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½o#ï¿½Gï¿½I9ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½r@8ï¿½ï¿½(ï¿½SGjÕªï¿½"ï¿½]ï¿½~Vï¿½ï¿½ï¿½ï¿½vï¿½Ô¦ï¿½ï¿½Ã‡Viï¿½d_ï¿½QuD=Sï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½]ï¿½ï¿½`^ï¿½gÈ;ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½|ï¿½ï¿½}r<1ï¿½jï¿½3
ï¿½hï¿½ï¿½.ï¿½h%ï¿½ZIÉ©tï¿½bï¿½awÆŒitï¿½ï¿½!ï¿½ï¿½Mï¿½ï¿½ï¿½ï¿½Pï¿½|ï¿½@+ï¿½ï¿½ï¿½ï¿½Mï¿½?ï¿½ï¿½qQBï¿½ï¿½á‡•tï¿½ï¿½Q:$Fgï¿½R8mï¿½dï¿½ï¿½ï¿½S3yï¿½DZï¿½ï¿½bÚ¶m'ï¿½;Fï¿½ï¿½ï¿½ï¿½ï¿½08ï¿½ï¿½ï¿½d^6}p9ï¿½Ì‰ï¿½fßµkk	-ï¿½ï¿½W^242Ü˜ï¿½ï¿½Ö»ï¿½ï¿½ï¿½ÔŠoï¿½}á·†ï¿½Ù‹ï¿½xï¿½M^6}ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½Ö­[Uï¿½!|ï¿½ï¿½ï¿½ï¿½Ûµï¿½06oÞªHjï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½i-Aï¿½ï¿½Nï¿½_ï¿½>Å¤ï¿½ï¿½ï¿½Lï¿½ï¿½~ï¿½ï¿½ÖŽï¿½ï¿½ï¿½Tï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½ï¿½?<ï¿½~ï¿½ï¿½oï¿½ï¿½;Ç„ï¿½ï¿½Oï¿½Ic7ï¿½rï¿½ï¿½ï¿½Eï¿½ï¿½?Jï¿½ï¿½N-ï¿½XÚ¶mCï¿½ï¿½ï¿½kï¿½ï¿½ï¿½ï¿½tï¿½ï¿½oï¿½cï¿½ï¿½&.ï¿½sDD=ï¿½ï¿½ï¿½F9+ï¿½ï¿½7ï¿½ï¿½ ï¿½ï¿½ï¿½_ï¿½>Fï¿½+ï¿½1ï¿½pï¿½Eï¿½ï¿½tH1kGZï¿½-Zï¿½ï¿½$ï¿½m&cï¿½#xJï¿½$Ò£ï¿½)a];ï¿½ï¿½ï¿½ï¿½Yï¿½I4'ï¿½ï¿½ï¿½ï¿½1ï¿½&
ï¿½xï¿½ï¿½/ï¿½ï¿½ß‡ï¿½ï¿½.ï¿½6mï¿½ï¿½.#ï¿½ï¿½ï¿½kï¿½ï¿½mï¿½ï¿½ï¿½ï¿½+ï¿½Ïœï¿½Ò‹ï¿½eï¿½ï¿½<ï¿½ï¿½d	k3ï¿½BB^yï¿½rï¿½
ï¿½gÏž%hï¿½gyHfï¿½ ï¿½132NImZï¿½ï¿½ï¿½7|`ï¿½uï¿½ï¿½ÊšG;ï¿½ï¿½Í‚cÔ¹ï¿½ï¿½3'Ó¨Qwï¿½lï¿½oï¿½ï¿½&NWï¿½ï¿½ï¿½ï¿½3'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½á¸¹ï¿½Â˜ï¿½ï¿½ï¿½jï¿½h'ï¿½Dï¿½@^Zï¿½ï¿½lHCï¿½W6<q"]vtï¿½mï¿½DG+RJMMï¿½)ï¿½ï¿½ï¿½Xeï¿½oï¿½|BJzï¿½\ï¿½ï¿½yØ‡!ï¿½a~Reï¿½ï¿½ï¿½ï¿½G
ï¿½f$é§¶ï¿½"ï¿½Î®]ï¿½ï¿½ï¿½ï¿½ï¿½È‡n Gï¿½ï¿½YBCï¿½nï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½wï¿½ï¿½Ù¼Y.Þ·oï¿½ï¿½Øyï¿½ï¿½.ï¿½\.Dï¿½9ï¿½9ï¿½ï¿½]6ï¿½Å	?{)5}ZÆ„ï¿½ï¿½(nï¿½6Cï¿½ï¿½aï¿½ï¿½Ö­+=0cï¿½ï¿½x=Ý )ï¿½"-YWï¿½ï¿½yï¿½ï¿½Vy`ï¿½:}ï¿½ï¿½;ï¿½Â„Ã‚ï¿½ï¿½x!ï¿½ï¿½ï¿½;ï¿½ï¿½9
ï¿½rrlh6ï¿½xï¿½ï¿½5fï¿½ï¿½!n)9ï¿½5ï¿½ï¿½ï¿½,ï¿½ï¿½_ï¿½g;ï¿½!Íš6Sï¿½M_ï¿½Õ‘ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½ï¿½uï¿½
Stï¿½ï¿½ï¿½ï¿½ï¿½!|dï¿½ï¿½ï¿½rqï¿½rï¿½R9ï¿½ï¿½p#ï¿½5ï¿½Ø±ï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½`ï¿½ï¿½ï¿½aaGï¿½ï¿½ ;ï¿½GKï¿½ï¿½K/>ï¿½ï¿½
*ï¿½\e{]Uï¿½ï¿½6Wï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½
BÂ¹0M ï¿½ï¿½L
jA?ï¿½ï¿½ï¿½Wuï¿½'ï¿½BJz7Ð—_~Kï¿½ï¿½4{ï¿½ï¿½lè½ª.ï¿½6<ï¿½0{EZkIYYï¿½ï¿½ï¿½uï¿½	ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½kï¿½ï¿½|Xï¿½ah5ï¿½'ï¿½ï¿½fï¿½!ï¿½ï¿½4Mp&ï¿½[8ï¿½ï¿½ï¿½0CÎž=Çžï¿½<ï¿½ï¿½Cï¿½Þ½zï¿½ï¿½ï¿½Xï¿½ï¿½]Û¶ï¿½ï¿½0ï¿½ï¿½1ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½T^brï¿½'ï¿½LÊ†]pZï¿½ï¿½ï¿½ï¿½ï¿½Ï¯ï¿½	ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Ã§ï¿½ï¿½Nï¿½ï¿½ï¿½<ï¿½3ï¿½Ú¨Qc6ï¿½S	ï¿½ï¿½ï¿½Bï¿½KULkHï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½/ï¿½sï¿½ï¿½ï¿½ï¿½q!%=ï¿½':l ï¿½ï¿½K?7<mï¿½ ï¿½~ï¿½]#x(vï¿½á’ƒbï¿½ï¿½Wï¿½ï¿½{ï¿½Vï¿½={ï¿½ï¿½ï¿½ï¿½,8pï¿½Z
ï¿½ï¿½>ï¿½ï¿½kï¿½)ï¿½ï¿½vï¿½ï¿½
ï¿½q=y{Tf'ï¿½ï¿½5ï¿½É³ï¿½)ï¿½ï¿½ vï¿½ï¿½ï¿½6ï¿½=ï¿½^ÆKË¸~ï¿½ï¿½Ö‡ï¿½ï¿½+ï¿½Ü‰<ï¿½Cï¿½v)}ï¿½ï¿½rJIKeï¿½Rï¿½ï¿½!1mHeOï¿½Q&ï¿½^=#ï¿½bqCÃ–ï¿½ï¿½ï¿½d1ï¿½ï¿½bï¿½ï¿½Æï¿½ï¿½ï¿½`ï¿½ï¿½0ï¿½ï¿½ï¿½Afï¿½ï¿½bÚ‚n3
ï¿½Û§ï¿½aï¿½&vï¿½ï¿½ï¿½,ï¿½-Zï¿½gï¿½4{ï¿½Lï¿½3ZÅ‹YCï¿½ï¿½ï¿½?dBï¿½Qï¿½ï¿½Î?ï¿½ï¿½ï¿½pvpï¿½ï¿½ï¿½ï¿½ï¿½+ï¿½ï¿½e!Ï‚Wï¿½ï¿½	ï¿½ï¿½ï¿½}ï¿½a 0<ï¿½t=[3ï¿½ï¿½[	ï¿½(Jï¿½}ï¿½>ï¿½kdï¿½7vï¿½Þ«<wï¿½~zï¿½)9ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Öµ+ï¿½ï¿½Sxï¿½ï¿½ï¿½pï¿½m:ï¿½Þ¶gï¿½\ï¿½$ï¿½Ú‚.ï¿½~[ï¿½W%7vï¿½zWKÏ‹ï¿½ï¿½fï¿½ï¿½ï¿½F{ï¿½ï¿½cï¿½ï¿½Vc;%5ï¿½ï¿½ï¿½ï¿½VURï¿½q3ï¿½AEï¿½Eï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Yfï¿½ï¿½ï¿½CMï¿½Xï¿½r5a#ï¿½ï¿½ï¿½Ó¦Øœï¿½ï¿½ï¿½ï¿½ï¿½ï¿½WPï¿½{ï¿½ï¿½ï¿½	ï¿½hï¿½ï¿½9Mfyï¿½ï¿½5bï¿½nÓ¦ÍŠï¿½:uï¿½Dï¿½f=dxOï¿½eË¾0fï¿½ï¿½"ï¿½Iï¿½ï¿½WQï¿½ï¿½ï¿½bRï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½ ï¿½7jï¿½Hï¿½acï¿½ï¿½L`Bï¿½ï¿½kï¿½fï¿½cJï¿½oï¿½2ï¿½^'ï¿½ï¿½#ï¿½1ï¿½4Lï¿½xï¿½I	ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½=tï¿½esï¿½ï¿½!ï¿½%<ï¿½ï¿½ï¿½6x#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½V+ï¿½jï¿½2ï¿½Vï¿½a6.ï¿½ï¿½ï¿½Rï¿½Tï¿½Â“fIJ*3^ï¿½ï¿½ï¿½+xÅŠUÔžï¿½ï¿½#Gï¿½yï¿½ï¿½ï¿½;8))Ù˜ï¿½.l%ï¿½-pï¿½ï¿½[ï¿½ï¿½/Zï¿½4ï¿½ï¿½aï¿½ï¿½ï¿½ï¿½ï¿½hï¿½LNï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ub0ï¿½ï¿½ï¿½ï¿½ï¿½Ù‹ï¿½(?ï¿½eï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½É¬ï¿½a:Ú‡ï¿½3++[ï¿½ï¿½ï¿½uuï¿½ï¿½Xï¿½hJz%!ï¿½J-ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½.Ä™wÎ•ï¿½	jï¿½wEç©¬ï¿½ï¿½ï¿½ï¿½ï¿½6ï¿½n8ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½FMaï¿½)C@Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½vï¿½ï¿½ï¿½ÈŽï¿½Ý ;88Rï¿½Aï¿½ï¿½)9@ï¿½ï¿½ï¿½×ï¿½;ï¿½Hï¿½jï¿½O
ï¿½ï¿½:w/7ï¿½wPLï¿½ï¿½ï¿½"ï¿½È¿ï¿½ï¿½ï¿½ï¿½V!rPï¿½5jDï¿½Iï¿½ï¿½>X2ï¿½ï¿½)ï¿½V)Tï¿½ï¿½ï¿½M#IuKï¿½ï¿½qfoï¿½9nï¿½ï¿½Jï¿½Aï¿½nKJï¿½ï¿½o5ï¿½-8ï¿½ï¿½ï¿½l:ï¿½ï¿½ï¿½ï¿½ Pï¿½ï¿½ï¿½M	ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½"1ï¿½_>Wjï¿½ï¿½lï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Rï¿½b.ï¿½Jï¿½ï¿½<Í›~"ï¿½ï¿½ `
ï¿½jï¿½fO8ï¿½iï¿½a2ï¿½ï¿½wï¿½ï¿½ï¿½ï¿½Bï¿½#ï¿½Vï¿½dnï¿½ï¿½$MJpï¿½cï¿½ï¿½ï¿½"ï¿½ï¿½ `]Ü’ï¿½@DMH 'ï¿½ï¿½ï¿½;Kxï¿½Lï¿½GÖ½ ï¿½fï¿½ï¿½ï¿½Ú”@HÚ†Rï¿½ï¿½hï¿½ï¿½ï¿½ï¿½Æ„ï¿½ï¿½ï¿½iï¿½ï¿½Aï¿½ï¿½#%MFï¿½qï¿½ï¿½	ï¿½Bï¿½ï¿½7ï¿½ï¿½ï¿½ 4&ï¿½ï¿½ï¿½ï¿½3Wï¿½]#5<ï¿½#%ÝZï¿½)i1iA:ï¿½Dï¿½Dï¿½:ï¿½ï¿½ï¿½ï¿½ Pï¿½ï¿½%)imIBMHï¿½ï¿½g&$31ï¿½}ï¿½Aï¿½ï¿½ï¿½[ï¿½ï¿½Ñšï¿½ÖŠï¿½Ä„}ï¿½ï¿½ï¿½<:4ï¿½#qA@ï¿½{Ü–ï¿½4ï¿½ï¿½ï¿½ï¿½mIoCSï¿½iï¿½+ï¿½ï¿½ï¿½Pï¿½_Üšï¿½4!4ï¿½ï¿½>ï¿½.ï¿½nï¿½ï¿½ï¿½ï¿½@ï¿½"ï¿½Ö¤h5!A2ï¿½ï¿½=)Akï¿½ï¿½Æ¤`ï¿½?Aï¿½ï¿½p{Rï¿½ÈšIHï¿½9ÍœOï¿½%ï¿½ï¿½Gï¿½cH	ï¿½j2B\kDï¿½4ï¿½ï¿½ï¿½@ï¿½"ï¿½Qï¿½dï¿½Zï¿½ÈŒï¿½ï¿½ï¿½ psfï¿½uï¿½$5F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½3DEï¿½Aï¿½Xs    IENDï¿½B`ï¿½
--- END OF FILE 2025-03-26/server/slash-command.png ---


--- START OF FILE 2025-03-26/server/tools.mdx ---
---
title: Tools
---

<Info>**Protocol Revision**: 2025-03-26</Info>

The Model Context Protocol (MCP) allows servers to expose tools that can be invoked by
language models. Tools enable models to interact with external systems, such as querying
databases, calling APIs, or performing computations. Each tool is uniquely identified by
a name and includes metadata describing its schema.

## User Interaction Model

Tools in MCP are designed to be **model-controlled**, meaning that the language model can
discover and invoke tools automatically based on its contextual understanding and the
user's prompts.

However, implementations are free to expose tools through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

<Warning>

For trust & safety and security, there **SHOULD** always
be a human in the loop with the ability to deny tool invocations.

Applications **SHOULD**:

- Provide UI that makes clear which tools are being exposed to the AI model
- Insert clear visual indicators when tools are invoked
- Present confirmation prompts to the user for operations, to ensure a human is in the
  loop

</Warning>

## Capabilities

Servers that support tools **MUST** declare the `tools` capability:

```json
{
  "capabilities": {
    "tools": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the server will emit notifications when the list of
available tools changes.

## Protocol Messages

### Listing Tools

To discover available tools, clients send a `tools/list` request. This operation supports
[pagination](/specification/2025-03-26/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "City name or zip code"
            }
          },
          "required": ["location"]
        }
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Calling Tools

To invoke a tool, clients send a `tools/call` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "get_weather",
    "arguments": {
      "location": "New York"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Current weather in New York:\nTemperature: 72Â°F\nConditions: Partly cloudy"
      }
    ],
    "isError": false
  }
}
```

### List Changed Notification

When the list of available tools changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant LLM
    participant Client
    participant Server

    Note over Client,Server: Discovery
    Client->>Server: tools/list
    Server-->>Client: List of tools

    Note over Client,LLM: Tool Selection
    LLM->>Client: Select tool to use

    Note over Client,Server: Invocation
    Client->>Server: tools/call
    Server-->>Client: Tool result
    Client->>LLM: Process result

    Note over Client,Server: Updates
    Server--)Client: tools/list_changed
    Client->>Server: tools/list
    Server-->>Client: Updated tools
```

## Data Types

### Tool

A tool definition includes:

- `name`: Unique identifier for the tool
- `description`: Human-readable description of functionality
- `inputSchema`: JSON Schema defining expected parameters
- `annotations`: optional properties describing tool behavior

<Warning>

For trust & safety and security, clients **MUST** consider
tool annotations to be untrusted unless they come from trusted servers.

</Warning>

### Tool Result

Tool results can contain multiple content items of different types:

#### Text Content

```json
{
  "type": "text",
  "text": "Tool result text"
}
```

#### Image Content

```json
{
  "type": "image",
  "data": "base64-encoded-data",
  "mimeType": "image/png"
}
```

#### Audio Content

```json
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

#### Embedded Resources

[Resources](/specification/2025-03-26/server/resources) **MAY** be embedded, to provide additional context
or data, behind a URI that can be subscribed to or fetched again by the client later:

```json
{
  "type": "resource",
  "resource": {
    "uri": "resource://example",
    "mimeType": "text/plain",
    "text": "Resource content"
  }
}
```

## Error Handling

Tools use two error reporting mechanisms:

1. **Protocol Errors**: Standard JSON-RPC errors for issues like:

   - Unknown tools
   - Invalid arguments
   - Server errors

2. **Tool Execution Errors**: Reported in tool results with `isError: true`:
   - API failures
   - Invalid input data
   - Business logic errors

Example protocol error:

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "error": {
    "code": -32602,
    "message": "Unknown tool: invalid_tool_name"
  }
}
```

Example tool execution error:

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Failed to fetch weather data: API rate limit exceeded"
      }
    ],
    "isError": true
  }
}
```

## Security Considerations

1. Servers **MUST**:

   - Validate all tool inputs
   - Implement proper access controls
   - Rate limit tool invocations
   - Sanitize tool outputs

2. Clients **SHOULD**:
   - Prompt for user confirmation on sensitive operations
   - Show tool inputs to the user before calling the server, to avoid malicious or
     accidental data exfiltration
   - Validate tool results before passing to LLM
   - Implement timeouts for tool calls
   - Log tool usage for audit purposes

--- END OF FILE 2025-03-26/server/tools.mdx ---


--- START OF FILE 2025-03-26/changelog.mdx ---
---
title: Key Changes
---

This document lists changes made to the Model Context Protocol (MCP) specification since
the previous revision, [2024-11-05](/specification/2024-11-05).

## Major changes

1. Added a comprehensive **[authorization framework](/specification/2025-03-26/basic/authorization)**
   based on OAuth 2.1 (PR
   [#133](https://github.com/modelcontextprotocol/specification/pull/133))
1. Replaced the previous HTTP+SSE transport with a more flexible **[Streamable HTTP
   transport](/specification/2025-03-26/basic/transports#streamable-http)** (PR
   [#206](https://github.com/modelcontextprotocol/specification/pull/206))
1. Added support for JSON-RPC **[batching](https://www.jsonrpc.org/specification#batch)**
   (PR [#228](https://github.com/modelcontextprotocol/specification/pull/228))
1. Added comprehensive **tool annotations** for better describing tool behavior, like
   whether it is read-only or destructive (PR
   [#185](https://github.com/modelcontextprotocol/specification/pull/185))

## Other schema changes

- Added `message` field to `ProgressNotification` to provide descriptive status updates
- Added support for audio data, joining the existing text and image content types
- Added `completions` capability to explicitly indicate support for argument
  autocompletion suggestions

See
[the updated schema](http://github.com/modelcontextprotocol/specification/tree/main/schema/2025-03-26/schema.ts)
for more details.

## Full changelog

For a complete list of all changes that have been made since the last protocol revision,
[see GitHub](https://github.com/modelcontextprotocol/specification/compare/2024-11-05...2025-03-26).

--- END OF FILE 2025-03-26/changelog.mdx ---


--- START OF FILE 2025-03-26/index.mdx ---
---
title: Specification
---

[Model Context Protocol](https://modelcontextprotocol.io) (MCP) is an open protocol that
enables seamless integration between LLM applications and external data sources and
tools. Whether you're building an AI-powered IDE, enhancing a chat interface, or creating
custom AI workflows, MCP provides a standardized way to connect LLMs with the context
they need.

This specification defines the authoritative protocol requirements, based on the
TypeScript schema in
[schema.ts](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26/schema.ts).

For implementation guides and examples, visit
[modelcontextprotocol.io](https://modelcontextprotocol.io).

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [BCP 14](https://datatracker.ietf.org/doc/html/bcp14)
[[RFC2119](https://datatracker.ietf.org/doc/html/rfc2119)]
[[RFC8174](https://datatracker.ietf.org/doc/html/rfc8174)] when, and only when, they
appear in all capitals, as shown here.

## Overview

MCP provides a standardized way for applications to:

- Share contextual information with language models
- Expose tools and capabilities to AI systems
- Build composable integrations and workflows

The protocol uses [JSON-RPC](https://www.jsonrpc.org/) 2.0 messages to establish
communication between:

- **Hosts**: LLM applications that initiate connections
- **Clients**: Connectors within the host application
- **Servers**: Services that provide context and capabilities

MCP takes some inspiration from the
[Language Server Protocol](https://microsoft.github.io/language-server-protocol/), which
standardizes how to add support for programming languages across a whole ecosystem of
development tools. In a similar way, MCP standardizes how to integrate additional context
and tools into the ecosystem of AI applications.

## Key Details

### Base Protocol

- [JSON-RPC](https://www.jsonrpc.org/) message format
- Stateful connections
- Server and client capability negotiation

### Features

Servers offer any of the following features to clients:

- **Resources**: Context and data, for the user or the AI model to use
- **Prompts**: Templated messages and workflows for users
- **Tools**: Functions for the AI model to execute

Clients may offer the following feature to servers:

- **Sampling**: Server-initiated agentic behaviors and recursive LLM interactions

### Additional Utilities

- Configuration
- Progress tracking
- Cancellation
- Error reporting
- Logging

## Security and Trust & Safety

The Model Context Protocol enables powerful capabilities through arbitrary data access
and code execution paths. With this power comes important security and trust
considerations that all implementors must carefully address.

### Key Principles

1. **User Consent and Control**

   - Users must explicitly consent to and understand all data access and operations
   - Users must retain control over what data is shared and what actions are taken
   - Implementors should provide clear UIs for reviewing and authorizing activities

2. **Data Privacy**

   - Hosts must obtain explicit user consent before exposing user data to servers
   - Hosts must not transmit resource data elsewhere without user consent
   - User data should be protected with appropriate access controls

3. **Tool Safety**

   - Tools represent arbitrary code execution and must be treated with appropriate
     caution.
     - In particular, descriptions of tool behavior such as annotations should be
       considered untrusted, unless obtained from a trusted server.
   - Hosts must obtain explicit user consent before invoking any tool
   - Users should understand what each tool does before authorizing its use

4. **LLM Sampling Controls**
   - Users must explicitly approve any LLM sampling requests
   - Users should control:
     - Whether sampling occurs at all
     - The actual prompt that will be sent
     - What results the server can see
   - The protocol intentionally limits server visibility into prompts

### Implementation Guidelines

While MCP itself cannot enforce these security principles at the protocol level,
implementors **SHOULD**:

1. Build robust consent and authorization flows into their applications
2. Provide clear documentation of security implications
3. Implement appropriate access controls and data protections
4. Follow security best practices in their integrations
5. Consider privacy implications in their feature designs

## Learn More

Explore the detailed specification for each protocol component:

<CardGroup cols={5}>
  <Card
    title="Architecture"
    icon="sitemap"
    href="/specification/2025-03-26/architecture"
  />
  <Card
    title="Base Protocol"
    icon="code"
    href="/specification/2025-03-26/basic"
  />
  <Card
    title="Server Features"
    icon="server"
    href="/specification/2025-03-26/server"
  />
  <Card
    title="Client Features"
    icon="user"
    href="/specification/2025-03-26/client"
  />
  <Card title="Contributing" icon="pencil" href="/development/contributing" />
</CardGroup>

--- END OF FILE 2025-03-26/index.mdx ---


--- START OF FILE 2025-06-18/architecture/index.mdx ---
---
title: Architecture
---

<div id="enable-section-numbers" />

The Model Context Protocol (MCP) follows a client-host-server architecture where each
host can run multiple client instances. This architecture enables users to integrate AI
capabilities across applications while maintaining clear security boundaries and
isolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused
on context exchange and sampling coordination between clients and servers.

## Core Components

```mermaid
graph LR
    subgraph "Application Host Process"
        H[Host]
        C1[Client 1]
        C2[Client 2]
        C3[Client 3]
        H --> C1
        H --> C2
        H --> C3
    end

    subgraph "Local machine"
        S1[Server 1<br>Files & Git]
        S2[Server 2<br>Database]
        R1[("Local<br>Resource A")]
        R2[("Local<br>Resource B")]

        C1 --> S1
        C2 --> S2
        S1 <--> R1
        S2 <--> R2
    end

    subgraph "Internet"
        S3[Server 3<br>External APIs]
        R3[("Remote<br>Resource C")]

        C3 --> S3
        S3 <--> R3
    end
```

### Host

The host process acts as the container and coordinator:

- Creates and manages multiple client instances
- Controls client connection permissions and lifecycle
- Enforces security policies and consent requirements
- Handles user authorization decisions
- Coordinates AI/LLM integration and sampling
- Manages context aggregation across clients

### Clients

Each client is created by the host and maintains an isolated server connection:

- Establishes one stateful session per server
- Handles protocol negotiation and capability exchange
- Routes protocol messages bidirectionally
- Manages subscriptions and notifications
- Maintains security boundaries between servers

A host application creates and manages multiple clients, with each client having a 1:1
relationship with a particular server.

### Servers

Servers provide specialized context and capabilities:

- Expose resources, tools and prompts via MCP primitives
- Operate independently with focused responsibilities
- Request sampling through client interfaces
- Must respect security constraints
- Can be local processes or remote services

## Design Principles

MCP is built on several key design principles that inform its architecture and
implementation:

1. **Servers should be extremely easy to build**

   - Host applications handle complex orchestration responsibilities
   - Servers focus on specific, well-defined capabilities
   - Simple interfaces minimize implementation overhead
   - Clear separation enables maintainable code

2. **Servers should be highly composable**

   - Each server provides focused functionality in isolation
   - Multiple servers can be combined seamlessly
   - Shared protocol enables interoperability
   - Modular design supports extensibility

3. **Servers should not be able to read the whole conversation, nor "see into" other
   servers**

   - Servers receive only necessary contextual information
   - Full conversation history stays with the host
   - Each server connection maintains isolation
   - Cross-server interactions are controlled by the host
   - Host process enforces security boundaries

4. **Features can be added to servers and clients progressively**
   - Core protocol provides minimal required functionality
   - Additional capabilities can be negotiated as needed
   - Servers and clients evolve independently
   - Protocol designed for future extensibility
   - Backwards compatibility is maintained

## Capability Negotiation

The Model Context Protocol uses a capability-based negotiation system where clients and
servers explicitly declare their supported features during initialization. Capabilities
determine which protocol features and primitives are available during a session.

- Servers declare capabilities like resource subscriptions, tool support, and prompt
  templates
- Clients declare capabilities like sampling support and notification handling
- Both parties must respect declared capabilities throughout the session
- Additional capabilities can be negotiated through extensions to the protocol

```mermaid
sequenceDiagram
    participant Host
    participant Client
    participant Server

    Host->>+Client: Initialize client
    Client->>+Server: Initialize session with capabilities
    Server-->>Client: Respond with supported capabilities

    Note over Host,Server: Active Session with Negotiated Features

    loop Client Requests
        Host->>Client: User- or model-initiated action
        Client->>Server: Request (tools/resources)
        Server-->>Client: Response
        Client-->>Host: Update UI or respond to model
    end

    loop Server Requests
        Server->>Client: Request (sampling)
        Client->>Host: Forward to AI
        Host-->>Client: AI response
        Client-->>Server: Response
    end

    loop Notifications
        Server--)Client: Resource updates
        Client--)Server: Status changes
    end

    Host->>Client: Terminate
    Client->>-Server: End session
    deactivate Server
```

Each capability unlocks specific protocol features for use during the session. For
example:

- Implemented [server features](/specification/2025-06-18/server) must be advertised in the
  server's capabilities
- Emitting resource subscription notifications requires the server to declare
  subscription support
- Tool invocation requires the server to declare tool capabilities
- [Sampling](/specification/2025-06-18/client) requires the client to declare support in its
  capabilities

This capability negotiation ensures clients and servers have a clear understanding of
supported functionality while maintaining protocol extensibility.

--- END OF FILE 2025-06-18/architecture/index.mdx ---


--- START OF FILE 2025-06-18/basic/utilities/cancellation.mdx ---
---
title: Cancellation
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol (MCP) supports optional cancellation of in-progress requests
through notification messages. Either side can send a cancellation notification to
indicate that a previously-issued request should be terminated.

## Cancellation Flow

When a party wants to cancel an in-progress request, it sends a `notifications/cancelled`
notification containing:

- The ID of the request to cancel
- An optional reason string that can be logged or displayed

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/cancelled",
  "params": {
    "requestId": "123",
    "reason": "User requested cancellation"
  }
}
```

## Behavior Requirements

1. Cancellation notifications **MUST** only reference requests that:
   - Were previously issued in the same direction
   - Are believed to still be in-progress
2. The `initialize` request **MUST NOT** be cancelled by clients
3. Receivers of cancellation notifications **SHOULD**:
   - Stop processing the cancelled request
   - Free associated resources
   - Not send a response for the cancelled request
4. Receivers **MAY** ignore cancellation notifications if:
   - The referenced request is unknown
   - Processing has already completed
   - The request cannot be cancelled
5. The sender of the cancellation notification **SHOULD** ignore any response to the
   request that arrives afterward

## Timing Considerations

Due to network latency, cancellation notifications may arrive after request processing
has completed, and potentially after a response has already been sent.

Both parties **MUST** handle these race conditions gracefully:

```mermaid
sequenceDiagram
   participant Client
   participant Server

   Client->>Server: Request (ID: 123)
   Note over Server: Processing starts
   Client--)Server: notifications/cancelled (ID: 123)
   alt
      Note over Server: Processing may have<br/>completed before<br/>cancellation arrives
   else If not completed
      Note over Server: Stop processing
   end
```

## Implementation Notes

- Both parties **SHOULD** log cancellation reasons for debugging
- Application UIs **SHOULD** indicate when cancellation is requested

## Error Handling

Invalid cancellation notifications **SHOULD** be ignored:

- Unknown request IDs
- Already completed requests
- Malformed notifications

This maintains the "fire and forget" nature of notifications while allowing for race
conditions in asynchronous communication.

--- END OF FILE 2025-06-18/basic/utilities/cancellation.mdx ---


--- START OF FILE 2025-06-18/basic/utilities/ping.mdx ---
---
title: Ping
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol includes an optional ping mechanism that allows either party
to verify that their counterpart is still responsive and the connection is alive.

## Overview

The ping functionality is implemented through a simple request/response pattern. Either
the client or server can initiate a ping by sending a `ping` request.

## Message Format

A ping request is a standard JSON-RPC request with no parameters:

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "method": "ping"
}
```

## Behavior Requirements

1. The receiver **MUST** respond promptly with an empty response:

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {}
}
```

2. If no response is received within a reasonable timeout period, the sender **MAY**:
   - Consider the connection stale
   - Terminate the connection
   - Attempt reconnection procedures

## Usage Patterns

```mermaid
sequenceDiagram
    participant Sender
    participant Receiver

    Sender->>Receiver: ping request
    Receiver->>Sender: empty response
```

## Implementation Considerations

- Implementations **SHOULD** periodically issue pings to detect connection health
- The frequency of pings **SHOULD** be configurable
- Timeouts **SHOULD** be appropriate for the network environment
- Excessive pinging **SHOULD** be avoided to reduce network overhead

## Error Handling

- Timeouts **SHOULD** be treated as connection failures
- Multiple failed pings **MAY** trigger connection reset
- Implementations **SHOULD** log ping failures for diagnostics

--- END OF FILE 2025-06-18/basic/utilities/ping.mdx ---


--- START OF FILE 2025-06-18/basic/utilities/progress.mdx ---
---
title: Progress
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol (MCP) supports optional progress tracking for long-running
operations through notification messages. Either side can send progress notifications to
provide updates about operation status.

## Progress Flow

When a party wants to _receive_ progress updates for a request, it includes a
`progressToken` in the request metadata.

- Progress tokens **MUST** be a string or integer value
- Progress tokens can be chosen by the sender using any means, but **MUST** be unique
  across all active requests.

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "some_method",
  "params": {
    "_meta": {
      "progressToken": "abc123"
    }
  }
}
```

The receiver **MAY** then send progress notifications containing:

- The original progress token
- The current progress value so far
- An optional "total" value
- An optional "message" value

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/progress",
  "params": {
    "progressToken": "abc123",
    "progress": 50,
    "total": 100,
    "message": "Reticulating splines..."
  }
}
```

- The `progress` value **MUST** increase with each notification, even if the total is
  unknown.
- The `progress` and the `total` values **MAY** be floating point.
- The `message` field **SHOULD** provide relevant human readable progress information.

## Behavior Requirements

1. Progress notifications **MUST** only reference tokens that:

   - Were provided in an active request
   - Are associated with an in-progress operation

2. Receivers of progress requests **MAY**:
   - Choose not to send any progress notifications
   - Send notifications at whatever frequency they deem appropriate
   - Omit the total value if unknown

```mermaid
sequenceDiagram
    participant Sender
    participant Receiver

    Note over Sender,Receiver: Request with progress token
    Sender->>Receiver: Method request with progressToken

    Note over Sender,Receiver: Progress updates
    loop Progress Updates
        Receiver-->>Sender: Progress notification (0.2/1.0)
        Receiver-->>Sender: Progress notification (0.6/1.0)
        Receiver-->>Sender: Progress notification (1.0/1.0)
    end

    Note over Sender,Receiver: Operation complete
    Receiver->>Sender: Method response
```

## Implementation Notes

- Senders and receivers **SHOULD** track active progress tokens
- Both parties **SHOULD** implement rate limiting to prevent flooding
- Progress notifications **MUST** stop after completion

--- END OF FILE 2025-06-18/basic/utilities/progress.mdx ---


--- START OF FILE 2025-06-18/basic/authorization.mdx ---
---
title: Authorization
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

## Introduction

### Purpose and Scope

The Model Context Protocol provides authorization capabilities at the transport level,
enabling MCP clients to make requests to restricted MCP servers on behalf of resource
owners. This specification defines the authorization flow for HTTP-based transports.

### Protocol Requirements

Authorization is **OPTIONAL** for MCP implementations. When supported:

- Implementations using an HTTP-based transport **SHOULD** conform to this specification.
- Implementations using an STDIO transport **SHOULD NOT** follow this specification, and
  instead retrieve credentials from the environment.
- Implementations using alternative transports **MUST** follow established security best
  practices for their protocol.

### Standards Compliance

This authorization mechanism is based on established specifications listed below, but
implements a selected subset of their features to ensure security and interoperability
while maintaining simplicity:

- OAuth 2.1 IETF DRAFT ([draft-ietf-oauth-v2-1-12](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12))
- OAuth 2.0 Authorization Server Metadata
  ([RFC8414](https://datatracker.ietf.org/doc/html/rfc8414))
- OAuth 2.0 Dynamic Client Registration Protocol
  ([RFC7591](https://datatracker.ietf.org/doc/html/rfc7591))
- OAuth 2.0 Protected Resource Metadata ([RFC9728](https://datatracker.ietf.org/doc/html/rfc9728))

## Authorization Flow

### Roles

A protected _MCP server_ acts as an [OAuth 2.1 resource server](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-12.html#name-roles),
capable of accepting and responding to protected resource requests using access tokens.

An _MCP client_ acts as an [OAuth 2.1 client](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-12.html#name-roles),
making protected resource requests on behalf of a resource owner.

The _authorization server_ is responsible for interacting with the user (if necessary) and issuing access tokens for use at the MCP server.
The implementation details of the authorization server are beyond the scope of this specification. It may be hosted with the
resource server or a separate entity. The [Authorization Server Discovery section](#authorization-server-discovery)
specifies how an MCP server indicates the location of its corresponding authorization server to a client.

### Overview

1. Authorization servers **MUST** implement OAuth 2.1 with appropriate security
   measures for both confidential and public clients.

1. Authorization servers and MCP clients **SHOULD** support the OAuth 2.0 Dynamic Client Registration
   Protocol ([RFC7591](https://datatracker.ietf.org/doc/html/rfc7591)).

1. MCP servers **MUST** implement OAuth 2.0 Protected Resource Metadata ([RFC9728](https://datatracker.ietf.org/doc/html/rfc9728)).
   MCP clients **MUST** use OAuth 2.0 Protected Resource Metadata for authorization server discovery.

1. Authorization servers **MUST** provide OAuth 2.0 Authorization
   Server Metadata ([RFC8414](https://datatracker.ietf.org/doc/html/rfc8414)).
   MCP clients **MUST** use the OAuth 2.0 Authorization Server Metadata.

### Authorization Server Discovery

This section describes the mechanisms by which MCP servers advertise their associated
authorization servers to MCP clients, as well as the discovery process through which MCP
clients can determine authorization server endpoints and supported capabilities.

#### Authorization Server Location

MCP servers **MUST** implement the OAuth 2.0 Protected Resource Metadata ([RFC9728](https://datatracker.ietf.org/doc/html/rfc9728))
specification to indicate the locations of authorization servers. The Protected Resource Metadata document returned by the MCP server **MUST** include
the `authorization_servers` field containing at least one authorization server.

The specific use of `authorization_servers` is beyond the scope of this specification; implementers should consult
OAuth 2.0 Protected Resource Metadata ([RFC9728](https://datatracker.ietf.org/doc/html/rfc9728)) for
guidance on implementation details.

Implementors should note that Protected Resource Metadata documents can define multiple authorization servers. The responsibility for selecting which authorization server to use lies with the MCP client, following the guidelines specified in
[RFC9728 Section 7.6 "Authorization Servers"](https://datatracker.ietf.org/doc/html/rfc9728#name-authorization-servers).

MCP servers **MUST** use the HTTP header `WWW-Authenticate` when returning a _401 Unauthorized_ to indicate the location of the resource server metadata URL
as described in [RFC9728 Section 5.1 "WWW-Authenticate Response"](https://datatracker.ietf.org/doc/html/rfc9728#name-www-authenticate-response).

MCP clients **MUST** be able to parse `WWW-Authenticate` headers and respond appropriately to `HTTP 401 Unauthorized` responses from the MCP server.

#### Server Metadata Discovery

MCP clients **MUST** follow the OAuth 2.0 Authorization Server Metadata [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414)
specification to obtain the information required to interact with the authorization server.

#### Sequence Diagram

The following diagram outlines an example flow:

```mermaid
sequenceDiagram
    participant C as Client
    participant M as MCP Server (Resource Server)
    participant A as Authorization Server

    C->>M: MCP request without token
    M-->>C: HTTP 401 Unauthorized with WWW-Authenticate header
    Note over C: Extract resource_metadata<br />from WWW-Authenticate

    C->>M: GET /.well-known/oauth-protected-resource
    M-->>C: Resource metadata with authorization server URL
    Note over C: Validate RS metadata,<br />build AS metadata URL

    C->>A: GET /.well-known/oauth-authorization-server
    A-->>C: Authorization server metadata

    Note over C,A: OAuth 2.1 authorization flow happens here

    C->>A: Token request
    A-->>C: Access token

    C->>M: MCP request with access token
    M-->>C: MCP response
    Note over C,M: MCP communication continues with valid token
```

### Dynamic Client Registration

MCP clients and authorization servers **SHOULD** support the
OAuth 2.0 Dynamic Client Registration Protocol [RFC7591](https://datatracker.ietf.org/doc/html/rfc7591)
to allow MCP clients to obtain OAuth client IDs without user interaction. This provides a
standardized way for clients to automatically register with new authorization servers, which is crucial
for MCP because:

- Clients may not know all possible MCP servers and their authorization servers in advance.
- Manual registration would create friction for users.
- It enables seamless connection to new MCP servers and their authorization servers.
- Authorization servers can implement their own registration policies.

Any authorization servers that _do not_ support Dynamic Client Registration need to provide
alternative ways to obtain a client ID (and, if applicable, client credentials). For one of
these authorization servers, MCP clients will have to either:

1. Hardcode a client ID (and, if applicable, client credentials) specifically for the MCP client to use when
   interacting with that authorization server, or
2. Present a UI to users that allows them to enter these details, after registering an
   OAuth client themselves (e.g., through a configuration interface hosted by the
   server).

### Authorization Flow Steps

The complete Authorization flow proceeds as follows:

```mermaid
sequenceDiagram
    participant B as User-Agent (Browser)
    participant C as Client
    participant M as MCP Server (Resource Server)
    participant A as Authorization Server

    C->>M: MCP request without token
    M->>C: HTTP 401 Unauthorized with WWW-Authenticate header
    Note over C: Extract resource_metadata URL from WWW-Authenticate

    C->>M: Request Protected Resource Metadata
    M->>C: Return metadata

    Note over C: Parse metadata and extract authorization server(s)<br/>Client determines AS to use

    C->>A: GET /.well-known/oauth-authorization-server
    A->>C: Authorization server metadata response

    alt Dynamic client registration
        C->>A: POST /register
        A->>C: Client Credentials
    end

    Note over C: Generate PKCE parameters<br/>Include resource parameter
    C->>B: Open browser with authorization URL + code_challenge + resource
    B->>A: Authorization request with resource parameter
    Note over A: User authorizes
    A->>B: Redirect to callback with authorization code
    B->>C: Authorization code callback
    C->>A: Token request + code_verifier + resource
    A->>C: Access token (+ refresh token)
    C->>M: MCP request with access token
    M-->>C: MCP response
    Note over C,M: MCP communication continues with valid token
```

#### Resource Parameter Implementation

MCP clients **MUST** implement Resource Indicators for OAuth 2.0 as defined in [RFC 8707](https://www.rfc-editor.org/rfc/rfc8707.html)
to explicitly specify the target resource for which the token is being requested. The `resource` parameter:

1. **MUST** be included in both authorization requests and token requests.
2. **MUST** identify the MCP server that the client intends to use the token with.
3. **MUST** use the canonical URI of the MCP server as defined in [RFC 8707 Section 2](https://www.rfc-editor.org/rfc/rfc8707.html#name-access-token-request).

##### Canonical Server URI

For the purposes of this specification, the canonical URI of an MCP server is defined as the resource identifier as specified in
[RFC 8707 Section 2](https://www.rfc-editor.org/rfc/rfc8707.html#section-2) and aligns with the `resource` parameter in
[RFC 9728](https://datatracker.ietf.org/doc/html/rfc9728).

MCP clients **SHOULD** provide the most specific URI that they can for the MCP server they intend to access, following the guidance in [RFC 8707](https://www.rfc-editor.org/rfc/rfc8707). While the canonical form uses lowercase scheme and host components, implementations **SHOULD** accept uppercase scheme and host components for robustness and interoperability.

Examples of valid canonical URIs:

- `https://mcp.example.com/mcp`
- `https://mcp.example.com`
- `https://mcp.example.com:8443`
- `https://mcp.example.com/server/mcp` (when path component is necessary to identify individual MCP server)

Examples of invalid canonical URIs:

- `mcp.example.com` (missing scheme)
- `https://mcp.example.com#fragment` (contains fragment)

> **Note:** While both `https://mcp.example.com/` (with trailing slash) and `https://mcp.example.com` (without trailing slash) are technically valid absolute URIs according to [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986), implementations **SHOULD** consistently use the form without the trailing slash for better interoperability unless the trailing slash is semantically significant for the specific resource.

For example, if accessing an MCP server at `https://mcp.example.com`, the authorization request would include:

```
&resource=https%3A%2F%2Fmcp.example.com
```

MCP clients **MUST** send this parameter regardless of whether authorization servers support it.

### Access Token Usage

#### Token Requirements

Access token handling when making requests to MCP servers **MUST** conform to the requirements defined in
[OAuth 2.1 Section 5 "Resource Requests"](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5).
Specifically:

1. MCP client **MUST** use the Authorization request header field defined in
   [OAuth 2.1 Section 5.1.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5.1.1):

```
Authorization: Bearer <access-token>
```

Note that authorization **MUST** be included in every HTTP request from client to server,
even if they are part of the same logical session.

2. Access tokens **MUST NOT** be included in the URI query string

Example request:

```http
GET /mcp HTTP/1.1
Host: mcp.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

#### Token Handling

MCP servers, acting in their role as an OAuth 2.1 resource server, **MUST** validate access tokens as described in
[OAuth 2.1 Section 5.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5.2).
MCP servers **MUST** validate that access tokens were issued specifically for them as the intended audience,
according to [RFC 8707 Section 2](https://www.rfc-editor.org/rfc/rfc8707.html#section-2).
If validation fails, servers **MUST** respond according to
[OAuth 2.1 Section 5.3](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5.3)
error handling requirements. Invalid or expired tokens **MUST** receive a HTTP 401
response.

MCP clients **MUST NOT** send tokens to the MCP server other than ones issued by the MCP server's authorization server.

Authorization servers **MUST** only accept tokens that are valid for use with their
own resources.

MCP servers **MUST NOT** accept or transit any other tokens.

### Error Handling

Servers **MUST** return appropriate HTTP status codes for authorization errors:

| Status Code | Description  | Usage                                      |
| ----------- | ------------ | ------------------------------------------ |
| 401         | Unauthorized | Authorization required or token invalid    |
| 403         | Forbidden    | Invalid scopes or insufficient permissions |
| 400         | Bad Request  | Malformed authorization request            |

## Security Considerations

Implementations **MUST** follow OAuth 2.1 security best practices as laid out in [OAuth 2.1 Section 7. "Security Considerations"](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#name-security-considerations).

### Token Audience Binding and Validation

[RFC 8707](https://www.rfc-editor.org/rfc/rfc8707.html) Resource Indicators provide critical security benefits by binding tokens to their intended
audiences **when the Authorization Server supports the capability**. To enable current and future adoption:

- MCP clients **MUST** include the `resource` parameter in authorization and token requests as specified in the [Resource Parameter Implementation](#resource-parameter-implementation) section
- MCP servers **MUST** validate that tokens presented to them were specifically issued for their use

The [Security Best Practices document](/specification/2025-06-18/basic/security_best_practices#token-passthrough)
outlines why token audience validation is crucial and why token passthrough is explicitly forbidden.

### Token Theft

Attackers who obtain tokens stored by the client, or tokens cached or logged on the server can access protected resources with
requests that appear legitimate to resource servers.

Clients and servers **MUST** implement secure token storage and follow OAuth best practices,
as outlined in [OAuth 2.1, Section 7.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-7.1).

Authorization servers **SHOULD** issue short-lived access tokens to reduce the impact of leaked tokens.
For public clients, authorization servers **MUST** rotate refresh tokens as described in [OAuth 2.1 Section 4.3.1 "Refresh Token Grant"](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-4.3.1).

### Communication Security

Implementations **MUST** follow [OAuth 2.1 Section 1.5 "Communication Security"](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-1.5).

Specifically:

1. All authorization server endpoints **MUST** be served over HTTPS.
1. All redirect URIs **MUST** be either `localhost` or use HTTPS.

### Authorization Code Protection

An attacker who has gained access to an authorization code contained in an authorization response can try to redeem the authorization code for an access token or otherwise make use of the authorization code.
(Further described in [OAuth 2.1 Section 7.5](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-7.5))

To mitigate this, MCP clients **MUST** implement PKCE according to [OAuth 2.1 Section 7.5.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-7.5.2).
PKCE helps prevent authorization code interception and injection attacks by requiring clients to create a secret verifier-challenge pair, ensuring that only the original requestor can exchange an authorization code for tokens.

### Open Redirection

An attacker may craft malicious redirect URIs to direct users to phishing sites.

MCP clients **MUST** have redirect URIs registered with the authorization server.

Authorization servers **MUST** validate exact redirect URIs against pre-registered values to prevent redirection attacks.

MCP clients **SHOULD** use and verify state parameters in the authorization code flow
and discard any results that do not include or have a mismatch with the original state.

Authorization servers **MUST** take precautions to prevent redirecting user agents to untrusted URI's, following suggestions laid out in [OAuth 2.1 Section 7.12.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-7.12.2)

Authorization servers **SHOULD** only automatically redirect the user agent if it trusts the redirection URI. If the URI is not trusted, the authorization server MAY inform the user and rely on the user to make the correct decision.

### Confused Deputy Problem

Attackers can exploit MCP servers acting as intermediaries to third-party APIs, leading to [confused deputy vulnerabilities](/specification/2025-06-18/basic/security_best_practices#confused-deputy-problem).
By using stolen authorization codes, they can obtain access tokens without user consent.

MCP proxy servers using static client IDs **MUST** obtain user consent for each dynamically
registered client before forwarding to third-party authorization servers (which may require additional consent).

### Access Token Privilege Restriction

An attacker can gain unauthorized access or otherwise compromise a MCP server if the server accepts tokens issued for other resources.

This vulnerability has two critical dimensions:

1. **Audience validation failures.** When an MCP server doesn't verify that tokens were specifically intended for it (for example, via the audience claim, as mentioned in [RFC9068](https://www.rfc-editor.org/rfc/rfc9068.html)), it may accept tokens originally issued for other services. This breaks a fundamental OAuth security boundary, allowing attackers to reuse legitimate tokens across different services than intended.
2. **Token passthrough.** If the MCP server not only accepts tokens with incorrect audiences but also forwards these unmodified tokens to downstream services, it can potentially cause the ["confused deputy" problem](#confused-deputy-problem), where the downstream API may incorrectly trust the token as if it came from the MCP server or assume the token was validated by the upstream API. See the [Token Passthrough section](/specification/2025-06-18/basic/security_best_practices#token-passthrough) of the Security Best Practices guide for additional details.

MCP servers **MUST** validate access tokens before processing the request, ensuring the access token is issued specifically for the MCP server, and take all necessary steps to ensure no data is returned to unauthorized parties.

A MCP server **MUST** follow the guidelines in [OAuth 2.1 - Section 5.2](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-12.html#section-5.2) to validate inbound tokens.

MCP servers **MUST** only accept tokens specifically intended for themselves and **MUST** reject tokens that do not include them in the audience claim or otherwise verify that they are the intended recipient of the token. See the [Security Best Practices Token Passthrough section](/specification/2025-06-18/basic/security_best_practices#token-passthrough) for details.

If the MCP server makes requests to upstream APIs, it may act as an OAuth client to them. The access token used at the upstream API is a seperate token, issued by the upstream authorization server. The MCP server **MUST NOT** pass through the token it received from the MCP client.

MCP clients **MUST** implement and use the `resource` parameter as defined in [RFC 8707 - Resource Indicators for OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8707.html)
to explicitly specify the target resource for which the token is being requested. This requirement aligns with the recommendation in
[RFC 9728 Section 7.4](https://datatracker.ietf.org/doc/html/rfc9728#section-7.4). This ensures that access tokens are bound to their intended resources and
cannot be misused across different services.

--- END OF FILE 2025-06-18/basic/authorization.mdx ---


--- START OF FILE 2025-06-18/basic/index.mdx ---
---
title: Overview
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol consists of several key components that work together:

- **Base Protocol**: Core JSON-RPC message types
- **Lifecycle Management**: Connection initialization, capability negotiation, and
  session control
- **Authorization**: Authentication and authorization framework for HTTP-based transports
- **Server Features**: Resources, prompts, and tools exposed by servers
- **Client Features**: Sampling and root directory lists provided by clients
- **Utilities**: Cross-cutting concerns like logging and argument completion

All implementations **MUST** support the base protocol and lifecycle management
components. Other components **MAY** be implemented based on the specific needs of the
application.

These protocol layers establish clear separation of concerns while enabling rich
interactions between clients and servers. The modular design allows implementations to
support exactly the features they need.

## Messages

All messages between MCP clients and servers **MUST** follow the
[JSON-RPC 2.0](https://www.jsonrpc.org/specification) specification. The protocol defines
these types of messages:

### Requests

Requests are sent from the client to the server or vice versa, to initiate an operation.

```typescript
{
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

- Requests **MUST** include a string or integer ID.
- Unlike base JSON-RPC, the ID **MUST NOT** be `null`.
- The request ID **MUST NOT** have been previously used by the requestor within the same
  session.

### Responses

Responses are sent in reply to requests, containing the result or error of the operation.

```typescript
{
  jsonrpc: "2.0";
  id: string | number;
  result?: {
    [key: string]: unknown;
  }
  error?: {
    code: number;
    message: string;
    data?: unknown;
  }
}
```

- Responses **MUST** include the same ID as the request they correspond to.
- **Responses** are further sub-categorized as either **successful results** or
  **errors**. Either a `result` or an `error` **MUST** be set. A response **MUST NOT**
  set both.
- Results **MAY** follow any JSON object structure, while errors **MUST** include an
  error code and message at minimum.
- Error codes **MUST** be integers.

### Notifications

Notifications are sent from the client to the server or vice versa, as a one-way message.
The receiver **MUST NOT** send a response.

```typescript
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

- Notifications **MUST NOT** include an ID.

## Auth

MCP provides an [Authorization](/specification/2025-06-18/basic/authorization) framework for use with HTTP.
Implementations using an HTTP-based transport **SHOULD** conform to this specification,
whereas implementations using STDIO transport **SHOULD NOT** follow this specification,
and instead retrieve credentials from the environment.

Additionally, clients and servers **MAY** negotiate their own custom authentication and
authorization strategies.

For further discussions and contributions to the evolution of MCPâ€™s auth mechanisms, join
us in
[GitHub Discussions](https://github.com/modelcontextprotocol/specification/discussions)
to help shape the future of the protocol!

## Schema

The full specification of the protocol is defined as a
[TypeScript schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-06-18/schema.ts).
This is the source of truth for all protocol messages and structures.

There is also a
[JSON Schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-06-18/schema.json),
which is automatically generated from the TypeScript source of truth, for use with
various automated tooling.

### General fields

#### `_meta`

The `_meta` property/parameter is reserved by MCP to allow clients and servers
to attach additional metadata to their interactions.

Certain key names are reserved by MCP for protocol-level metadata, as specified below;
implementations MUST NOT make assumptions about values at these keys.

Additionally, definitions in the [schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-06-18/schema.ts)
may reserve particular names for purpose-specific metadata, as declared in those definitions.

**Key name format:** valid `_meta` key names have two segments: an optional **prefix**, and a **name**.

**Prefix:**

- If specified, MUST be a series of labels separated by dots (`.`), followed by a slash (`/`).
  - Labels MUST start with a letter and end with a letter or digit; interior characters can be letters, digits, or hyphens (`-`).
- Any prefix beginning with zero or more valid labels, followed by `modelcontextprotocol` or `mcp`, followed by any valid label,
  is **reserved** for MCP use.
  - For example: `modelcontextprotocol.io/`, `mcp.dev/`, `api.modelcontextprotocol.org/`, and `tools.mcp.com/` are all reserved.

**Name:**

- Unless empty, MUST begin and end with an alphanumeric character (`[a-z0-9A-Z]`).
- MAY contain hyphens (`-`), underscores (`_`), dots (`.`), and alphanumerics in between.

--- END OF FILE 2025-06-18/basic/index.mdx ---


--- START OF FILE 2025-06-18/basic/lifecycle.mdx ---
---
title: Lifecycle
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol (MCP) defines a rigorous lifecycle for client-server
connections that ensures proper capability negotiation and state management.

1. **Initialization**: Capability negotiation and protocol version agreement
2. **Operation**: Normal protocol communication
3. **Shutdown**: Graceful termination of the connection

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Initialization Phase
    activate Client
    Client->>+Server: initialize request
    Server-->>Client: initialize response
    Client--)Server: initialized notification

    Note over Client,Server: Operation Phase
    rect rgb(200, 220, 250)
        note over Client,Server: Normal protocol operations
    end

    Note over Client,Server: Shutdown
    Client--)-Server: Disconnect
    deactivate Server
    Note over Client,Server: Connection closed
```

## Lifecycle Phases

### Initialization

The initialization phase **MUST** be the first interaction between client and server.
During this phase, the client and server:

- Establish protocol version compatibility
- Exchange and negotiate capabilities
- Share implementation details

The client **MUST** initiate this phase by sending an `initialize` request containing:

- Protocol version supported
- Client capabilities
- Client implementation information

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "roots": {
        "listChanged": true
      },
      "sampling": {},
      "elicitation": {}
    },
    "clientInfo": {
      "name": "ExampleClient",
      "title": "Example Client Display Name",
      "version": "1.0.0"
    }
  }
}
```

The server **MUST** respond with its own capabilities and information:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "logging": {},
      "prompts": {
        "listChanged": true
      },
      "resources": {
        "subscribe": true,
        "listChanged": true
      },
      "tools": {
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "ExampleServer",
      "title": "Example Server Display Name",
      "version": "1.0.0"
    },
    "instructions": "Optional instructions for the client"
  }
}
```

After successful initialization, the client **MUST** send an `initialized` notification
to indicate it is ready to begin normal operations:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized"
}
```

- The client **SHOULD NOT** send requests other than
  [pings](/specification/2025-06-18/basic/utilities/ping) before the server has responded to the
  `initialize` request.
- The server **SHOULD NOT** send requests other than
  [pings](/specification/2025-06-18/basic/utilities/ping) and
  [logging](/specification/2025-06-18/server/utilities/logging) before receiving the `initialized`
  notification.

#### Version Negotiation

In the `initialize` request, the client **MUST** send a protocol version it supports.
This **SHOULD** be the _latest_ version supported by the client.

If the server supports the requested protocol version, it **MUST** respond with the same
version. Otherwise, the server **MUST** respond with another protocol version it
supports. This **SHOULD** be the _latest_ version supported by the server.

If the client does not support the version in the server's response, it **SHOULD**
disconnect.

<Note>
If using HTTP, the client **MUST** include the `MCP-Protocol-Version:
<protocol-version>` HTTP header on all subsequent requests to the MCP
server.
For details, see [the Protocol Version Header section in Transports](/specification/2025-06-18/basic/transports#protocol-version-header).
</Note>

#### Capability Negotiation

Client and server capabilities establish which optional protocol features will be
available during the session.

Key capabilities include:

| Category | Capability     | Description                                                                               |
| -------- | -------------- | ----------------------------------------------------------------------------------------- |
| Client   | `roots`        | Ability to provide filesystem [roots](/specification/2025-06-18/client/roots)             |
| Client   | `sampling`     | Support for LLM [sampling](/specification/2025-06-18/client/sampling) requests            |
| Client   | `elicitation`  | Support for server [elicitation](/specification/2025-06-18/client/elicitation) requests   |
| Client   | `experimental` | Describes support for non-standard experimental features                                  |
| Server   | `prompts`      | Offers [prompt templates](/specification/2025-06-18/server/prompts)                       |
| Server   | `resources`    | Provides readable [resources](/specification/2025-06-18/server/resources)                 |
| Server   | `tools`        | Exposes callable [tools](/specification/2025-06-18/server/tools)                          |
| Server   | `logging`      | Emits structured [log messages](/specification/2025-06-18/server/utilities/logging)       |
| Server   | `completions`  | Supports argument [autocompletion](/specification/2025-06-18/server/utilities/completion) |
| Server   | `experimental` | Describes support for non-standard experimental features                                  |

Capability objects can describe sub-capabilities like:

- `listChanged`: Support for list change notifications (for prompts, resources, and
  tools)
- `subscribe`: Support for subscribing to individual items' changes (resources only)

### Operation

During the operation phase, the client and server exchange messages according to the
negotiated capabilities.

Both parties **MUST**:

- Respect the negotiated protocol version
- Only use capabilities that were successfully negotiated

### Shutdown

During the shutdown phase, one side (usually the client) cleanly terminates the protocol
connection. No specific shutdown messages are definedâ€”instead, the underlying transport
mechanism should be used to signal connection termination:

#### stdio

For the stdio [transport](/specification/2025-06-18/basic/transports), the client **SHOULD** initiate
shutdown by:

1. First, closing the input stream to the child process (the server)
2. Waiting for the server to exit, or sending `SIGTERM` if the server does not exit
   within a reasonable time
3. Sending `SIGKILL` if the server does not exit within a reasonable time after `SIGTERM`

The server **MAY** initiate shutdown by closing its output stream to the client and
exiting.

#### HTTP

For HTTP [transports](/specification/2025-06-18/basic/transports), shutdown is indicated by closing the
associated HTTP connection(s).

## Timeouts

Implementations **SHOULD** establish timeouts for all sent requests, to prevent hung
connections and resource exhaustion. When the request has not received a success or error
response within the timeout period, the sender **SHOULD** issue a [cancellation
notification](/specification/2025-06-18/basic/utilities/cancellation) for that request and stop waiting for
a response.

SDKs and other middleware **SHOULD** allow these timeouts to be configured on a
per-request basis.

Implementations **MAY** choose to reset the timeout clock when receiving a [progress
notification](/specification/2025-06-18/basic/utilities/progress) corresponding to the request, as this
implies that work is actually happening. However, implementations **SHOULD** always
enforce a maximum timeout, regardless of progress notifications, to limit the impact of a
misbehaving client or server.

## Error Handling

Implementations **SHOULD** be prepared to handle these error cases:

- Protocol version mismatch
- Failure to negotiate required capabilities
- Request [timeouts](#timeouts)

Example initialization error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Unsupported protocol version",
    "data": {
      "supported": ["2024-11-05"],
      "requested": "1.0.0"
    }
  }
}
```

--- END OF FILE 2025-06-18/basic/lifecycle.mdx ---


--- START OF FILE 2025-06-18/basic/security_best_practices.mdx ---
---
title: Security Best Practices
---

<div id="enable-section-numbers" />

## Introduction

### Purpose and Scope

This document provides security considerations for the Model Context Protocol (MCP), complementing the MCP Authorization specification. This document identifies security risks, attack vectors, and best practices specific to MCP implementations.

The primary audience for this document includes developers implementing MCP authorization flows, MCP server operators, and security professionals evaluating MCP-based systems. This document should be read alongside the MCP Authorization specification and [OAuth 2.0 security best practices](https://datatracker.ietf.org/doc/html/rfc9700).

## Attacks and Mitigations

This section gives a detailed description of attacks on MCP implementations, along with potential countermeasures.

### Confused Deputy Problem

Attackers can exploit MCP servers proxying other resource servers, creating "[confused deputy](https://en.wikipedia.org/wiki/Confused_deputy_problem)" vulnerabilities.

#### Terminology

**MCP Proxy Server**
: An MCP server that connects MCP clients to third-party APIs, offering MCP features while delegating operations and acting as a single OAuth client to the third-party API server.

**Third-Party Authorization Server**
: Authorization server that protects the third-party API. It may lack dynamic client registration support, requiring MCP proxy to use a static client ID for all requests.

**Third-Party API**
: The protected resource server that provides the actual API functionality. Access to this
API requires tokens issued by the third-party authorization server.

**Static Client ID**
: A fixed OAuth 2.0 client identifier used by the MCP proxy server when communicating with
the third-party authorization server. This Client ID refers to the MCP server acting as a client
to the Third-Party API. It is the same value for all MCP server to Third-Party API interactions regardless of
which MCP client initiated the request.

#### Architecture and Attack Flows

##### Normal OAuth proxy usage (preserves user consent)

```mermaid
sequenceDiagram
    participant UA as User-Agent (Browser)
    participant MC as MCP Client
    participant M as MCP Proxy Server
    participant TAS as Third-Party Authorization Server

    Note over UA,M: Initial Auth flow completed

    Note over UA,TAS: Step 1: Legitimate user consent for Third Party Server

    M->>UA: Redirect to third party authorization server
    UA->>TAS: Authorization request (client_id: mcp-proxy)
    TAS->>UA: Authorization consent screen
    Note over UA: Review consent screen
    UA->>TAS: Approve
    TAS->>UA: Set consent cookie for client ID: mcp-proxy
    TAS->>UA: 3P Authorization code + redirect to mcp-proxy-server.com
    UA->>M: 3P Authorization code
    Note over M,TAS: Exchange 3P code for 3P token
    Note over M: Generate MCP authorization code
    M->>UA: Redirect to MCP Client with MCP authorization code

    Note over M,UA: Exchange code for token, etc.
```

##### Malicious OAuth proxy usage (skips user consent)

```mermaid
sequenceDiagram
    participant UA as User-Agent (Browser)
    participant M as MCP Proxy Server
    participant TAS as Third-Party Authorization Server
    participant A as Attacker


    Note over UA,A: Step 2: Attack (leveraging existing cookie, skipping consent)
    A->>M: Dynamically register malicious client, redirect_uri: attacker.com
    A->>UA: Sends malicious link
    UA->>TAS: Authorization request (client_id: mcp-proxy) + consent cookie
    rect rgba(255, 17, 0, 0.67)
    TAS->>TAS: Cookie present, consent skipped
    end

   TAS->>UA: 3P Authorization code + redirect to mcp-proxy-server.com
   UA->>M: 3P Authorization code
   Note over M,TAS: Exchange 3P code for 3P token
   Note over M: Generate MCP authorization code
   M->>UA: Redirect to attacker.com with MCP Authorization code
   UA->>A: MCP Authorization code delivered to attacker.com
   Note over M,A: Attacker exchanges MCP code for MCP token
   A->>M: Attacker impersonates user to MCP server
```

#### Attack Description

When an MCP proxy server uses a static client ID to authenticate with a third-party
authorization server that does not support dynamic client registration, the following
attack becomes possible:

1. A user authenticates normally through the MCP proxy server to access the third-party API
2. During this flow, the third-party authorization server sets a cookie on the user agent
   indicating consent for the static client ID
3. An attacker later sends the user a malicious link containing a crafted authorization request which contains a malicious redirect URI along with a new dynamically registered client ID
4. When the user clicks the link, their browser still has the consent cookie from the previous legitimate request
5. The third-party authorization server detects the cookie and skips the consent screen
6. The MCP authorization code is redirected to the attacker's server (specified in the crafted redirect_uri during dynamic client registration)
7. The attacker exchanges the stolen authorization code for access tokens for the MCP server without the user's explicit approval
8. Attacker now has access to the third-party API as the compromised user

#### Mitigation

MCP proxy servers using static client IDs **MUST** obtain user consent for each dynamically
registered client before forwarding to third-party authorization servers (which may require additional consent).

### Token Passthrough

"Token passthrough" is an anti-pattern where an MCP server accepts tokens from an MCP client without validating that the tokens were properly issued _to the MCP server_ and "passing them through" to the downstream API.

#### Risks

Token passthrough is explicitly forbidden in the [authorization specification](/specification/2025-06-18/basic/authorization) as it introduces a number of security risks, that include:

- **Security Control Circumvention**
  - The MCP Server or downstream APIs might implement important security controls like rate limiting, request validation, or traffic monitoring, that depend on the token audience or other credential constraints. If clients can obtain and use tokens directly with the downstream APIs without the MCP server validating them properly or ensuring that the tokens are issued for the right service, they bypass these controls.
- **Accountability and Audit Trail Issues**
  - The MCP Server will be unable to identify or distinguish between MCP Clients when clients are calling with an upstream-issued access token which may be opaque to the MCP Server.
  - The downstream Resource Serverâ€™s logs may show requests that appear to come from a different source with a different identity, rather than the MCP server that is actually forwarding the tokens.
  - Both factors make incident investigation, controls, and auditing more difficult.
  - If the MCP Server passes tokens without validating their claims (e.g., roles, privileges, or audience) or other metadata, a malicious actor in possession of a stolen token can use the server as a proxy for data exfiltration.
- **Trust Boundary Issues**
  - The downstream Resource Server grants trust to specific entities. This trust might include assumptions about origin or client behavior patterns. Breaking this trust boundary could lead to unexpected issues.
  - If the token is accepted by multiple services without proper validation, an attacker compromising one service can use the token to access other connected services.
- **Future Compatibility Risk**
  - Even if an MCP Server starts as a "pure proxy" today, it might need to add security controls later. Starting with proper token audience separation makes it easier to evolve the security model.

#### Mitigation

MCP servers **MUST NOT** accept any tokens that were not explicitly issued for the MCP server.

### Session Hijacking

Session hijacking is an attack vector where a client is provided a session ID by the server, and an unauthorized party is able to obtain and use that same session ID to impersonate the original client and perform unauthorized actions on their behalf.

#### Session Hijack Prompt Injection

```mermaid
sequenceDiagram
    participant Client
    participant ServerA
    participant Queue
    participant ServerB
    participant Attacker

    Client->>ServerA: Initialize (connect to streamable HTTP server)
    ServerA-->>Client: Respond with session ID

    Attacker->>ServerB: Access/guess session ID
    Note right of Attacker: Attacker knows/guesses session ID

    Attacker->>ServerB: Trigger event (malicious payload, using session ID)
    ServerB->>Queue: Enqueue event (keyed by session ID)

    ServerA->>Queue: Poll for events (using session ID)
    Queue-->>ServerA: Event data (malicious payload)

    ServerA-->>Client: Async response (malicious payload)
    Client->>Client: Acts based on malicious payload
```

#### Session Hijack Impersonation

```mermaid
sequenceDiagram
    participant Client
    participant Server
    participant Attacker

    Client->>Server: Initialize (login/authenticate)
    Server-->>Client: Respond with session ID (persistent session created)

    Attacker->>Server: Access/guess session ID
    Note right of Attacker: Attacker knows/guesses session ID

    Attacker->>Server: Make API call (using session ID, no re-auth)
    Server-->>Attacker: Respond as if Attacker is Client (session hijack)
```

#### Attack Description

When you have multiple stateful HTTP servers that handle MCP requests, the following attack vectors are possible:

**Session Hijack Prompt Injection**

1. The client connects to **Server A** and receives a session ID.
1. The attacker obtains an existing session ID and sends a malicious event to **Server B** with said session ID.

   - When a server supports [redelivery/resumable streams](/specification/2025-06-18/basic/transports#resumability-and-redelivery), deliberately terminating the request before receiving the response could lead to it being resumed by the original client via the GET request for server sent events.
   - If a particular server initiates server sent events as a consequence of a tool call such as a `notifications/tools/list_changed`, where it is possible to affect the tools that are offered by the server, a client could end up with tools that they were not aware were enabled.

1. **Server B** enqueues the event (associated with session ID) into a shared queue.
1. **Server A** polls the queue for events using the session ID and retrieves the malicious payload.
1. **Server A** sends the malicious payload to the client as an asynchronous or resumed response.
1. The client receives and acts on the malicious payload, leading to potential compromise.

**Session Hijack Impersonation**

1. The MCP client authenticates with the MCP server, creating a persistent session ID.
2. The attacker obtains the session ID.
3. The attacker makes calls to the MCP server using the session ID.
4. MCP server does not check for additional authorization and treats the attacker as a legitimate user, allowing unauthorized access or actions.

#### Mitigation

To prevent session hijacking and event injection attacks, the following mitigations should be implemented:

MCP servers that implement authorization **MUST** verify all inbound requests.
MCP Servers **MUST NOT** use sessions for authentication.

MCP servers **MUST** use secure, non-deterministic session IDs.
Generated session IDs (e.g., UUIDs) **SHOULD** use secure random number generators. Avoid predictable or sequential session identifiers that could be guessed by an attacker. Rotating or expiring session IDs can also reduce the risk.

MCP servers **SHOULD** bind session IDs to user-specific information.
When storing or transmitting session-related data (e.g., in a queue), combine the session ID with information unique to the authorized user, such as their internal user ID. Use a key format like `<user_id>:<session_id>`. This ensures that even if an attacker guesses a session ID, they cannot impersonate another user as the user ID is derived from the user token and not provided by the client.

MCP servers can optionally leverage additional unique identifiers.

--- END OF FILE 2025-06-18/basic/security_best_practices.mdx ---


--- START OF FILE 2025-06-18/basic/transports.mdx ---
---
title: Transports
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

MCP uses JSON-RPC to encode messages. JSON-RPC messages **MUST** be UTF-8 encoded.

The protocol currently defines two standard transport mechanisms for client-server
communication:

1. [stdio](#stdio), communication over standard in and standard out
2. [Streamable HTTP](#streamable-http)

Clients **SHOULD** support stdio whenever possible.

It is also possible for clients and servers to implement
[custom transports](#custom-transports) in a pluggable fashion.

## stdio

In the **stdio** transport:

- The client launches the MCP server as a subprocess.
- The server reads JSON-RPC messages from its standard input (`stdin`) and sends messages
  to its standard output (`stdout`).
- Messages are individual JSON-RPC requests, notifications, or responses.
- Messages are delimited by newlines, and **MUST NOT** contain embedded newlines.
- The server **MAY** write UTF-8 strings to its standard error (`stderr`) for logging
  purposes. Clients **MAY** capture, forward, or ignore this logging.
- The server **MUST NOT** write anything to its `stdout` that is not a valid MCP message.
- The client **MUST NOT** write anything to the server's `stdin` that is not a valid MCP
  message.

```mermaid
sequenceDiagram
    participant Client
    participant Server Process

    Client->>+Server Process: Launch subprocess
    loop Message Exchange
        Client->>Server Process: Write to stdin
        Server Process->>Client: Write to stdout
        Server Process--)Client: Optional logs on stderr
    end
    Client->>Server Process: Close stdin, terminate subprocess
    deactivate Server Process
```

## Streamable HTTP

<Info>

This replaces the [HTTP+SSE
transport](/specification/2024-11-05/basic/transports#http-with-sse) from
protocol version 2024-11-05. See the [backwards compatibility](#backwards-compatibility)
guide below.

</Info>

In the **Streamable HTTP** transport, the server operates as an independent process that
can handle multiple client connections. This transport uses HTTP POST and GET requests.
Server can optionally make use of
[Server-Sent Events](https://en.wikipedia.org/wiki/Server-sent_events) (SSE) to stream
multiple server messages. This permits basic MCP servers, as well as more feature-rich
servers supporting streaming and server-to-client notifications and requests.

The server **MUST** provide a single HTTP endpoint path (hereafter referred to as the
**MCP endpoint**) that supports both POST and GET methods. For example, this could be a
URL like `https://example.com/mcp`.

#### Security Warning

When implementing Streamable HTTP transport:

1. Servers **MUST** validate the `Origin` header on all incoming connections to prevent DNS rebinding attacks
2. When running locally, servers **SHOULD** bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)
3. Servers **SHOULD** implement proper authentication for all connections

Without these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.

### Sending Messages to the Server

Every JSON-RPC message sent from the client **MUST** be a new HTTP POST request to the
MCP endpoint.

1. The client **MUST** use HTTP POST to send JSON-RPC messages to the MCP endpoint.
2. The client **MUST** include an `Accept` header, listing both `application/json` and
   `text/event-stream` as supported content types.
3. The body of the POST request **MUST** be a single JSON-RPC _request_, _notification_, or _response_.
4. If the input is a JSON-RPC _response_ or _notification_:
   - If the server accepts the input, the server **MUST** return HTTP status code 202
     Accepted with no body.
   - If the server cannot accept the input, it **MUST** return an HTTP error status code
     (e.g., 400 Bad Request). The HTTP response body **MAY** comprise a JSON-RPC _error
     response_ that has no `id`.
5. If the input is a JSON-RPC _request_, the server **MUST** either
   return `Content-Type: text/event-stream`, to initiate an SSE stream, or
   `Content-Type: application/json`, to return one JSON object. The client **MUST**
   support both these cases.
6. If the server initiates an SSE stream:
   - The SSE stream **SHOULD** eventually include JSON-RPC _response_ for the
     JSON-RPC _request_ sent in the POST body.
   - The server **MAY** send JSON-RPC _requests_ and _notifications_ before sending the
     JSON-RPC _response_. These messages **SHOULD** relate to the originating client
     _request_.
   - The server **SHOULD NOT** close the SSE stream before sending the JSON-RPC _response_
     for the received JSON-RPC _request_, unless the [session](#session-management)
     expires.
   - After the JSON-RPC _response_ has been sent, the server **SHOULD** close the SSE
     stream.
   - Disconnection **MAY** occur at any time (e.g., due to network conditions).
     Therefore:
     - Disconnection **SHOULD NOT** be interpreted as the client cancelling its request.
     - To cancel, the client **SHOULD** explicitly send an MCP `CancelledNotification`.
     - To avoid message loss due to disconnection, the server **MAY** make the stream
       [resumable](#resumability-and-redelivery).

### Listening for Messages from the Server

1. The client **MAY** issue an HTTP GET to the MCP endpoint. This can be used to open an
   SSE stream, allowing the server to communicate to the client, without the client first
   sending data via HTTP POST.
2. The client **MUST** include an `Accept` header, listing `text/event-stream` as a
   supported content type.
3. The server **MUST** either return `Content-Type: text/event-stream` in response to
   this HTTP GET, or else return HTTP 405 Method Not Allowed, indicating that the server
   does not offer an SSE stream at this endpoint.
4. If the server initiates an SSE stream:
   - The server **MAY** send JSON-RPC _requests_ and _notifications_ on the stream.
   - These messages **SHOULD** be unrelated to any concurrently-running JSON-RPC
     _request_ from the client.
   - The server **MUST NOT** send a JSON-RPC _response_ on the stream **unless**
     [resuming](#resumability-and-redelivery) a stream associated with a previous client
     request.
   - The server **MAY** close the SSE stream at any time.
   - The client **MAY** close the SSE stream at any time.

### Multiple Connections

1. The client **MAY** remain connected to multiple SSE streams simultaneously.
2. The server **MUST** send each of its JSON-RPC messages on only one of the connected
   streams; that is, it **MUST NOT** broadcast the same message across multiple streams.
   - The risk of message loss **MAY** be mitigated by making the stream
     [resumable](#resumability-and-redelivery).

### Resumability and Redelivery

To support resuming broken connections, and redelivering messages that might otherwise be
lost:

1. Servers **MAY** attach an `id` field to their SSE events, as described in the
   [SSE standard](https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation).
   - If present, the ID **MUST** be globally unique across all streams within that
     [session](#session-management)â€”or all streams with that specific client, if session
     management is not in use.
2. If the client wishes to resume after a broken connection, it **SHOULD** issue an HTTP
   GET to the MCP endpoint, and include the
   [`Last-Event-ID`](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-last-event-id-header)
   header to indicate the last event ID it received.
   - The server **MAY** use this header to replay messages that would have been sent
     after the last event ID, _on the stream that was disconnected_, and to resume the
     stream from that point.
   - The server **MUST NOT** replay messages that would have been delivered on a
     different stream.

In other words, these event IDs should be assigned by servers on a _per-stream_ basis, to
act as a cursor within that particular stream.

### Session Management

An MCP "session" consists of logically related interactions between a client and a
server, beginning with the [initialization phase](/specification/2025-06-18/basic/lifecycle). To support
servers which want to establish stateful sessions:

1. A server using the Streamable HTTP transport **MAY** assign a session ID at
   initialization time, by including it in an `Mcp-Session-Id` header on the HTTP
   response containing the `InitializeResult`.
   - The session ID **SHOULD** be globally unique and cryptographically secure (e.g., a
     securely generated UUID, a JWT, or a cryptographic hash).
   - The session ID **MUST** only contain visible ASCII characters (ranging from 0x21 to
     0x7E).
2. If an `Mcp-Session-Id` is returned by the server during initialization, clients using
   the Streamable HTTP transport **MUST** include it in the `Mcp-Session-Id` header on
   all of their subsequent HTTP requests.
   - Servers that require a session ID **SHOULD** respond to requests without an
     `Mcp-Session-Id` header (other than initialization) with HTTP 400 Bad Request.
3. The server **MAY** terminate the session at any time, after which it **MUST** respond
   to requests containing that session ID with HTTP 404 Not Found.
4. When a client receives HTTP 404 in response to a request containing an
   `Mcp-Session-Id`, it **MUST** start a new session by sending a new `InitializeRequest`
   without a session ID attached.
5. Clients that no longer need a particular session (e.g., because the user is leaving
   the client application) **SHOULD** send an HTTP DELETE to the MCP endpoint with the
   `Mcp-Session-Id` header, to explicitly terminate the session.
   - The server **MAY** respond to this request with HTTP 405 Method Not Allowed,
     indicating that the server does not allow clients to terminate sessions.

### Sequence Diagram

```mermaid
sequenceDiagram
    participant Client
    participant Server

    note over Client, Server: initialization

    Client->>+Server: POST InitializeRequest
    Server->>-Client: InitializeResponse<br>Mcp-Session-Id: 1868a90c...

    Client->>+Server: POST InitializedNotification<br>Mcp-Session-Id: 1868a90c...
    Server->>-Client: 202 Accepted

    note over Client, Server: client requests
    Client->>+Server: POST ... request ...<br>Mcp-Session-Id: 1868a90c...

    alt single HTTP response
      Server->>Client: ... response ...
    else server opens SSE stream
      loop while connection remains open
          Server-)Client: ... SSE messages from server ...
      end
      Server-)Client: SSE event: ... response ...
    end
    deactivate Server

    note over Client, Server: client notifications/responses
    Client->>+Server: POST ... notification/response ...<br>Mcp-Session-Id: 1868a90c...
    Server->>-Client: 202 Accepted

    note over Client, Server: server requests
    Client->>+Server: GET<br>Mcp-Session-Id: 1868a90c...
    loop while connection remains open
        Server-)Client: ... SSE messages from server ...
    end
    deactivate Server

```

### Protocol Version Header

If using HTTP, the client **MUST** include the `MCP-Protocol-Version:
<protocol-version>` HTTP header on all subsequent requests to the MCP
server, allowing the MCP server to respond based on the MCP protocol version.

For example: `MCP-Protocol-Version: 2025-06-18`

The protocol version sent by the client **SHOULD** be the one [negotiated during
initialization](/specification/2025-06-18/basic/lifecycle#version-negotiation).

For backwards compatibility, if the server does _not_ receive an `MCP-Protocol-Version`
header, and has no other way to identify the version - for example, by relying on the
protocol version negotiated during initialization - the server **SHOULD** assume protocol
version `2025-03-26`.

If the server receives a request with an invalid or unsupported
`MCP-Protocol-Version`, it **MUST** respond with `400 Bad Request`.

### Backwards Compatibility

Clients and servers can maintain backwards compatibility with the deprecated [HTTP+SSE
transport](/specification/2024-11-05/basic/transports#http-with-sse) (from
protocol version 2024-11-05) as follows:

**Servers** wanting to support older clients should:

- Continue to host both the SSE and POST endpoints of the old transport, alongside the
  new "MCP endpoint" defined for the Streamable HTTP transport.
  - It is also possible to combine the old POST endpoint and the new MCP endpoint, but
    this may introduce unneeded complexity.

**Clients** wanting to support older servers should:

1. Accept an MCP server URL from the user, which may point to either a server using the
   old transport or the new transport.
2. Attempt to POST an `InitializeRequest` to the server URL, with an `Accept` header as
   defined above:
   - If it succeeds, the client can assume this is a server supporting the new Streamable
     HTTP transport.
   - If it fails with an HTTP 4xx status code (e.g., 405 Method Not Allowed or 404 Not
     Found):
     - Issue a GET request to the server URL, expecting that this will open an SSE stream
       and return an `endpoint` event as the first event.
     - When the `endpoint` event arrives, the client can assume this is a server running
       the old HTTP+SSE transport, and should use that transport for all subsequent
       communication.

## Custom Transports

Clients and servers **MAY** implement additional custom transport mechanisms to suit
their specific needs. The protocol is transport-agnostic and can be implemented over any
communication channel that supports bidirectional message exchange.

Implementers who choose to support custom transports **MUST** ensure they preserve the
JSON-RPC message format and lifecycle requirements defined by MCP. Custom transports
**SHOULD** document their specific connection establishment and message exchange patterns
to aid interoperability.

--- END OF FILE 2025-06-18/basic/transports.mdx ---


--- START OF FILE 2025-06-18/client/elicitation.mdx ---
---
title: Elicitation
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

<Note>

Elicitation is newly introduced in this version of the MCP specification and its design may evolve in future protocol versions.

</Note>

The Model Context Protocol (MCP) provides a standardized way for servers to request additional
information from users through the client during interactions. This flow allows clients to
maintain control over user interactions and data sharing while enabling servers to gather
necessary information dynamically.
Servers request structured data from users with JSON schemas to validate responses.

## User Interaction Model

Elicitation in MCP allows servers to implement interactive workflows by enabling user input
requests to occur _nested_ inside other MCP server features.

Implementations are free to expose elicitation through any interface pattern that suits
their needs&mdash;the protocol itself does not mandate any specific user interaction
model.

<Warning>

For trust & safety and security:

- Servers **MUST NOT** use elicitation to request sensitive information.

Applications **SHOULD**:

- Provide UI that makes it clear which server is requesting information
- Allow users to review and modify their responses before sending
- Respect user privacy and provide clear decline and cancel options

</Warning>

## Capabilities

Clients that support elicitation **MUST** declare the `elicitation` capability during
[initialization](/specification/2025-06-18/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "elicitation": {}
  }
}
```

## Protocol Messages

### Creating Elicitation Requests

To request information from a user, servers send an `elicitation/create` request:

#### Simple Text Request

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "elicitation/create",
  "params": {
    "message": "Please provide your GitHub username",
    "requestedSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      },
      "required": ["name"]
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "action": "accept",
    "content": {
      "name": "octocat"
    }
  }
}
```

#### Structured Data Request

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "elicitation/create",
  "params": {
    "message": "Please provide your contact information",
    "requestedSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Your full name"
        },
        "email": {
          "type": "string",
          "format": "email",
          "description": "Your email address"
        },
        "age": {
          "type": "number",
          "minimum": 18,
          "description": "Your age"
        }
      },
      "required": ["name", "email"]
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "action": "accept",
    "content": {
      "name": "Monalisa Octocat",
      "email": "octocat@github.com",
      "age": 30
    }
  }
}
```

**Reject Response Example:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "action": "decline"
  }
}
```

**Cancel Response Example:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "action": "cancel"
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant User
    participant Client
    participant Server

    Note over Server,Client: Server initiates elicitation
    Server->>Client: elicitation/create

    Note over Client,User: Human interaction
    Client->>User: Present elicitation UI
    User-->>Client: Provide requested information

    Note over Server,Client: Complete request
    Client-->>Server: Return user response

    Note over Server: Continue processing with new information
```

## Request Schema

The `requestedSchema` field allows servers to define the structure of the expected response using a restricted subset of JSON Schema. To simplify implementation for clients, elicitation schemas are limited to flat objects with primitive properties only:

```json
"requestedSchema": {
  "type": "object",
  "properties": {
    "propertyName": {
      "type": "string",
      "title": "Display Name",
      "description": "Description of the property"
    },
    "anotherProperty": {
      "type": "number",
      "minimum": 0,
      "maximum": 100
    }
  },
  "required": ["propertyName"]
}
```

### Supported Schema Types

The schema is restricted to these primitive types:

1. **String Schema**

   ```json
   {
     "type": "string",
     "title": "Display Name",
     "description": "Description text",
     "minLength": 3,
     "maxLength": 50,
     "format": "email" // Supported: "email", "uri", "date", "date-time"
   }
   ```

   Supported formats: `email`, `uri`, `date`, `date-time`

2. **Number Schema**

   ```json
   {
     "type": "number", // or "integer"
     "title": "Display Name",
     "description": "Description text",
     "minimum": 0,
     "maximum": 100
   }
   ```

3. **Boolean Schema**

   ```json
   {
     "type": "boolean",
     "title": "Display Name",
     "description": "Description text",
     "default": false
   }
   ```

4. **Enum Schema**
   ```json
   {
     "type": "string",
     "title": "Display Name",
     "description": "Description text",
     "enum": ["option1", "option2", "option3"],
     "enumNames": ["Option 1", "Option 2", "Option 3"]
   }
   ```

Clients can use this schema to:

1. Generate appropriate input forms
2. Validate user input before sending
3. Provide better guidance to users

Note that complex nested structures, arrays of objects, and other advanced JSON Schema features are intentionally not supported to simplify client implementation.

## Response Actions

Elicitation responses use a three-action model to clearly distinguish between different user actions:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "action": "accept", // or "decline" or "cancel"
    "content": {
      "propertyName": "value",
      "anotherProperty": 42
    }
  }
}
```

The three response actions are:

1. **Accept** (`action: "accept"`): User explicitly approved and submitted with data

   - The `content` field contains the submitted data matching the requested schema
   - Example: User clicked "Submit", "OK", "Confirm", etc.

2. **Decline** (`action: "decline"`): User explicitly declined the request

   - The `content` field is typically omitted
   - Example: User clicked "Reject", "Decline", "No", etc.

3. **Cancel** (`action: "cancel"`): User dismissed without making an explicit choice
   - The `content` field is typically omitted
   - Example: User closed the dialog, clicked outside, pressed Escape, etc.

Servers should handle each state appropriately:

- **Accept**: Process the submitted data
- **Decline**: Handle explicit decline (e.g., offer alternatives)
- **Cancel**: Handle dismissal (e.g., prompt again later)

## Security Considerations

1. Servers **MUST NOT** request sensitive information through elicitation
2. Clients **SHOULD** implement user approval controls
3. Both parties **SHOULD** validate elicitation content against the provided schema
4. Clients **SHOULD** provide clear indication of which server is requesting information
5. Clients **SHOULD** allow users to decline elicitation requests at any time
6. Clients **SHOULD** implement rate limiting
7. Clients **SHOULD** present elicitation requests in a way that makes it clear what information is being requested and why

--- END OF FILE 2025-06-18/client/elicitation.mdx ---


--- START OF FILE 2025-06-18/client/roots.mdx ---
---
title: Roots
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol (MCP) provides a standardized way for clients to expose
filesystem "roots" to servers. Roots define the boundaries of where servers can operate
within the filesystem, allowing them to understand which directories and files they have
access to. Servers can request the list of roots from supporting clients and receive
notifications when that list changes.

## User Interaction Model

Roots in MCP are typically exposed through workspace or project configuration interfaces.

For example, implementations could offer a workspace/project picker that allows users to
select directories and files the server should have access to. This can be combined with
automatic workspace detection from version control systems or project files.

However, implementations are free to expose roots through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Capabilities

Clients that support roots **MUST** declare the `roots` capability during
[initialization](/specification/2025-06-18/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "roots": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the client will emit notifications when the list of roots
changes.

## Protocol Messages

### Listing Roots

To retrieve roots, servers send a `roots/list` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "roots/list"
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "roots": [
      {
        "uri": "file:///home/user/projects/myproject",
        "name": "My Project"
      }
    ]
  }
}
```

### Root List Changes

When roots change, clients that support `listChanged` **MUST** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/roots/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Server
    participant Client

    Note over Server,Client: Discovery
    Server->>Client: roots/list
    Client-->>Server: Available roots

    Note over Server,Client: Changes
    Client--)Server: notifications/roots/list_changed
    Server->>Client: roots/list
    Client-->>Server: Updated roots
```

## Data Types

### Root

A root definition includes:

- `uri`: Unique identifier for the root. This **MUST** be a `file://` URI in the current
  specification.
- `name`: Optional human-readable name for display purposes.

Example roots for different use cases:

#### Project Directory

```json
{
  "uri": "file:///home/user/projects/myproject",
  "name": "My Project"
}
```

#### Multiple Repositories

```json
[
  {
    "uri": "file:///home/user/repos/frontend",
    "name": "Frontend Repository"
  },
  {
    "uri": "file:///home/user/repos/backend",
    "name": "Backend Repository"
  }
]
```

## Error Handling

Clients **SHOULD** return standard JSON-RPC errors for common failure cases:

- Client does not support roots: `-32601` (Method not found)
- Internal errors: `-32603`

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Roots not supported",
    "data": {
      "reason": "Client does not have roots capability"
    }
  }
}
```

## Security Considerations

1. Clients **MUST**:

   - Only expose roots with appropriate permissions
   - Validate all root URIs to prevent path traversal
   - Implement proper access controls
   - Monitor root accessibility

2. Servers **SHOULD**:
   - Handle cases where roots become unavailable
   - Respect root boundaries during operations
   - Validate all paths against provided roots

## Implementation Guidelines

1. Clients **SHOULD**:

   - Prompt users for consent before exposing roots to servers
   - Provide clear user interfaces for root management
   - Validate root accessibility before exposing
   - Monitor for root changes

2. Servers **SHOULD**:
   - Check for roots capability before usage
   - Handle root list changes gracefully
   - Respect root boundaries in operations
   - Cache root information appropriately

--- END OF FILE 2025-06-18/client/roots.mdx ---


--- START OF FILE 2025-06-18/client/sampling.mdx ---
---
title: Sampling
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to request LLM
sampling ("completions" or "generations") from language models via clients. This flow
allows clients to maintain control over model access, selection, and permissions while
enabling servers to leverage AI capabilities&mdash;with no server API keys necessary.
Servers can request text, audio, or image-based interactions and optionally include
context from MCP servers in their prompts.

## User Interaction Model

Sampling in MCP allows servers to implement agentic behaviors, by enabling LLM calls to
occur _nested_ inside other MCP server features.

Implementations are free to expose sampling through any interface pattern that suits
their needs&mdash;the protocol itself does not mandate any specific user interaction
model.

<Warning>

For trust & safety and security, there **SHOULD** always
be a human in the loop with the ability to deny sampling requests.

Applications **SHOULD**:

- Provide UI that makes it easy and intuitive to review sampling requests
- Allow users to view and edit prompts before sending
- Present generated responses for review before delivery

</Warning>

## Capabilities

Clients that support sampling **MUST** declare the `sampling` capability during
[initialization](/specification/2025-06-18/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "sampling": {}
  }
}
```

## Protocol Messages

### Creating Messages

To request a language model generation, servers send a `sampling/createMessage` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "What is the capital of France?"
        }
      }
    ],
    "modelPreferences": {
      "hints": [
        {
          "name": "claude-3-sonnet"
        }
      ],
      "intelligencePriority": 0.8,
      "speedPriority": 0.5
    },
    "systemPrompt": "You are a helpful assistant.",
    "maxTokens": 100
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "role": "assistant",
    "content": {
      "type": "text",
      "text": "The capital of France is Paris."
    },
    "model": "claude-3-sonnet-20240307",
    "stopReason": "endTurn"
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Server
    participant Client
    participant User
    participant LLM

    Note over Server,Client: Server initiates sampling
    Server->>Client: sampling/createMessage

    Note over Client,User: Human-in-the-loop review
    Client->>User: Present request for approval
    User-->>Client: Review and approve/modify

    Note over Client,LLM: Model interaction
    Client->>LLM: Forward approved request
    LLM-->>Client: Return generation

    Note over Client,User: Response review
    Client->>User: Present response for approval
    User-->>Client: Review and approve/modify

    Note over Server,Client: Complete request
    Client-->>Server: Return approved response
```

## Data Types

### Messages

Sampling messages can contain:

#### Text Content

```json
{
  "type": "text",
  "text": "The message content"
}
```

#### Image Content

```json
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/jpeg"
}
```

#### Audio Content

```json
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

### Model Preferences

Model selection in MCP requires careful abstraction since servers and clients may use
different AI providers with distinct model offerings. A server cannot simply request a
specific model by name since the client may not have access to that exact model or may
prefer to use a different provider's equivalent model.

To solve this, MCP implements a preference system that combines abstract capability
priorities with optional model hints:

#### Capability Priorities

Servers express their needs through three normalized priority values (0-1):

- `costPriority`: How important is minimizing costs? Higher values prefer cheaper models.
- `speedPriority`: How important is low latency? Higher values prefer faster models.
- `intelligencePriority`: How important are advanced capabilities? Higher values prefer
  more capable models.

#### Model Hints

While priorities help select models based on characteristics, `hints` allow servers to
suggest specific models or model families:

- Hints are treated as substrings that can match model names flexibly
- Multiple hints are evaluated in order of preference
- Clients **MAY** map hints to equivalent models from different providers
- Hints are advisory&mdash;clients make final model selection

For example:

```json
{
  "hints": [
    { "name": "claude-3-sonnet" }, // Prefer Sonnet-class models
    { "name": "claude" } // Fall back to any Claude model
  ],
  "costPriority": 0.3, // Cost is less important
  "speedPriority": 0.8, // Speed is very important
  "intelligencePriority": 0.5 // Moderate capability needs
}
```

The client processes these preferences to select an appropriate model from its available
options. For instance, if the client doesn't have access to Claude models but has Gemini,
it might map the sonnet hint to `gemini-1.5-pro` based on similar capabilities.

## Error Handling

Clients **SHOULD** return errors for common failure cases:

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -1,
    "message": "User rejected sampling request"
  }
}
```

## Security Considerations

1. Clients **SHOULD** implement user approval controls
2. Both parties **SHOULD** validate message content
3. Clients **SHOULD** respect model preference hints
4. Clients **SHOULD** implement rate limiting
5. Both parties **MUST** handle sensitive data appropriately

--- END OF FILE 2025-06-18/client/sampling.mdx ---


--- START OF FILE 2025-06-18/server/utilities/completion.mdx ---
---
title: Completion
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to offer
argument autocompletion suggestions for prompts and resource URIs. This enables rich,
IDE-like experiences where users receive contextual suggestions while entering argument
values.

## User Interaction Model

Completion in MCP is designed to support interactive user experiences similar to IDE code
completion.

For example, applications may show completion suggestions in a dropdown or popup menu as
users type, with the ability to filter and select from available options.

However, implementations are free to expose completion through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Capabilities

Servers that support completions **MUST** declare the `completions` capability:

```json
{
  "capabilities": {
    "completions": {}
  }
}
```

## Protocol Messages

### Requesting Completions

To get completion suggestions, clients send a `completion/complete` request specifying
what is being completed through a reference type:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "code_review"
    },
    "argument": {
      "name": "language",
      "value": "py"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "completion": {
      "values": ["python", "pytorch", "pyside"],
      "total": 10,
      "hasMore": true
    }
  }
}
```

For prompts or URI templates with multiple arguments, clients should include previous completions in the `context.arguments` object to provide context for subsequent requests.

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "code_review"
    },
    "argument": {
      "name": "framework",
      "value": "fla"
    },
    "context": {
      "arguments": {
        "language": "python"
      }
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "completion": {
      "values": ["flask"],
      "total": 1,
      "hasMore": false
    }
  }
}
```

### Reference Types

The protocol supports two types of completion references:

| Type           | Description                 | Example                                             |
| -------------- | --------------------------- | --------------------------------------------------- |
| `ref/prompt`   | References a prompt by name | `{"type": "ref/prompt", "name": "code_review"}`     |
| `ref/resource` | References a resource URI   | `{"type": "ref/resource", "uri": "file:///{path}"}` |

### Completion Results

Servers return an array of completion values ranked by relevance, with:

- Maximum 100 items per response
- Optional total number of available matches
- Boolean indicating if additional results exist

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client: User types argument
    Client->>Server: completion/complete
    Server-->>Client: Completion suggestions

    Note over Client: User continues typing
    Client->>Server: completion/complete
    Server-->>Client: Refined suggestions
```

## Data Types

### CompleteRequest

- `ref`: A `PromptReference` or `ResourceReference`
- `argument`: Object containing:
  - `name`: Argument name
  - `value`: Current value
- `context`: Object containing:
  - `arguments`: A mapping of already-resolved argument names to their values.

### CompleteResult

- `completion`: Object containing:
  - `values`: Array of suggestions (max 100)
  - `total`: Optional total matches
  - `hasMore`: Additional results flag

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Method not found: `-32601` (Capability not supported)
- Invalid prompt name: `-32602` (Invalid params)
- Missing required arguments: `-32602` (Invalid params)
- Internal errors: `-32603` (Internal error)

## Implementation Considerations

1. Servers **SHOULD**:

   - Return suggestions sorted by relevance
   - Implement fuzzy matching where appropriate
   - Rate limit completion requests
   - Validate all inputs

2. Clients **SHOULD**:
   - Debounce rapid completion requests
   - Cache completion results where appropriate
   - Handle missing or partial results gracefully

## Security

Implementations **MUST**:

- Validate all completion inputs
- Implement appropriate rate limiting
- Control access to sensitive suggestions
- Prevent completion-based information disclosure

--- END OF FILE 2025-06-18/server/utilities/completion.mdx ---


--- START OF FILE 2025-06-18/server/utilities/logging.mdx ---
---
title: Logging
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to send
structured log messages to clients. Clients can control logging verbosity by setting
minimum log levels, with servers sending notifications containing severity levels,
optional logger names, and arbitrary JSON-serializable data.

## User Interaction Model

Implementations are free to expose logging through any interface pattern that suits their
needs&mdash;the protocol itself does not mandate any specific user interaction model.

## Capabilities

Servers that emit log message notifications **MUST** declare the `logging` capability:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

## Log Levels

The protocol follows the standard syslog severity levels specified in
[RFC 5424](https://datatracker.ietf.org/doc/html/rfc5424#section-6.2.1):

| Level     | Description                      | Example Use Case           |
| --------- | -------------------------------- | -------------------------- |
| debug     | Detailed debugging information   | Function entry/exit points |
| info      | General informational messages   | Operation progress updates |
| notice    | Normal but significant events    | Configuration changes      |
| warning   | Warning conditions               | Deprecated feature usage   |
| error     | Error conditions                 | Operation failures         |
| critical  | Critical conditions              | System component failures  |
| alert     | Action must be taken immediately | Data corruption detected   |
| emergency | System is unusable               | Complete system failure    |

## Protocol Messages

### Setting Log Level

To configure the minimum log level, clients **MAY** send a `logging/setLevel` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "logging/setLevel",
  "params": {
    "level": "info"
  }
}
```

### Log Message Notifications

Servers send log messages using `notifications/message` notifications:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/message",
  "params": {
    "level": "error",
    "logger": "database",
    "data": {
      "error": "Connection failed",
      "details": {
        "host": "localhost",
        "port": 5432
      }
    }
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Configure Logging
    Client->>Server: logging/setLevel (info)
    Server-->>Client: Empty Result

    Note over Client,Server: Server Activity
    Server--)Client: notifications/message (info)
    Server--)Client: notifications/message (warning)
    Server--)Client: notifications/message (error)

    Note over Client,Server: Level Change
    Client->>Server: logging/setLevel (error)
    Server-->>Client: Empty Result
    Note over Server: Only sends error level<br/>and above
```

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Invalid log level: `-32602` (Invalid params)
- Configuration errors: `-32603` (Internal error)

## Implementation Considerations

1. Servers **SHOULD**:

   - Rate limit log messages
   - Include relevant context in data field
   - Use consistent logger names
   - Remove sensitive information

2. Clients **MAY**:
   - Present log messages in the UI
   - Implement log filtering/search
   - Display severity visually
   - Persist log messages

## Security

1. Log messages **MUST NOT** contain:

   - Credentials or secrets
   - Personal identifying information
   - Internal system details that could aid attacks

2. Implementations **SHOULD**:
   - Rate limit messages
   - Validate all data fields
   - Control log access
   - Monitor for sensitive content

--- END OF FILE 2025-06-18/server/utilities/logging.mdx ---


--- START OF FILE 2025-06-18/server/utilities/pagination.mdx ---
---
title: Pagination
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol (MCP) supports paginating list operations that may return
large result sets. Pagination allows servers to yield results in smaller chunks rather
than all at once.

Pagination is especially important when connecting to external services over the
internet, but also useful for local integrations to avoid performance issues with large
data sets.

## Pagination Model

Pagination in MCP uses an opaque cursor-based approach, instead of numbered pages.

- The **cursor** is an opaque string token, representing a position in the result set
- **Page size** is determined by the server, and clients **MUST NOT** assume a fixed page
  size

## Response Format

Pagination starts when the server sends a **response** that includes:

- The current page of results
- An optional `nextCursor` field if more results exist

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {
    "resources": [...],
    "nextCursor": "eyJwYWdlIjogM30="
  }
}
```

## Request Format

After receiving a cursor, the client can _continue_ paginating by issuing a request
including that cursor:

```json
{
  "jsonrpc": "2.0",
  "method": "resources/list",
  "params": {
    "cursor": "eyJwYWdlIjogMn0="
  }
}
```

## Pagination Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: List Request (no cursor)
    loop Pagination Loop
      Server-->>Client: Page of results + nextCursor
      Client->>Server: List Request (with cursor)
    end
```

## Operations Supporting Pagination

The following MCP operations support pagination:

- `resources/list` - List available resources
- `resources/templates/list` - List resource templates
- `prompts/list` - List available prompts
- `tools/list` - List available tools

## Implementation Guidelines

1. Servers **SHOULD**:

   - Provide stable cursors
   - Handle invalid cursors gracefully

2. Clients **SHOULD**:

   - Treat a missing `nextCursor` as the end of results
   - Support both paginated and non-paginated flows

3. Clients **MUST** treat cursors as opaque tokens:
   - Don't make assumptions about cursor format
   - Don't attempt to parse or modify cursors
   - Don't persist cursors across sessions

## Error Handling

Invalid cursors **SHOULD** result in an error with code -32602 (Invalid params).

--- END OF FILE 2025-06-18/server/utilities/pagination.mdx ---


--- START OF FILE 2025-06-18/server/index.mdx ---
---
title: Overview
---

<Info>**Protocol Revision**: 2025-06-18</Info>

Servers provide the fundamental building blocks for adding context to language models via
MCP. These primitives enable rich interactions between clients, servers, and language
models:

- **Prompts**: Pre-defined templates or instructions that guide language model
  interactions
- **Resources**: Structured data or content that provides additional context to the model
- **Tools**: Executable functions that allow models to perform actions or retrieve
  information

Each primitive can be summarized in the following control hierarchy:

| Primitive | Control                | Description                                        | Example                         |
| --------- | ---------------------- | -------------------------------------------------- | ------------------------------- |
| Prompts   | User-controlled        | Interactive templates invoked by user choice       | Slash commands, menu options    |
| Resources | Application-controlled | Contextual data attached and managed by the client | File contents, git history      |
| Tools     | Model-controlled       | Functions exposed to the LLM to take actions       | API POST requests, file writing |

Explore these key primitives in more detail below:

<CardGroup cols={3}>
  <Card
    title="Prompts"
    icon="message"
    href="/specification/2025-06-18/server/prompts"
  />
  <Card
    title="Resources"
    icon="file-lines"
    href="/specification/2025-06-18/server/resources"
  />
  <Card
    title="Tools"
    icon="wrench"
    href="/specification/2025-06-18/server/tools"
  />
</CardGroup>

--- END OF FILE 2025-06-18/server/index.mdx ---


--- START OF FILE 2025-06-18/server/prompts.mdx ---
---
title: Prompts
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to expose prompt
templates to clients. Prompts allow servers to provide structured messages and
instructions for interacting with language models. Clients can discover available
prompts, retrieve their contents, and provide arguments to customize them.

## User Interaction Model

Prompts are designed to be **user-controlled**, meaning they are exposed from servers to
clients with the intention of the user being able to explicitly select them for use.

Typically, prompts would be triggered through user-initiated commands in the user
interface, which allows users to naturally discover and invoke available prompts.

For example, as slash commands:

![Example of prompt exposed as slash command](/specification/2025-06-18/server/slash-command.png)

However, implementors are free to expose prompts through any interface pattern that suits
their needs&mdash;the protocol itself does not mandate any specific user interaction
model.

## Capabilities

Servers that support prompts **MUST** declare the `prompts` capability during
[initialization](/specification/2025-06-18/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "prompts": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the server will emit notifications when the list of
available prompts changes.

## Protocol Messages

### Listing Prompts

To retrieve available prompts, clients send a `prompts/list` request. This operation
supports [pagination](/specification/2025-06-18/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "prompts/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "prompts": [
      {
        "name": "code_review",
        "title": "Request Code Review",
        "description": "Asks the LLM to analyze code quality and suggest improvements",
        "arguments": [
          {
            "name": "code",
            "description": "The code to review",
            "required": true
          }
        ]
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Getting a Prompt

To retrieve a specific prompt, clients send a `prompts/get` request. Arguments may be
auto-completed through [the completion API](/specification/2025-06-18/server/utilities/completion).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "prompts/get",
  "params": {
    "name": "code_review",
    "arguments": {
      "code": "def hello():\n    print('world')"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "description": "Code review prompt",
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "Please review this Python code:\ndef hello():\n    print('world')"
        }
      }
    ]
  }
}
```

### List Changed Notification

When the list of available prompts changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/prompts/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Discovery
    Client->>Server: prompts/list
    Server-->>Client: List of prompts

    Note over Client,Server: Usage
    Client->>Server: prompts/get
    Server-->>Client: Prompt content

    opt listChanged
      Note over Client,Server: Changes
      Server--)Client: prompts/list_changed
      Client->>Server: prompts/list
      Server-->>Client: Updated prompts
    end
```

## Data Types

### Prompt

A prompt definition includes:

- `name`: Unique identifier for the prompt
- `title`: Optional human-readable name of the prompt for display purposes.
- `description`: Optional human-readable description
- `arguments`: Optional list of arguments for customization

### PromptMessage

Messages in a prompt can contain:

- `role`: Either "user" or "assistant" to indicate the speaker
- `content`: One of the following content types:

#### Text Content

Text content represents plain text messages:

```json
{
  "type": "text",
  "text": "The text content of the message"
}
```

This is the most common content type used for natural language interactions.

#### Image Content

Image content allows including visual information in messages:

```json
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/png"
}
```

The image data **MUST** be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where visual context is important.

#### Audio Content

Audio content allows including audio information in messages:

```json
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

The audio data MUST be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where audio context is important.

#### Embedded Resources

Embedded resources allow referencing server-side resources directly in messages:

```json
{
  "type": "resource",
  "resource": {
    "uri": "resource://example",
    "name": "example",
    "title": "My Example Resource",
    "mimeType": "text/plain",
    "text": "Resource content"
  }
}
```

Resources can contain either text or binary (blob) data and **MUST** include:

- A valid resource URI
- The appropriate MIME type
- Either text content or base64-encoded blob data

Embedded resources enable prompts to seamlessly incorporate server-managed content like
documentation, code samples, or other reference materials directly into the conversation
flow.

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Invalid prompt name: `-32602` (Invalid params)
- Missing required arguments: `-32602` (Invalid params)
- Internal errors: `-32603` (Internal error)

## Implementation Considerations

1. Servers **SHOULD** validate prompt arguments before processing
2. Clients **SHOULD** handle pagination for large prompt lists
3. Both parties **SHOULD** respect capability negotiation

## Security

Implementations **MUST** carefully validate all prompt inputs and outputs to prevent
injection attacks or unauthorized access to resources.

--- END OF FILE 2025-06-18/server/prompts.mdx ---


--- START OF FILE 2025-06-18/server/resource-picker.png ---
ï¿½PNG

   
IHDR   ï¿½   ï¿½   ï¿½Ä¶  `iCCPICC Profile  (ï¿½uï¿½;HAï¿½ï¿½h$Dï¿½ï¿½H!Qï¿½*ï¿½ï¿½ï¿½rF,ï¿½ XQï¿½ï¿½Kï¿½ï¿½dï¿½wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6bciï¿½ï¿½BÒ‰ï¿½ï¿½"ï¿½ï¿½B4ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½3ï¿½ ï¿½%ï¿½gï¿½	ium]ï¿½!
?Âšnï¿½ï¿½ï¿½.P	ï¿½ï¿½ï¿½ï¿½ï¿½z7&fÍ¤cRï¿½rp68$oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½~Pï¿½tï¿½mï¿½ï¿½ï¿½;6|Hï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½-ï¿½5kï¿½2Iï¿½{ï¿½^ï¿½rï¿½ï¿½Ä‘lï¿½oï¿½qï¿½ï¿½Ö¿vï¿½ï¿½ï¿½Eï¿½0ï¿½0Rï¿½Ã¤ï¿½ï¿½
ï¿½P ÓŸ"ï¿½?}Jï¿½/ï¿½2ï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½Â¤ï¿½ï¿½Qï¿½ï¿½qDï¿½eLR*ï¿½Þ¿ï¿½ï¿½zGï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%Pï¿½ï¿½×®7z\7Lï¿½ï¿½ï¿½u=uï¿½ï¿½ï¿½[ï¿½@Ï›ã¼Ž ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½qï¿½@ï¿½#Pï¿½|.Laï¿½vY'   beXIfMM *           ï¿½i       &     ï¿½ï¿½       Pï¿½       ï¿½ï¿½       ï¿½    ASCII   Screenshot9UD  =iTXtXML:com.adobe.xmp     <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="XMP Core 6.0.0">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:exif="http://ns.adobe.com/exif/1.0/"
            xmlns:tiff="http://ns.adobe.com/tiff/1.0/">
         <exif:PixelYDimension>181</exif:PixelYDimension>
         <exif:UserComment>Screenshot</exif:UserComment>
         <exif:PixelXDimension>174</exif:PixelXDimension>
         <tiff:Orientation>1</tiff:Orientation>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
oPï¿½=  3HIDATxï¿½}ï¿½Õ‘nMMï¿½fA(ï¿½0BFH"ï¿½dlï¿½ï¿½ï¿½ï¿½omdï¿½ï¿½ï¿½9ï¿½. ï¿½kï¿½g>{ï¿½kï¿½
ï¿½È€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½EAHï¿½ï¿½rï¿½H3ï¿½hï¿½hï¿½ï¿½ï¿½ï¿½ï¿½Ü¾}cï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½V×©:uï¿½Ô©S]}ï¿½oß¢ï¿½ï¿½Sï¿½Qï¿½rï¿½Xï¿½eï¿½ï¿½1ï¿½ï¿½Þ‘ï¿½EDï¿½,ï¿½_ï¿½RQï¿½ ï¿½ï¿½ï¿½Wï¿½Hzdï¿½L,P,N+ï¿½?2ï¿½ï¿½ï¿½ï¿½x"ï¿½ï¿½ï¿½i%ï¿½f
ï¿½ï¿½Pï¿½^]]Mï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Bï¿½wï¿½*%+ï¿½ï¿½fï¿½Lï¿½ï¿½ wï¿½ï¿½i:]}ï¿½Uqï¿½oXOï¿½>ï¿½;ï¿½ï¿½ï¿½[izï¿½4ï¿½ï¿½ï¿½wï¿½ï¿½C@ï¿½ï¿½;ï¿½ï¿½.ï¿½[ï¿½>kï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½hï¿½ï¿½IT\TL}ï¿½iï¿½Õ¯~ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6å—¿ï¿½5=ï¿½ï¿½v9çœ³éš«ï¿½ï¿½;vï¿½ï¿½Iï¿½ï¿½7ï¿½ï¿½-ï¿½ï¿½ï¿½ï¿½6Û cAï¿½ï¿½ï¿½
Zï¿½Nï¿½ï¿½ï¿½kï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½
ï¿½æš«hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~''ï¿½ï¿½UWï¿½Oï¿½sï¿½Rï¿½-iï¿½%ï¿½ï¿½ï¿½!ï¿½ï¿½ï¿½XW\~-ï¿½Åƒï¿½ï¿½~ï¿½ï¿½wï¿½ï¿½ï¿½ï¿½ï¿½|9mÝ¶=ï¿½ï¿½1cï¿½Ò‹/ï¿½H+Vï¿½ï¿½ï¿½ï¿½Ú½ï¿½=ï¿½ï¿½È‘#ï¿½c[L_ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>!ï¿½ï¿½ï¿½]Kç·ï¿½ wÌ˜1ï¿½ï¿½Ö›ï¿½/~ï¿½ï¿½=ï¿½ï¿½@!ï¿½nï¿½ï¿½Îªï¿½*8ï¿½)=Dï¿½ï¿½pÐ›nï¿½ï¿½+ï¿½N#zï¿½
"<ï¿½z.ï¿½.ï¿½ï¿½Wnï¿½5kï¿½Òµ<ï¿½Cï¿½ï¿½uz0nï¿½XZï¿½ï¿½
zsï¿½ï¿½Jï¿½ï¿½Gï¿½ï¿½]D]]ï¿½Bï¿½|,ï¿½ï¿½ï¿½ï¿½ï¿½r
}ï¿½ï¿½Rï¿½?ï¿½ï¿½ï¿½ï¿½N+Jï¿½+.ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4oï¿½\Ú¶mï¿½ï¿½ï¿½ ;wî¤†ï¿½ï¿½ï¿½=Wï¿½ï¿½wï¿½Fwï¿½ï¿½}ï¿½ï¿½ï¿½oï¿½)ï¿½Nï¿½ï¿½oï¿½I<ï¿½ï¿½ï¿½%ï¿½Lï¿½:Eï¿½ï¿½ï¿½H;/ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8pï¿½ï¿½m JFï¿½lï¿½9.ï¿½Ù¹nÎš(^SSMï¿½ï¿½ï¿½ï¿½ï¿½dï¿½-rï¿½WGï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bÖ‘ï¿½Dï¿½_ï¿½ï¿½ujDeÔŸwÞ¹ï¿½Uï¿½ï¿½Aï¿½m`ï¿½ï¿½ï¿½Ó§ï¿½/ï¿½ï¿½ï¿½xï¿½v[ï¿½ï¿½ï¿½aÃ†ï¿½ï¿½ï¿½_Kï¿½ï¿½ï¿½ï¿½yï¿½ï¿½sï¿½Csï¿½Ì¦qï¿½ï¿½qï¿½ï¿½ï¿½z0ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½|{ï¿½ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½	/ï¿½8Ï|/=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½Oï¿½mï¿½1ï¿½Aï¿½ï¿½4oï¿½<qï¿½W^yï¿½ï¿½{ï¿½o4ï¿½ï¿½VUEXTpï¿½9sï¿½ï¿½ï¿½É“%yï¿½ï¿½ï¿½i5/ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½hÏžï¿½4fï¿½hï¿½ï¿½ï¿½ï¿½ï¿½{~(iï¿½ï¿½ï¿½ï¿½yA\ï¿½ï¿½ï¿½ï¿½ï¿½`>nï¿½ï¿½Kï¿½ï¿½3ï¿½R'ï¿½;Ð¥Xï¿½)ï¿½ï¿½cï¿½ï¿½xH"Ú¦+ï¿½~|pz8
"3rTï¿½!ï¿½ï¿½Oï¿½ï¿½)?ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½Aï¿½~ï¿½Cï¿½ï¿½ï¿½|ï¿½
Gï¿½ï¿½ï¿½4ï¿½ï¿½ï¿½ï¿½O[ï¿½DWg-ï¿½?ï¿½>ï¿½ï¿½%tï¿½ï¿½ï¿½"Qï¿½bagjgï¿½ï¿½Gï¿½*ï¿½ï¿½K_ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½}ï½’ï¿½xï¿½
Ú·oï¿½ï¿½!Ò®]ï¿½Vï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½ï¿½~{mÙ²ï¿½^}Mï¿½6Uï¿½Qï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½#nÙºï¿½ï¿½0ï¿½yï¿½fBï¿½EyGd8<ï¿½ï¿½ï¿½_ï¿½	Nï¿½h-|ÌœÙ”ï¿½ï¿½ï¿½&ï¿½eBHï¿½ï¿½ï¿½M%W`Ä†Jï¿½ï¿½d#
ï¿½~ï¿½ï¿½BM/ï¿½ tï¿½uï¿½cï¿½ï¿½hï¿½ï¿½ï¿½Nï¿½o_ï¿½ï¿½:ï¿½`ï¿½ï¿½ï¿½Q>]#ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½-{ï¿½ï¿½ï¿½É·ï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½.à¨¸ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½ï¿½fï¿½ï¿½ß¡/ï¿½k4ï¿½ï¿½sï¿½ï¿½.ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½>"ï¿½|ï¿½ï¿½Iï¿½"ï¿½ï¿½ï¿½Î¦Mï¿½hï¿½"ï¿½*î¸»ï¿½ï¿½JKJï¿½ï¿½HwOï¿½fcï¿½Ä‰tï¿½I'ï¿½%lï¿½ï¿½Å´uï¿½6ï¿½%ï¿½}ï¿½ï¿½ï¿½qMPï¿½ï¿½9Xjaå¸ˆï¿½,ï¿½7Çµï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½:/ï¿½×­[*ï¿½ï¿½Q4Smï¿½ï¿½p|ï¿½ï¿½9ï¿½ï¿½D?É‘cï¿½ï¿½ä°›ï¿½wttï¿½iï¿½ï¿½~ï¿½ï¿½ï¿½i,ç²‹ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½bpÂ¦3ï¿½Zï¿½ï¿½#äŠ½ï¿½ï¿½ï¿½^|ï¿½%zï¿½ï¿½ï¿½ï¿½ï¿½qï¿½xï¿½É¿P
çµ¼-ï¿½Qï¿½ï¿½?ï¿½ï¿½ÚšZzï¿½hï¿½ï¿½ï¿½ï¿½ï¿½>vï¿½ï¿½ï¿½Úµï¿½Qï¿½v^uZÐ‚wWsXdï¿½ï¿½sï¿½ ï¿½%ï¿½ï¿½%+ï¿½ï¿½~FBJï¿½
Nï¿½Mï¿½#kï¿½vï¿½ï¿½ï¿½3ï¿½Å¿ï¿½ï¿½/ï¿½ï¿½nï¿½ï¿½tEï¿½)wï¿½ï¿½Eï¿½ï¿½+n\ï¿½ï¿½?ï¿½ï¿½*++]ï¿½]ï¿½v'ï¿½ï¿½rï¿½gï¿½Rï¿½ï¿½ï¿½ß–S	_ï¿½ï¿½WHï¿½0~ï¿½Iï¿½446ï¿½ï¿½ï¿½ï¿½ï¿½ 4ï¿½iï¿½ï¿½/ï¿½ï¿½Ø¸ï¿½Ë¦ï¿½A]ï¿½a9-ï¿½ï¿½ï¿½ï¿½l ï¿½ï¿½,ï¿½=Fï¿½ï¿½gï¿½u
^8Nï¿½pï¿½dï¿½#"2ï¿½ï¿½ï¿½ï¿½Ô¡ï¿½tà©œï¿½6]ï¿½ï¿½.*ï¿½ï¿½ï¿½Iï¿½Nï¿½Ygï¿½ï¿½N*Ò€3Nï¿½hï¿½ï¿½;ï¿½ï¿½uï¿½2ï¿½Tjï¿½s\ï¿½Oï¿½Û½8mFï¿½ZerRGOw7ï¿½ï¿½ï¿½ï¿½dï¿½@ï¿½fÏžï¿½gï¿½9ï¿½=Â§ï¿½ï¿½è¬³Î’(Ð±ï¿½>ï¿½,ï¿½Ó“O
;ï¿½ï¿½Qï¿½ï¿½ï¿½bï¿½tï¿½xï¿½'jï¿½ï¿½ï¿½ï¿½ï¿½q:ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½yï¿½mhï¿½oWKï¿½ï¿½ï¿½2ï¿½~ï¿½@ï¿½7UQï¿½iï¿½wWï¿½DZï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½	mWï¿½pP@ï¿½ï¿½ï¿½-ï¿½Ö·ï¿½{ï¿½qï¿½%ï¿½Ð±"Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½sï¿½%ï¿½!ï¿½ï¿½ï¿½Uï¿½ptÐµï¿½Ò›ï¿½7ï¿½ï¿½Qï¿½r
>wï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½|ï¿½ï¿½v~9..~&Lï¿½@ï¿½ï¿½=ï¿½ï¿½ï¿½kï¿½ï¿½ï¿½/ï¿½Vï¿½ï¿½|>uï¿½:ï¿½ï¿½ï¿½ï¿½ï¿½g-_Pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½rï¿½fï¿½Fï¿½pnï¿½ï¿½ï¿½ï¿½0oï¿½!Õ¸ï¿½ï¿½2iï¿½Dzooï¿½ï¿½ï¿½H
ï¿½td7ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½Xï¿½Ò….ï¿½?>ï¿½È¯ï¿½ï¿½ï¿½?Bï¿½Gï¿½fï¿½C6lï¿½ï¿½ï¿½z/ï¿½uï¿½8yï¿½ï¿½ï¿½ï¿½@ï¿½nlhï¿½ï¿½ï¿½p.ï¿½ï¿½R:ï¿½Çˆvmï¿½?Ò˜ï¿½ï¿½rï¿½ï¿½wHï¿½{ï¿½<ï¿½Sï¿½ï¿½gï¿½ï¿½}ï¿½fï¿½~8+\vï¿½ï¿½4mï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½Úªï¿½ï¿½ï¿½ï¿½ï¿½PGGxï¿½EMMï¿½tl'MMï¿½%ï¿½ï¿½ï¿½apXï¿½ï¿½Î¾!ï¿½Ó¢wï¿½ï¿½ï¿½ï¿½|	ï¿½tï¿½Sï¿½ï¿½#ï¿½ï¿½ï¿½Mï¿½Lï¿½ï¿½cï¿½ï¿½ï¿½ï¿½Uï¿½ï¿½mï¿½ï¿½ï¿½(ï¿½U:ï¿½ï¿½ï¿½QT"[]ï¿½<Iï¿½ï¿½>ï¿½ï¿½ï¿½$nAbaï¿½p ikï¿½ï¿½,ï¿½ZQQÉ»ï¿½Oï¿½ï¿½#Gï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½o]m$]`ï¿½ï¿½ï¿½ï¿½ï¿½Fï¿½*ï¿½ï¿½ Yï¿½}Vï¿½ï¿½ï¿½qï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½FLï¿½?ï¿½ï¿½}6ï¿½ï¿½%ï¿½Pï¿½Lï¿½ï¿½ï¿½#Yï¿½ï¿½luNï¿½ï¿½ï¿½o#ï¿½)ï¿½ï¿½rï¿½`ï¿½ï¿½ï¿½?~ï¿½ï¿½Q>Rï¿½Äµ@Bï¿½ï¿½ï¿½ï¿½r\lï¿½`ï¿½ï¿½?
ï¿½'ï¿½ï¿½ï¿½ï¿½=9ï¿½ï¿½ï¿½FVï¿½\ï¿½;kï¿½@ï¿½Mfï¿½4rï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½ï¿½ Nï¿½ï¿½ï¿½í‹»sï¿½.ï¿½`Z 7ï¿½8ï¿½ï¿½33ï¿½gqq0*ï¿½ï¿½ï¿½rï¿½Qn.ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½w0g,ï¿½[,Pï¿½h+NÄÇ™Ç¢ï¿½ï¿½?ï¿½xï¿½8ï¿½ï¿½iï¿½Aï¿½iï¿½49.TKï¿½};ï¿½Aï¿½ï¿½r\ï¿½YWoï¿½9ï¿½ï¿½ï¿½ï¿½ì¸©s[?zoï¿½Qï¿½hï¿½ï¿½/ï¿½O8ï¿½E.ï¿½ï¿½<ï¿½ï¿½O'ï¿½ï¿½DZï¿½ï¿½ï¿½cï¿½ï¿½?Åï¿½ï¿½Ñ·ï¿½Dhï¿½W#k6ï¿½0?Nï¿½ï¿½+gï¿½Tï¿½@2ï¿½ï¿½ï¿½ï¿½ï¿½qï¿½rï¿½dï¿½ï¿½&ï¿½=Fï¿½ï¿½ï¿½hKKï¿½\ï¿½ï¿½ï¿½D(dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½}ï¿½ï¿½^?ï¿½ï¿½*++ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½]ï¿½@D^ï¿½ï¿½o^ï¿½ï¿½&mï¿½ï¿½ï¿½NpGï¿½ÏƒÜ§ï¿½Dï¿½ï¿½$ï¿½ï¿½Ç‹ï¿½ä†…ï¿½_ï¿½(ï¿½ï¿½ï¿½ï¿½Tï¿½[Sï¿½~ï¿½ï¿½ï¿½eï¿½xyï¿½ï¿½ï¿½<ï¿½$yBYï¿½ï¿½y\ï¿½7ï¿½ï¿½f!9Dï¿½pï¿½
ï¿½eï¿½ï¿½ï¿½Zï¿½;Wï¿½ï¿½ï¿½>Å®Cï¿½ï¿½V0ï¿½
ï¿½ï¿½Dï¿½ï¿½ï¿½Yï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½B CPï¿½aë»lï¿½ï¿½ï¿½ï¿½d#e";ï¿½ï¿½S(9ï¿½ï¿½>ï¿½aï¿½ï¿½dï¿½ï¿½ï¿½ï¿½`dï¿½ï¿½ï¿½ iï¿½'tï¿½ï¿½iï¿½TtD\ï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½D8ï¿½ï¿½gï¿½ï¿½ï¿½ï¿½Oz;Xï¿½ï¿½ï¿½,ï¿½Nï¿½Qm7!#ï¿½ï¿½ï¿½ï¿½ï¿½qZs!fG\Gï¿½ï¿½ï¿½ï¿½ï¿½ZtEï¿½ï¿½F0SXï¿½ï¿½Ü„C"ï¿½ï¿½ï¿½Aï¿½ï¿½-ï¿½ï¿½ï¿½;ï¿½ï¿½,_ï¿½ï¿½k~Ì«ï¿½4
ï¿½ï¿½Qï¿½-Ç•ï¿½Df$ï¿½ï¿½]Lï¿½Eï¿½ï¿½ï¿½ï¿½ ï¿½Ô¨7%ï¿½7ï¿½Qï¿½ï¿½â¢ Sï¿½uÊ¥x&<Ù´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½LxTï¿½ï¿½ï¿½ï¿½]nï¿½WÌ¥zfï¿½sjctï¿½ï¿½Xï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç¤aAï¿½Xï¿½x|ï¿½Kn
6ï¿½9rï¿½d/7ï¿½>.{B'ï¿½rï¿½?ï¿½ï¿½t	ï¿½Ö|ï¿½
0ï¿½ï¿½.ï¿½C HqÚ«ï¿½ï¿½99'-^ï¿½^e6Ó‚ï¿½xTF&<fï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½MRï¿½,Æ¤2ï¿½ï¿½7ï¿½>ï¿½ï¿½xï¿½ï¿½ï¿½&ï¿½Ñ¹89>DyÅ…b>ï¿½
9ï¿½IWkï¿½?ï¿½ï¿½ï¿½ï¿½JJï¿½0ï¿½Gï¿½L:ï¿½fï¿½/ Q	bï¿½Rï¿½ï¿½ï¿½Mï¿½DlØ 0ï¿½ï¿½ï¿½Rï¿½&ï¿½hï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½Ü›ï¿½ï¿½ï¿½?ï¿½hï¿½ï¿½+'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½æ¸eï¿½ï¿½ï¿½KPbAï¿½JCnBï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½Jï¿½x,ï¿½ï¿½aï¿½09.7:ï¿½ï¿½ï¿½L@ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<!+Tï¿½!'ï¿½ï¿½ï¿½ï¿½ï¿½ar\g|ï¿½8ï¿½@6xï¿½sSï¿½ï¿½9ï¿½~ï¿½|oï¿½ï¿½GWKhï¿½Tï¿½Éµï¿½!#×¾Oï¿½vyï¿½quï¿½`ï¿½xWï¿½Hï¿½.ï¿½Bï¿½ï¿½,Y,:ï¿½0dï¿½Ô¨ï¿½ 0}<2ï¿½ï¿½/ï¿½Hï¿½%ï¿½ï¿½ï¿½+2ï¿½4aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,zï¿½ï¿½JMCFï¿½Nhï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½q3ï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½3Xxï¿½	=ï¿½ï¿½ï¿½ï¿½Í³
ï¿½ï¿½ï¿½Gs7VÑ€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!Ë²3-?Eï¿½ï¿½(=ï¿½ï¿½ï¿½uÅ£ï¿½dï¿½oï¿½9ï¿½ï¿½ï¿½Bï¿½ ï¿½8~ï¿½eï¿½
ï¿½ï¿½H×ŸÎ/ï¿½ÆºÚ¼LJG}:ï¿½dtï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½\ï¿½ï¿½gï¿½Qï¿½-ï¿½oï¿½ï¿½ï¿½gï¿½,N×¯ï¿½{nï¿½B8ï¿½Q$O::ï¿½Oï¿½8_ï¿½}Wï¿½Nï¿½ï¿½ï¿½Ulï¿½ï¿½ï¿½&ï¿½ï¿½Qvï¿½ï¿½gï¿½ï¿½__Bï¿½^r)-ï¿½ï¿½ï¿½ï¿½ï¿½/ï¿½Iï¿½Cï¿½2ï¿½ï¿½3ï¿½Iï¿½GTï¿½ï¿½ï¿½'ï¿½ï¿½Bï¿½yï¿½ï¿½;ï¿½ivXrï¿½ï¿½ï¿½[Lï¿½ï¿½ï¿½gMï¿½E?Ë–-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aGCï¿½ï¿½?ï¿½ï¿½A:ï¿½pï¿½ï¿½Å’ï¿½zï¿½ï¿½Ò¥K%Â£%.ï¿½uN^}ï¿½ï¿½Eï¿½ï¿½ï¿½}\ï¿½ï¿½ï¿½8t1ï¿½ï¿½ï¿½|ï¿½!ï¿½ï¿½ï¿½yï¿½vï¿½9sï¿½ï¿½ï¿½eï¿½ï¿½ï¿½lï¿½Q7ï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½zï¿½QCï¿½ï¿½>ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{6\ï¿½i"L9ï¿½ï¿½ï¿½ï¿½t4ï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ì´œï¿½"ï¿½ ï¿½"Ç½ï¿½ï¿½ï¿½ï¿½ï¿½9?)$Cï¿½Cyï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½y5ï¿½ï¿½ï¿½ièŽ£ï¿½QOZpï¿½ï¿½ï¿½ï¿½EZ8ï¿½uÑ8-ç·ˆï¿½ï¿½ï¿½Dï¿½0ï¿½}Xï¿½Aï¿½	ï¿½ï¿½ï¿½;ï¿½b $Hï¿½ï¿½ï¿½zï¿½ï¿½<ï¿½}9ï¿½;ï¿½ï¿½ï¿½NÎ˜ï¿½ï¿½ï¿½ï¿½Wï¿½5gï¿½Û‘vï¿½ã´ˆï¿½Ïiï»Ÿï¿½sï¿½kï¿½tï¿½ï¿½'ï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½>S\ï¿½ï¿½qï¿½mm>ï¿½}9ï¿½V{['Gï¿½4ß€0}ï¿½-ï¿½fï¿½1ï¿½ÂŽr ï¿½ï¿½JNï¿½M8ï¿½ï¿½Ï‘vï¿½wï¿½ÒªUï¿½ï¿½8#ï¿½ï¿½sï¿½tcJï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½{qmï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½Ç™ï¿½ï¿½ï¿½ï¿½jï¿½#ï¿½#.Jlï¿½6(.aPÂï¿½50 ï¿½ï¿½ï¿½Vï¿½ ï¿½Eï¿½ï¿½ï¿½iï¿½ï¿½ï¿½-ï¿½ï¿½ï¿½qï¿½ï¿½ï¿½ï¿½^cï¿½ï¿½ï¿½ï¿½:"ï¿½ï¿½@ï¿½}\]&ï¿½dMï¿½ï¿½Vhï¿½ï¿½ï¿½ï¿½ï¿½\N0QWï¿½Zï¿½ï¿½nï¿½]ï¿½:iï¿½ï¿½ï¿½KgÈ±KØ¸-ï¿½=ï¿½ï¿½ï¿½ï¿½zï¿½ï¿½mï¿½s`ï¿½ï¿½6vï¿½Wï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Xeï¿½ï¿½OÖ‡ï¿½ï¿½ï¿½J&Cï¿½Qï¿½9nï¿½Xï¿½ï¿½ ï¿½wï¿½ !;>ï¿½rziyï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½È‘ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½&G<Å½ï¿½Kï¿½+ï¿½ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½:ï¿½ï¿½sï¿½ï·¿ï¿½mN~ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6aï¿½ï¿½ï¿½ï¿½+^N	ï¿½ï¿½AEï¿½k/ï¿½+ï¿½ï¿½ï¿½ï¿½EMMï¿½8F!Lï¿½ï¿½ï¿½aMu5ï¿½wï¿½Yï¿½& Ò¢Hf<ï¿½=ï¿½%ï¿½z\Bï¿½ï¿½*ï¿½n`r56ï¿½ï¿½ï¿½)Kw<ru\ÙŽ)ï¿½ï¿½>rï¿½fï¿½ï¿½ï¿½ï¿½Ã€5ï¿½Uï¿½;.Æ…"ï¿½.CIï¿½&ï¿½ï¿½"ï¿½ï¿½qï¿½YCï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½1TQ5ï¿½ï¿½ï¿½oï¿½:ï¿½ï¿½ï¿½<.ï¿½ï¿½.ï¿½|aï¿½an8ì“¯ï¿½Ã¦TN-ï¿½Lï¿½{a0ï¿½ï¿½Vï¿½ï¿½ï¿½Îµï¿½pï¿½$ï¿½8ï¿½HQï¿½ï¿½ï¿½ï¿½Aï¿½Ê²ï¿½Ã–kï¿½ï¿½~ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½Ç•ï¿½Ú¯ï¿½ï¿½`Sï¿½T|Xï¿½0ï¿½ï¿½dï¿½Ê¬+&>ï¿½*ï¿½Bï¿½[u4ï¿½ï¿½gzï¿½ï¿½Ï±ï¿½ï¿½zï¿½yï¿½ï¿½Qï¿½ï¿½ï¿½&N_[ï¿½}Ì¼ï¿½ï¿½kZÉ³ï¿½cP(ï¿½Xï¿½Lï¿½5ï¿½ï¿½ï¿½sï¿½ï¿½<ï¿½ï¿½ï¿½ 
ï¿½ï¿½uï¿½ï¿½Wï¿½Cï¿½ï¿½ï¿½ãkï¿½ï¿½ï¿½8ï¿½ï¿½NNd
B_wï¿½8+ï¿½ qï¿½ï¿½z+ï¿½ï¿½ï¿½$ï¿½"*A,`ï¿½,ï¿½ï¿½ï¿½<ï¿½ÍŒ.ï¿½ï¿½ï¿½'Ó¬@ï¿½ï¿½Nï¿½ï¿½ï¿½@ï¿½8ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½j:]Dï¿½ï¿½<ï¿½+ï¿½mVï¿½(ï¿½ï¿½6ï¿½(ï¿½xï¿½ï¿½ï¿½f*Wï¿½i_^\ï¿½>ï¿½ï¿½Qï¿½d}{r\g@ï¿½Zï¿½sï¿½4Pq/Lï¿½Kï¿½ï¿½ï¿½Uï¿½Aï¿½W"ï¿½ï¿½Þš0qï¿½65ï¿½ï¿½Oï¿½]Ï‰3B|ï¿½b1ï¿½ï¿½H)1'1r
ï¿½Pï¿½xï¿½ï¿½*ï¿½ï¿½Imï¿½ï¿½%ï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½jxï¿½iï¿½*ï¿½ï¿½mkï¿½ï¿½sfï¿½*U%wï¿½ï¿½APï¿½ï¿½ï¿½ï¿½ï¿½Ag-ï¿½$ï¿½éŽ¡ï¿½ï¿½;V>?ï¿½Jï¿½ï¿½ ï¿½Wl~ï¿½m\ï¿½ï¿½ï¿½ï¿½Ü¯ï¿½ï¿½ï¿½Û¸ê±—8J&<ï¿½3ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç“ï¿½7ï¿½ï¿½
cï¿½aï¿½ï¿½.Í˜	ax6ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*ï¿½pï¿½>ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½ypï¿½ï¿½t2ï¿½ï¿½3ï¿½#Sï¿½X&ï¿½ï¿½v2iï¿½ï¿½ ï¿½
Cï¿½Ä²Lï¿½ï¿½1ï¿½x)ï¿½x&|ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½,ï¿½ï¿½
Û™Vï¿½qï¿½ï¿½ï¿½vï¿½n.ï¿½ï¿½v C!X ï¿½ï¿½qÓ*vNï¿½ï¿½lï¿½ï¿½VQmï¿½Y@ï¿½ï¿½E|5ï¿½ï¿½ï¿½ ï¿½ï¿½zï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç•ï¿½Vï¿½+É½ï¿½hï¿½ï¿½ï¿½K{ï¿½ï¿½ï¿½;U%bï¿½ï¿½#ï¿½7ï¿½ï¿½ï¿½ï¿½jï¿½jï¿½ï¿½jï¿½WTpï¿½ï¿½Gï¿½R?.ï¿½ï¿½ï¿½Imï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½3^nWï¿½ï¿½n,ï¿½ï¿½Ð°ï¿½gï¿½D\ï¿½}C9#qx
ï¿½ï¿½mï¿½
ï¿½13ï¿½ï¿½ï¿½@#Fï¿½Sooï¿½ï¿½wRwOï¿½ï¿½ï¿½rc"<ï¿½[^VFUÃªï¿½ï¿½!ï¿½ï¿½ï¿½Ctï¿½ï¿½ï¿½ï¿½Xfï¿½Å—e ï¿½ï¿½Ð¡kï¿½ÐŸÇ­ï¿½ï¿½ï¿½ï¿½ï¿½r;v4ï¿½tjï¿½8ï¿½:+ï¿½5iï¿½ï¿½%ï¿½Å´gï¿½>vîž¤|ï¿½ï¿½ï¿½@ï¿½ï¿½9ï¿½Ï’5[N+ï¿½+hï¿½ï¿½qtï¿½ï¿½ï¿½ï¿½ï¿½a7Â¦3ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½,#ï¿½~#~ï¿½zï¿½ï¿½Kï¿½ï¿½ï¿½|ï¿½Ï¡ï¿½ï¿½ ï¿½ï¿½ï¿½qï¿½ï¿½8lï¿½KW\ï¿½ï¿½ï¿½ï¿½c8ï¿½vwï¿½1Û‚6h;vï¿½(G#[ï¿½ï¿½Pkï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½=Lï¿½ï¿½Sï¿½Ãšï¿½ï¿½ï¿½Yï¿½uï¿½Aï¿½@ï¿½]ï¿½8ï¿½ï¿½ï¿½ï¿½Ñœï¿½Vï¿½ï¿½yGï¿½ï¿½ï¿½ï¿½Wr^!ï¿½ï¿½ï¿½mï¿½hcXï¿½={ï¿½ï¿½<.bï¿½ï¿½=ï¿½5ï¿½ï¿½ï¿½-ï¿½ï¿½Ø¾}|ï¿½ï¿½ï¿½Bï¿½ZZZï¿½Ý†ï¿½Bï¿½ï¿½myVA#nï¿½ï¿½ï¿½g>sï¿½ï¿½"nï¿½
ï¿½ï¿½jï¿½ï¿½ï¿½+ï¿½ï¿½5ï¿½^ï¿½Úµ{/ï¿½xï¿½ï¿½8ï¿½ï¿½sÎ¤ï¿½Æï¿½G{"ï¿½sØ‰ï¿½ï¿½Vï¿½mï¿½ï¿½ï¿½oï¿½Yqï¿½dï¿½ï¿½bvï¿½Lï¿½*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½7ï¿½Cï¿½5"rï¿½ï¿½
ï¿½ï¿½ï¿½pÚ¹gï¿½ï¿½:/ï¿½u+^]ï¿½Ó‚d7bÑ¢ï¿½ï¿½m7ï¿½ï¿½Gï¿½ï¿½Y@ï¿½ï¿½ï¿½ï¿½Sï¿½ï¿½~p7ï¿½Í£ÎŸw^(zï¿½ï¿½QCï¿½ï¿½eï¿½ï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½V(ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½6ï¿½2ï¿½Yï¿½uZï¿½ï¿½ï¿½[ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,, ï¿½ï¿½ï¿½ï—”ï¿½ï¿½ï¿½gS1ï¿½ï¿½=?ï¿½Û‘`ï¿½ï¿½gï¿½?zï¿½9nï¿½ï¿½ï¿½,ï¿½#ï¿½jï¿½VÔï¿½iï¿½ï¿½o ï¿½ï¿½%xï¿½ï¿½'ï¿½Dï¿½ï¿½ï¿½ï¿½___o3ï¿½Ó¿ï¿½|3Nï¿½tï¿½=ï¿½g3pï¿½Xï¿½/ï¿½ï¿½"ï¿½ï¿½ï¿½@ï¿½ï¿½s\^ï¿½ï¿½ï¿½d1ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½yï¿½9n
ï¿½ï¿½-7ï¿½_Þ£Î‹ï¿½ï¿½n~ï¿½Lw#ï¿½ï¿½y.ï¿½ZQï¿½ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Muï¿½9ï¿½y=lï¿½ï¿½5bDï¿½ï¿½`8.ï¿½Gï¿½8/G^L(ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½nï¿½ï¿½ï¿½%ï¿½ï¿½ï¿½ï¿½,ï¿½ 8hï¿½+ï¿½ï¿½Gï¿½9ï¿½ï¿½ï¿½t'ï¿½Mk;ï¿½ï¿½ï¿½r^<ï¿½0eï¿½ï¿½usï¿½ ï¿½Ö¯x#ï¿½'<xï¿½ï¿½o~Mï¿½ï¿½ï¿½Bw#.ï¿½Õ‰ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½g"ï¿½Fï¿½ï¿½ï¿½kï¿½ï¿½:ßˆï¿½-/ï¿½ï¿½Nï¿½Ç %+gï¿½uN2RTï¿½ï¿½ï¿½Tï¿½nï¿½ï¿½ï¿½8ç½›ï¿½#/ï¿½ï¿½ï¿½ï¿½?6ï¿½3xï¿½ï¿½Jï¿½ï¿½qï¿½0ï¿½jVï¿½F^Å½Ð—ï¿½M5ï¿½*lEï¿½ï¿½ï¿½ÚŽï¿½ï¿½Q
ï¿½ï¿½wï¿½Vï¿½ï¿½Î«ï¿½
kï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½ï¿½<Xï¿½Dï¿½[0É’6ï¿½G^3Ï©ï¿½ß¨ï¿½ï¿½^?Iï¿½^ï¿½ï¿½ï¿½qï¿½ï¿½B\Nï¿½ï¿½+ï¿½
ï¿½gï¿½ï¿½#ï¿½j9xï¿½ï¿½ï¿½y?7`ï¿½ï¿½bï¿½ï¿½
T[[PRï¿½<hï¿½ï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½ï¿½uï¿½Mkï¿½ï¿½ï¿½ï¿½9Pï¿½ï¿½	ï¿½ï¿½ï¿½ï¿½q|ï¿½ï¿½}gï¿½6zyyiï¿½ï¿½ï¿½ï¿½ï¿½sR!]@Xï¿½R:;;ï¿½nWYi)ï¿½ï¿½ï¿½ï¿½n
%ï¿½O8-ï¿½ï¿½xï¿½m_Î¼QÄ™ï¿½Hï¿½ï¿½ï¿½ï¿½apRï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wÅŠï¿½ï¿½ï¿½Ï¿iï¿½ï¿½9ï¿½ï¿½|Aï¿½Fq\,ï¿½ï¿½ï¿½ERWWï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ð‹ï¿½ï¿½ï¿½
ï¿½TR\ï¿½ï¿½ï¿½ï¿½i'L<ï¿½ï¿½ï¿½Û©ï¿½~8Kï¿½JPdï¿½ï¿½Gï¿½wï¿½ï¿½?ï¿½O/ï¿½ï¿½ï¿½ï¿½3ï¿½RÍ·wï¿½sï¿½%ï¿½"ï¿½ï¿½ï¿½b`ï¿½ï¿½y#9ÂŸï¿½9ï¿½Ã‘2tï¿½ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½Wï¿½Ïš5Kï¿½vÂ„ï¿½ï¿½ï¿½ï¿½3ï¿½ï¿½q\3ï¿½ï¿½ï¿½ï¿½Gï¿½+^ï¿½ï¿½á¼™Î¿ï¿½ï¿½ï¿½?ï¿½ï¿½Ãï¿½ï¿½Tqï¿½p<ï¿½xï¿½ï¿½aï¿½Ó9Bï¿½ï¿½ï¿½ï¿½(ï¿½fï¿½xï¿½ï¿½ï¿½ï¿½#ï¿½Dï¿½Vï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½ï¿½"/;ï¿½D\xnï¿½ï¿½_ï¿½ï¿½ï¿½2ÇŽNï¿½uÂ¹8ï¿½|ï¿½F}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½DNï¿½iVï¿½\ï¿½>-ï¿½ï¿½ï¿½{]ï¿½Ê§ï¿½ï¿½pï¿½=ï¿½3je9ï¿½ï¿½Oï¿½Qï¿½ï¿½ï¿½ï¿½>ï¿½Yï¿½ï¿½ï¿½qï¿½ï¿½qï¿½1ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½7ï¿½Gï¿½ï¿½ï¿½nï¿½yï¿½]wGÍˆAï¿½Ãœï¿½qï¿½Wï¿½Ë¼oï¿½mï¿½ï¿½ï¿½ï¿½C~ï¿½ï¿½wï¿½SÏ¿8ï¿½o;ï¿½Jwï¿½qU9KYq<OEWï¿½ï¿½PÕŠï¿½ï¿½Z@ï¿½;ï¿½ï¿½Oï¿½ï¿½gï¿½gï¿½ï¿½?ï¿½#ï¿½\ï¿½ï¿½ï¿½O{ï¿½Î™ï¿½nï¿½ï¿½ï¿½(Wzï¿½ï¿½OJ7ï¿½Fï¿½Cï¿½pï¿½RÞ¢ï¿½ve/oSb{ï¿½ï¿½{#2pD\\ï¿½`gï¿½ï¿½ï¿½Wï¿½Cï¿½qÍ¾4ï¿½21ï¿½ï¿½LÂ‘ï¿½-ï¿½Gï¿½JkuFuï¿½
~!ï¿½j;ï¿½ï¿½ ï¿½-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'ï¿½7ï¿½ï¿½6YNï¿½ï¿½
Mï¿½ï¿½ï¿½ï¿½vï¿½ceï¿½ï¿½4+(^hKHEï¿½ï¿½ï¿½Ç€Z Nï¿½ï¿½ï¿½ï¿½fï¿½hï¿½?D^Lï¿½wï¿½ï¿½tï¿½ï¿½ï¿½ï¿½<ï¿½`ï¿½dï¿½ï¿½ï¿½$#3ï¿½iiVï¿½i[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½N
ï¿½Q=ï¿½s\ï¿½=Öˆï¿½ï¿½;8(ï¿½F\ãœˆï¿½ï¿½ï¿½P#ï¿½ï¿½^ï¿½HWï¿½Ô•ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½gu:ï¿½Gï¿½:ï¿½ï¿½=Vï¿½lï¿½;Sï¿½<ï¿½ï¿½ï¿½mVï¿½ Wï¿½kï¿½8`ï¿½rï¿½S-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½qï¿½GÜ“ï¿½"ï¿½ï¿½+IO9ï¿½ï¿½jï¿½Md;ß™ï¿½;ï¿½ï¿½ï¿½ï¿½QqRï¿½rï¿½ï¿½ÚŠï¿½"-w\ï¿½ECï¿½ï¿½6ï¿½xï¿½ï¿½r\ï¿½lï¿½ï¿½IqIï¿½%(>dg,R\,tï¿½ï¿½ï¿½yTFwï¿½ï¿½ï¿½ <ï¿½ï¿½!mï¿½8ï¿½ï¿½\ï¿½?ï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½69á¬¤ï¿½ur['ï¿½ï¿½Hï¿½,ï¿½ï¿½7ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½qï¿½ï¿½ï¿½?Iï¿½ï¿½s\ï¿½,.r5ï¿½ï¿½ï¿½k0:ï¿½Eeï¿½Z ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ç¸ºï¿½ï¿½F\'vï¿½ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½=ï¿½ï¿½;o'ï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½&ï¿½ï¿½gï¿½ï¿½ï¿½}s\^'ï¿½Zï¿½yaJï¿½Quæ ´ï¿½<ï¿½eï¿½ï¿½ï¿½-ï¿½g;ß™ï¿½{r\dï¿½ï¿½Eq/T.o=:EQï¿½ï¿½9ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½:2MQï¿½jF3ahÌ›ï¿½ï¿½1ï¿½ï¿½;ï¿½*8Î NaC5ï¿½cï¿½+ï¿½GGï¿½ÒƒBï¿½Bï¿½vï¿½pï¿½ï¿½mï¿½ï¿½ï¿½}bï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½cSuï¿½@×¥* ru:oï¿½ï¿½ï¿½;g~Lï¿½Sï¿½ï¿½ï¿½ï¿½Z7ï¿½ï¿½ï¿½qï¿½ï¿½Cï¿½ï¿½?ï¿½ ï¿½
ï¿½Å¸ï¿½ï¿½ï¿½8ï¿½ ï¿½ï¿½ï¿½ï¿½×Ÿï¿½ï¿½>ï¿½zï¿½ï¿½MCB_qÔï¿½+ï¿½ï¿½$ï¿½ï¿½4ï¿½5ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½Qï¿½ï¿½H<ï¿½ï¿½Kï¿½T&iï¿½ï¿½ï¿½:ï¿½B
ï¿½ï¿½;CV3ï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½w>\ï¿½<==Ö€;uï¿½xï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½;ï¿½QGWï¿½wï¿½ZÚºiË®6ï¿½ï¿½ï¿½~ï¿½jHvï¿½kï¿½ï¿½fï¿½ï¿½wï¿½^ï¿½ï¿½7-xï¿½Qgwuï¿½ï¿½ï¿½|<ï¿½ï¿½/ï¿½ï¿½<ï¿½ï¿½GÚï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½stï¿½Sï¿½Oï¿½qï¿½ï¿½x4ï¿½ï¿½ï¿½ï¿½ï¿½Ï¡1ï¿½É.ï¿½ï¿½Thï¿½ï¿½ï¿½ï¿½Apå‡¾ï¿½ï¿½ï¿½ï¿½ï¿½VÓºï¿½ï¿½,ï¿½e~ï¿½Eï¿½ï¿½-9ï¿½Úï¿½ï¿½?{ï¿½ï¿½_ï¿½ï¿½ï¿½'ï¿½V&ï¿½W.ï¿½(8>^Yï¿½L?|x
:ï¿½C#ï¿½Wï¿½ï¿½[Ï£)'ï¿½S[g}ï¿½gï¿½Ñ³ï¿½ï¿½ÞŠï¿½ï¿½ï¿½ï¿½x}ð²©´|ï¿½ï¿½ï¿½ï¿½^ï¿½ï¿½tï¿½ï¿½ï¿½|ï¿½ï¿½ï¿½#W6ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½ï¿½^ï¿½0ï¿½ï¿½e!ï¿½zRï¿½ï¿½vï¿½nï¿½ï¿½
Úºï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Dï¿½fï¿½+ï¿½1ï¿½ï¿½/_ï¿½6HÞ’ï¿½ï¿½{ï¿½
ï¿½w"ï¿½ï¿½ï¿½&ÆšOï¿½
q3ï¿½ï¿½vfWï¿½
&	]ze
ï¿½ï¿½ï¿½Ñ‹ï¿½ï¿½xï¿½{ï¿½ï¿½ï¿½}pï¿½ï¿½ï¿½ï¿½.ï¿½?ï¿½>{ï¿½ï¿½3}$;qï¿½^ï¿½ï¿½ï¿½ï¿½â´¥%ï¿½ï¿½`ï¿½Cï¿½ï¿½ï¿½ï¿½kï¿½yï¿½aw4~i;Õ³ï¿½ï¿½[ï¿½ï¿½ï¿½?ï¿½#zï¿½ï¿½ï¿½ï¿½gï¿½Eï¿½`ï¿½ï¿½dï¿½ï¿½?ï¿½@^{ï¿½Yï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½+ï¿½k1Eï¿½ï¿½`'=ï¿½ï¿½&^ï¿½Eï¿½ï¿½ï¿½,N;wï¿½hï¿½ï¿½ï¿½ï¿½ï¿½VÓ½ï¿½YK+ï¿½5}0ì§±ï¿½5ï¿½d1ï¿½ï¿½$:ï¿½ï¿½Wï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½-ï¿½+WQï¿½Oï¿½ÅŠï¿½`ï¿½ï¿½}ï¿½)|Í¦ï¿½8ï¿½ï¿½ï¿½ï¿½h2ï¿½=sUUï¿½Ñ¿ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½5ï¿½ï¿½0GÖ²2^Qï¿½jï¿½\0ï¿½>ï¿½x=ï¿½ï¿½Vï¿½ï¿½ï¿½_ï¿½g^ï¿½Eï¿½ï¿½ï¿½lï¿½ï¿½KÛ¤ï¿½ï¿½ï¿½
ÇŸï¿½Qsï¿½ï¿½fzbï¿½6ï¿½ï¿½qBï¿½ï¿½?xï¿½ï¿½T_SFï¿½-ï¿½ï¿½8ï¿½'ï¿½Wï¿½ï¿½lï¿½ï¿½ß¶qï¿½~ï¿½ï¿½zuï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½zsï¿½Aï¿½ï¿½oï¿½<ï¿½ï¿½Ó—Ã´zï¿½ï¿½=ï¿½qPì‡ˆï¿½y	2ï¿½0cï¿½ï¿½ï¿½rï¿½ï¿½pï¿½k(ï¿½JWï¿½eï¿½Gï¿½Ö‰ï¿½ï¿½ï¿½ï¿½ï¿½DUfvSï¿½dß ~/ï¿½:ï¿½zï¿½Ëžï¿½ï¿½fï¿½wï¿½_I;ï¿½!D0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4v>Dï¿½ï¿½ï¿½ï¿½NKï¿½ï¿½ï¿½]ï¿½Ìœ2\ï¿½oï¿½d^È‡ï¿½vï¿½ï¿½.7ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Î†ï¿½ï¿½4ï¿½Fï¿½ï¿½ï¿½ï¿½`ï¿½Oï¿½ï¿½ï¿½uï¿½4}Bï¿½È›zï¿½yï¿½*roï¿½ï¿½?ï¿½[IXï¿½Uï¿½ï¿½|ï¿½iï¿½1äºƒe?ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Uï¿½;^jï¿½å®Bï¿½ï¿½K8+Ñ¶ï¿½ï¿½zMï¿½sï¿½6ï¿½ï¿½ï¿½_&9ï¿½mï¿½ï¿½ï¿½'6ï¿½)yï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½ï¿½Zï¿½a?]:b<=ï¿½ï¿½nj=ï¿½-N=ï¿½xï¿½o_H5ï¿½ï¿½Wï¿½9ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|Ñ‡2ï¿½|ï¿½ï¿½&
ï¿½oAtï¿½ï¿½ï¿½ï¿½ï¿½ï¿½N|ï¿½Dï¿½ï¸„&ï¿½ï¿½ï¿½/ï¿½ï¿½èƒ‹ï¿½ï¿½ï¿½ï¿½ï¿½3ï¿½ï¿½_ï¿½ï¿½ï¿½0ï¿½[ï¿½ï¿½Lï¿½ï¿½ï¿½\pcitï¿½ï¿½ï¿½ ï¿½ï¿½F>1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½g>ï¿½rï¿½3gï¿½tï¿½,ï¿½rï¿½Â‰ï¿½è³›ï¿½?yï¿½~ï¿½ï¿½zï¿½Ä»ï¿½=ï¿½ï¿½ÞŠn6ï¿½ï¿½l ï¿½ï¿½ï¿½ï¿½ÎŸDï¿½<ï¿½ï¿½ï¿½ï¿½ï¿½iGï¿½ï¿½ï¿½ï¿½/ï¿½ï¿½Ç¯>ï¿½f8ï¿½"ï¿½ï¿½L&ï¿½8ï¿½]{ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½w$~aï¿½^ï¿½ï¿½=ï¿½(ï¿½ï¿½ï¿½ï¿½b/U"6?ï¿½Qï¿½ï¿½!ï¿½ÅºPï¿½7+.Wï¿½ï¿½Ø±ï¿½"
'ï¿½ï¿½p0 ï¿½Wo:ï¿½ï¿½}ï¿½kreï¿½ï¿½{ï¿½sgï¿½ï¿½]ï¿½@ï¿½:ï¿½{ï¿½//ï¿½ï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½ï¿½W3ï¿½ï¿½"3ï¿½ï¿½4Swï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/+vï¿½ï¿½ï¿½ï¿½Mï¿½ï¿½ï¿½4zeï¿½q:ï¿½ï¿½h)ï¿½M.ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½8ï¿½ï¿½Bï¿½Fï¿½ï¿½ï¿½?ï¿½dï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½l?ï¿½iï¿½ï¿½
ï¿½ï¿½ï¿½Fï¿½ï¿½+nï¿½.?uzï¿½Pï¿½ï¿½ZÉ¹ï¿½_ï¿½ï¿½a:cï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½G:ï¿½ÒCï¿½PWEï¿½Uï¿½ï¿½Kï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½}4zDï¿½DHIJ-z*ï¿½~ï¿½ï¿½ï¿½ï¿½Ó¨ï¿½Õœ&ï¿½Bï¿½ï¿½ï¿½rï¿½ï¿½Fï¿½ï¿½ï¿½Y9ï¿½ï¿½\ï¿½ï¿½
\ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½Aï¿½$ï¿½ï¿½Jï¿½ï¿½}ï¿½;[ï¿½ï¿½ï¿½ï¿½CMmï¿½cï¿½qDï¿½ï¿½ÙŠï¿½bï¿½-ï¿½Ç«*ï¿½y'ï¿½Fï¿½ï¿½ï¿½{ï¿½ï¿½Fï¿½ï¿½Mtï¿½F?ï¿½ï¿½eLCï¿½ï¿½0ï¿½ï¿½ï¿½%ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½Hï¿½ï¿½~ï¿½Y&ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½r\6]vï¿½]ï¿½Zï¿½ï¿½XIJï¿½ï¿½$0çˆ£wï¿½VsQ1ï¿½cs ï¿½ï¿½=ï¿½Vï¿½ï¿½Xï¿½ï¿½ï¿½r\ï¿½$r(ï¿½ï¿½[iï¿½t6Xcï¿½Bï¿½ï¿½ï¿½Wï¿½
ï¿½ï¿½WKXï¿½ï¿½8ï¿½ï¿½ï¿½'ï¿½ï¿½lLï¿½ï¿½
ï¿½ï¿½'Â†ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½x"'Kxï¿½ï¿½PMRHï¿½ï¿½ï¿½Mï¿½ï¿½=ï¿½ï¿½GO5#Iï¿½o .ï¿½ï¿½ï¿½/l{ï¿½ï¿½
1y	9ï¿½BYï¿½Åµ]}Kï¿½ï¿½ï¿½Â±q0ï¿½ï¿½Q
ï¿½>q'Jgï¿½ï¿½ï¿½ï¿½qCï¿½Pï¿½0ï¿½Øˆï¿½ï¿½2ï¿½~ï¿½ï¿½Zï¿½Ü¨ï¿½ï¿½F6ï¿½xï¿½â¹©ï¿½ï¿½ï¿½ï¿½Yï¿½pï¿½ï¿½ï¿½ï¿½jï¿½^ï¿½ZÅœï¿½lhn+y/ï¿½'(ï¿½ï¿½ï¿½ï¿½,qï¿½1ï¿½ÛŸï¿½n,Yï¿½ï¿½pï¿½|ï¿½ï¿½iO:ï¿½ï¿½ï¿½×žï¿½ï¿½ï¿½Bï¿½ï¿½H?ï¿½ï¿½".`ï¿½Sï¿½ï¿½Cï¿½+	ï¿½,ï¿½ï¿½+ï¿½ï¿½>ï¿½dï¿½ï¿½Hï¿½k
9fxBï¿½ï¿½Oï¿½7ï¿½>.k):ï¿½ÞŸï¿½ï¿½f*.(ï¿½ï¿½Y-ï¿½ï¿½ï¿½;ï¿½ï¿½Cï¿½ï¿½{ï¿½ï¿½ï¿½VB"Nbï¿½uï¿½ï¿½!]ï¿½ï¿½`ï¿½Ã….,
ï¿½jï¿½Gp(Ùï¿½
3hï¿½Qï¿½3<ï¿½qï¿½ï¿½ï¿½Y*ï¿½ï¿½aï¿½Iï¿½ï¿½-sï¿½ï¿½qï¿½3ï¿½ï¿½aï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½Cï¿½EWï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½/vï¿½ï¿½ï¿½ï¿½N`QrÂ€Pï¿½ï¿½ï¿½ï¿½ï¿½820ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½l{
ï¿½}xï¿½dï¿½Bï¿½ï¿½e|@ï¿½yr\ï¿½spFï¿½rï¿½ï¿½toÄï¿½<ï¿½ï¿½
ï¿½ï¿½jaï¿½/ï¿½Ð—nx`Dw&ï¿½crï¿½ï¿½ï¿½ï¿½Eï¿½U6ï¿½ï¿½ï¿½ï¿½ï¿½r\ï¿½4gï¿½ ï¿½Eï¿½ï¿½Å…b>ï¿½Nqï¿½ËŠï¿½cï¿½"ï¿½ï¿½Rï¿½qï¿½ï¿½uï¿½ï¿½ï¿½3ï¿½ï¿½\ï¿½_ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½Nï¿½9ï¿½nÄ…sï¿½%Muaï¿½ï¿½rLï¿½ï¿½ï¿½"Ý‡7ï¿½aï¿½mï¿½ï¿½*Bï¿½ï¿½ï¿½$ë²¢ï¿½
Y
ï¿½4ï¿½Wï¿½vï¿½ï¿½Aï¿½<ï¿½2Oï¿½ï¿½ebÂ»ï¿½ï¿½9ï¿½Ü[ï¿½{Pï¿½ï¿½dWï¿½ï¿½ Uï¿½ï¿½ï¿½Mï¿½Iï¿½/ï¿½ï¿½>Tï¿½gf$6>ï¿½]ï¿½ï¿½Oï¿½Þ“ï¿½cï¿½ï¿½ï¿½ï¿½sï¿½pï¿½ï¿½sï¿½hï¿½nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6ï¿½Ñ¾ï¿½ï¿½ï¿½ï¿½ï¿½y5Rï¿½dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½oï¿½)ï¿½ï¿½r*-ï¿½ï¿½ï¿½ï¿½Rï¿½ï¿½ï¿½1^q2ï¿½'ï¿½ï¿½ï¿½[h~`ï¿½fï¿½Qï¿½9.\ï¿½%ï¿½ï¿½0ï¿½ï¿½2Ç¡ï¿½ï¿½Ø¡ 1ï¿½^vï¿½ï¿½#ï¿½ï¿½ï¿½Fï¿½ï¿½TRZBï¿½ï¿½m`*ï¿½W*ï¿½,Ç¨ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½N\Fï¿½U5ï¿½Wï¿½ï¿½[ï¿½Caï¿½ï¿½ï¿½gï¿½~ï¿½ï¿½ï¿½ï¿½sï¿½|ï¿½45ï¿½ï¿½ï¿½BÃï¿½çºº:ï¿½Pï¿½~~cï¿½ï¿½ï¿½Ruu
ï¿½ï¿½ï¿½qDMWï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½!ï¿½_:ï¿½ï¿½J=ï¿½T];ï¿½eï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½Þ™ï¿½XNï¿½
ï¿½ï¿½qï¿½ï¿½].ï¿½9[ï¿½ï¿½ï¿½ï¿½Î¸ï¿½ï¿½hï¿½ï¿½ï¿½pï¿½ï¿½QLï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½i[ì¥ºï¿½j1ï¿½ï¿½ï¿½ï¿½ï¿½Vï¿½ï¿½&ï¿½ï¿½rï¿½ï¿½ï¿½ï¿½nï¿½ï¿½Ê¨ï¿½ï¿½ ï¿½Û³ï¿½Fï¿½Oeâ¼…1ï¿½Ø¨ï¿½ï¿½yCï¿½
0ï¿½ï¿½#Yï¿½ï¿½ï¿½9ï¿½ï¿½0	fï¿½ÅŽï¿½ï¿½ï¿½8ï¿½Mcï¿½Zh8Vfoo'ï¿½4ï¿½ï¿½ï¿½ï¿½ï¿½Ð¨Qchï¿½ï¿½1ï¿½ï¿½ï¿½Cï¿½[[WÇ²FÓ°ï¿½rÚ·{;Gaï¿½Fï¿½Bï¿½ï¿½>p:Prï¿½ï¿½Tï¿½Ýˆï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½\qï¿½(;Äªï¿½ï¿½ï¿½2ï¿½ï¿½ï¿½&ï¿½PHï¿½Qvï¿½ï¿½{wSÍ°a4rï¿½(ï¿½ï¿½ï¿½ï¿½yn<ï¿½4ï¿½ï¿½ï¿½Fï¿½ï¿½]ï¿½wQgGï¿½
ï¿½nï¿½Iï¿½'4?Hï¿½_\ï¿½+ï¿½lï¿½Eï¿½3ï¿½ï¿½ï¿½ï¿½JIï¿½,ï¿½ï¿½Ý¬hï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½*xï¿½Aï¿½ï¿½ï¿½Cï¿½|ï¿½-ï¿½Ó»;ï¿½ï¿½loo/ß²ï¿½WHï¿½ï¿½xî¢˜**Lï¿½
zG{;ï¿½3ï¿½u.'ï¿½ï¿½ï¿½DcC#mß¹ï¿½yï¿½=cï¿½?ï¿½9ï¿½ï¿½'ï¿½3Oï¿½Ì¹ï¿½	ï¿½ï¿½ï¿½ï¿½bHï¿½Hï¿½+ï¿½ï¿½Î¥ï¿½ï¿½ï¿½ZKï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½KK=5ï¿½ï¿½ï¿½8PQï¿½} ï¿½ï¿½|Aï¿½sï¿½Vj^Gï¿½ï¿½ï¿½dÐŽzï¿½ï¿½ï¿½ï¿½ï¿½c;^ï¿½+xfï¿½ï¿½1ï¿½ï¿½/ï¿½ï¿½ï¿½~ï¿½6lï¿½@---TSSM3fï¿½Fgï¿½9ï¿½,Nï¿½	ï¿½ï¿½ï¿½jï¿½dï¿½ï¿½ï¿½nï¿½ï¿½a^ï¿½WEï¿½=ï¿½ ï¿½0ï¿½ï¿½1~ï¿½uï¿½ï¿½ï¿½3ï¿½ï¿½=ï¿½ï¿½<B7ï¿½ï¿½ ï¿½ï¿½+ï¿½ï¿½kÄ•ï¿½ï¿½sï¿½ï¿½eRzï¿½ï¿½}rï¿½ï¿½ï¿½ï¿½Dï¿½Eï¿½Aï¿½5ï¿½
ï¿½KGï¿½ï¿½ï¿½ï¿½ï¿½Bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½[iï¿½[oï¿½ï¿½ï¿½ï¿½fjhlï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Aï¿½gÍ¢ï¿½~ï¿½ï¿½nyï¿½N7ï¿½Ö¬yï¿½Ö¯[Oï¿½9ï¿½=ï¿½ï¿½mQï¿½Kï¿½ï¿½sï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½gï¿½lg~Ç—ï¿½ï¿½ï¿½ï¿½nï¿½ï¿½sï¿½8ï¿½pï¿½Mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½iBï¿½<(ï¿½ï¿½ï¿½Ó¤ï¿½ï¿½ï¿½)x]oï¿½_ï¿½v
Íš}6ï¿½>9ï¿½ï¿½\ï¿½:ï¿½9wï¿½\ï¿½ï¿½ ï¿½<ï¿½_ï¿½ï¿½ï¿½ï¿½kï¿½ï¿½Í¸YS-ï¿½ï¿½ï¿½]@3gÎ¤uï¿½ï¿½Ñ“O>Isï¿½Î¥3ï¿½<ï¿½wï¿½ï¿½ï¿½ï¿½ï¿½6mzï¿½ï¿½Oï¿½Nsï¿½=ï¿½ï¿½vpï¿½-ï¿½ ï¿½pï¿½Û¾cï¿½7ï¿½ï¿½Gaï¿½Pï¿½,Ø˜ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½:ï¿½ï¿½?ï¿½å¸†ï¿½p_ï¿½x1<#:4ï¿½ï¿½ï¿½8 W|ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½ï¿½pG9ï¿½C:S0ï¿½tï¿½ï¿½8ï¿½ï¿½ï¿½\ï¿½J<ï¿½ï¿½ï¿½ï¿½ï¿½)Sï¿½ï¿½)ï¿½ï¿½ï¿½3~Ø¤ï¿½&Nï¿½ ï¿½ï¿½IÝ½{7Mcï¿½mimï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½ï¿½!ï¿½~ï¿½ï¿½ï¿½Â˜ï¿½+uÈƒ0~ï¿½ï¿½ï¿½?ï¿½ï¿½rï¿½ aï¿½bï¿½ï¿½0)oï¿½ï¿½ï¿½Wï¿½ï¿½(ï¿½8f8|ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½kjiÜ¸SXï¿½ï¿½^ï¿½Sï¿½[ï¿½|ï¿½ï¿½Ã¹0Qï¿½Zï¿½ï¿½xXï¿½ï¿½ÍŸTï¿½W]wï¿½uï¿½6ï¿½{Ø‰ï¿½*ï¿½ï¿½ï¿½krï¿½bÞ¼y>ï¿½ï¿½}ï¿½ï¿½ï¿½[ï¿½ï¿½ß‰sï¿½!ï¿½-qï¿½ ï¿½wï¿½ï¿½ï¿½sï¿½8mÜ¸Aï¿½2ï¿½ï¿½aï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½>.[ï¿½Wï¿½>ï¿½ï¿½_ï¿½ï¿½zï¿½Ù§8:ï¿½ï¿½Lï¿½ï¿½[ï¿½ï¿½Â€x0;ï¿½ï¿½ï¿½ NGNï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½.ï¿½6oï¿½$<ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½GÛ·mKï¿½ï¿½ï¿½ï¿½nï¿½{9oï¿½ï¿½ï¿½ï¿½ï¿½gÏ®ï¿½ï¿½sOÑ²ï¿½~ï¿½h|ï¿½ï¿½ï¿½ï¿½quqï¿½Eï¿½pï¿½	ï¿½ï¿½ï¿½6Nï¿½i6ï¿½,ï¿½&rï¿½w~ï¿½[ï¿½ï¿½_vÅ•|:E5ï¿½uï¿½ï¿½ï¿½bWEUu !ï¿½uhã¼´ï¿½ï¿½ï¿½/ï¿½pÑ”Xï¿½#;ï¿½&ï¿½cï¿½ï¿½ï¿½Ò†ï¿½%ÚŽ;ï¿½ï¿½Sè¥‰ï¿½&ï¿½Ô©SyPbIWï¿½Ñ¾>vï¿½4~Â©ï¿½9ï¿½aï¿½(ï¿½@C<Hï¿½ï¿½#mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½P(ï¿½|gÒ¾hï¿½ï¿½
ï¿½ï¿½qï¿½ï¿½
/ï¿½Þ±ï¿½Æ‡>ï¿½ï¿½2ï¿½o@ï¿½8Ü¯ï¿½ï¿½755ï¿½E]Dï¿½ï¿½~:ï¿½ï¿½ï¿½$<M5ï¿½[?ï¿½ï¿½Lï¿½yï¿½`ï¿½xNg|JG×;wÒªï¿½+Yï¿½Ytê©“ï¿½ï¿½z+vÖ®ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½qq1ï¿½ï¿½ï¿½ï¿½áˆŽï¿½oQ1~ï¿½ï¿½Xï¿½|ï¿½ï¿½*lyï¿½Ý»ï¿½ï¿½|ï¿½Mzï¿½ï¿½ï¿½4ï¿½ï¿½Aï¿½ï¿½ï¿½EMï¿½ï¿½%!
ï¿½
ï¿½ï¿½Îï¿½ï¿½ï¿½R^ï¿½`ï¿½Lï¿½r*}ï¿½ï¿½_ï¿½S}Õ°ï¿½ï¿½ï¿½CDï¿½ï¿½ZRR*ï¿½^HZ[[y[m
}ï¿½/ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½beï¿½ï¿½ï¿½ê®ï¿½hï¿½ï¿½-tï¿½y?ï¿½:ï¿½ï¿½ï¿½vÂŽï¿½9ï¿½ï¿½	ï¿½Yï¿½ï¿½xZl×®ï¿½ï¿½ï¿½ï¿½ï¿½Ã¼ï¿½rï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½a:ï¿½ï¿½ï¿½:ï¿½ï¿½ï¿½ï¿½~z/ç¸·Hï¿½ll)[_ï¿½a>ï¿½]]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½uoï¿½ï¿½Õ«N(ï¿½ï¿½tï¿½ï¿½dÔ¨ï¿½ï¿½Å»ï¿½ï¿½>^ï¿½?ï¿½ï¿½=Kï¿½yï¿½ï¿½ï¿½ï¿½`|'lë–­tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½JXï¿½]ï¿½ï¿½ï¿½Dï¿½ï¿½
ï¿½={vï¿½ï¿½Uï¿½ï¿½'ï¿½ï¿½_ ï¿½ï¿½vï¿½ï¿½OJoï¿½Úª)ï¿½ï¿½ï¿½&ï¿½|ï¿½ï¿½ï¿½<ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½Lï¿½|ï¿½#ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½{qAï¿½ï¿½ï¿½fï¿½ï¿½"8pï¿½ï¿½ï¿½Ù´ï¿½}ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½_ï¿½L'ï¿½Dï¿½ï¿½ï¿½U`ï¿½ï¿½*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Sgì‰¨dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Oragï¿½ï¿½/ï¿½'ï¿½e;ï¿½ï¿½ë¼¯ï¿½W.ï¿½ï¿½ï¿½oï¿½mÛ¶ï¿½3|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ôž8Ç©ï¿½\K3>wW!,ï¿½)ï¿½Gï¿½Iï¿½Ã¿sï¿½ï¿½ï¿½JHï¿½1ï¿½ï¿½ï¿½!ï¿½ï¿½ï¿½'ï¿½rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½;sHRï¿½D+ï¿½ï¿½ï¿½c:ï¿½ï¿½&ï¿½Ê ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½ï¿½ï¿½Îï¿½EÅ˜Ôœï¿½2ï¿½ï¿½yï¿½+Sï¿½ï¿½ï¿½ï¿½Upï¿½ï¿½ï¿½*ï¿½9ï¿½Ç½ï¿½rNÌ£ï¿½nczï¿½A\ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½>.Åï¿½ï¿½
ï¿½[ï¿½fï¿½bsï¿½f.ï¿½ï¿½ï¿½#'{ï¿½ï¿½ï¿½ï¿½0ï¿½Gd'ï¿½ï¿½ï¿½ï¿½ï¿½AbDqï¿½tï¿½=ï¿½ï¿½qqï¿½ ï¿½  Aï¿½ï¿½ï¿½h6ï¿½0ï¿½ï¿½:ï¿½uï¿½8eï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½Fv`ï¿½ï¿½nÄ…ï¿½aHï¿½ï¿½8\ê³£ï¿½ï¿½'l

ï¿½ï¿½ï¿½ï¿½ï¿½E\ï¿½Fxdï¿½ï¿½yï¿½ï¿½ï¿½ï¿½ï¿½ï¿½A3h0    IENDï¿½B`ï¿½
--- END OF FILE 2025-06-18/server/resource-picker.png ---


--- START OF FILE 2025-06-18/server/resources.mdx ---
---
title: Resources
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to expose
resources to clients. Resources allow servers to share data that provides context to
language models, such as files, database schemas, or application-specific information.
Each resource is uniquely identified by a
[URI](https://datatracker.ietf.org/doc/html/rfc3986).

## User Interaction Model

Resources in MCP are designed to be **application-driven**, with host applications
determining how to incorporate context based on their needs.

For example, applications could:

- Expose resources through UI elements for explicit selection, in a tree or list view
- Allow the user to search through and filter available resources
- Implement automatic context inclusion, based on heuristics or the AI model's selection

![Example of resource context picker](/specification/2025-06-18/server/resource-picker.png)

However, implementations are free to expose resources through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Capabilities

Servers that support resources **MUST** declare the `resources` capability:

```json
{
  "capabilities": {
    "resources": {
      "subscribe": true,
      "listChanged": true
    }
  }
}
```

The capability supports two optional features:

- `subscribe`: whether the client can subscribe to be notified of changes to individual
  resources.
- `listChanged`: whether the server will emit notifications when the list of available
  resources changes.

Both `subscribe` and `listChanged` are optional&mdash;servers can support neither,
either, or both:

```json
{
  "capabilities": {
    "resources": {} // Neither feature supported
  }
}
```

```json
{
  "capabilities": {
    "resources": {
      "subscribe": true // Only subscriptions supported
    }
  }
}
```

```json
{
  "capabilities": {
    "resources": {
      "listChanged": true // Only list change notifications supported
    }
  }
}
```

## Protocol Messages

### Listing Resources

To discover available resources, clients send a `resources/list` request. This operation
supports [pagination](/specification/2025-06-18/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "resources/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "file:///project/src/main.rs",
        "name": "main.rs",
        "title": "Rust Software Application Main File",
        "description": "Primary application entry point",
        "mimeType": "text/x-rust"
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Reading Resources

To retrieve resource contents, clients send a `resources/read` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "resources/read",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "contents": [
      {
        "uri": "file:///project/src/main.rs",
        "name": "main.rs",
        "title": "Rust Software Application Main File",
        "mimeType": "text/x-rust",
        "text": "fn main() {\n    println!(\"Hello world!\");\n}"
      }
    ]
  }
}
```

### Resource Templates

Resource templates allow servers to expose parameterized resources using
[URI templates](https://datatracker.ietf.org/doc/html/rfc6570). Arguments may be
auto-completed through [the completion API](/specification/2025-06-18/server/utilities/completion).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "resources/templates/list"
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "resourceTemplates": [
      {
        "uriTemplate": "file:///{path}",
        "name": "Project Files",
        "title": "ðŸ“ Project Files",
        "description": "Access files in the project directory",
        "mimeType": "application/octet-stream"
      }
    ]
  }
}
```

### List Changed Notification

When the list of available resources changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/list_changed"
}
```

### Subscriptions

The protocol supports optional subscriptions to resource changes. Clients can subscribe
to specific resources and receive notifications when they change:

**Subscribe Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "resources/subscribe",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

**Update Notification:**

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "file:///project/src/main.rs",
    "title": "Rust Software Application Main File"
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Resource Discovery
    Client->>Server: resources/list
    Server-->>Client: List of resources

    Note over Client,Server: Resource Access
    Client->>Server: resources/read
    Server-->>Client: Resource contents

    Note over Client,Server: Subscriptions
    Client->>Server: resources/subscribe
    Server-->>Client: Subscription confirmed

    Note over Client,Server: Updates
    Server--)Client: notifications/resources/updated
    Client->>Server: resources/read
    Server-->>Client: Updated contents
```

## Data Types

### Resource

A resource definition includes:

- `uri`: Unique identifier for the resource
- `name`: The name of the resource.
- `title`: Optional human-readable name of the resource for display purposes.
- `description`: Optional description
- `mimeType`: Optional MIME type
- `size`: Optional size in bytes

### Resource Contents

Resources can contain either text or binary data:

#### Text Content

```json
{
  "uri": "file:///example.txt",
  "name": "example.txt",
  "title": "Example Text File",
  "mimeType": "text/plain",
  "text": "Resource content"
}
```

#### Binary Content

```json
{
  "uri": "file:///example.png",
  "name": "example.png",
  "title": "Example Image",
  "mimeType": "image/png",
  "blob": "base64-encoded-data"
}
```

## Common URI Schemes

The protocol defines several standard URI schemes. This list not
exhaustive&mdash;implementations are always free to use additional, custom URI schemes.

### https://

Used to represent a resource available on the web.

Servers **SHOULD** use this scheme only when the client is able to fetch and load the
resource directly from the web on its ownâ€”that is, it doesnâ€™t need to read the resource
via the MCP server.

For other use cases, servers **SHOULD** prefer to use another URI scheme, or define a
custom one, even if the server will itself be downloading resource contents over the
internet.

### file://

Used to identify resources that behave like a filesystem. However, the resources do not
need to map to an actual physical filesystem.

MCP servers **MAY** identify file:// resources with an
[XDG MIME type](https://specifications.freedesktop.org/shared-mime-info-spec/0.14/ar01s02.html#id-1.3.14),
like `inode/directory`, to represent non-regular files (such as directories) that donâ€™t
otherwise have a standard MIME type.

### git://

Git version control integration.

### Custom URI Schemes

Custom URI schemes **MUST** be in accordance with [RFC3986](https://datatracker.ietf.org/doc/html/rfc3986),
taking the above guidance in to account.

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Resource not found: `-32002`
- Internal errors: `-32603`

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "error": {
    "code": -32002,
    "message": "Resource not found",
    "data": {
      "uri": "file:///nonexistent.txt"
    }
  }
}
```

## Security Considerations

1. Servers **MUST** validate all resource URIs
2. Access controls **SHOULD** be implemented for sensitive resources
3. Binary data **MUST** be properly encoded
4. Resource permissions **SHOULD** be checked before operations

--- END OF FILE 2025-06-18/server/resources.mdx ---


--- START OF FILE 2025-06-18/server/slash-command.png ---
ï¿½PNG

   
IHDR  %   j   ï¿½Gz  ^iCCPICC Profile  (ï¿½uï¿½;HAï¿½ï¿½ï¿½h0ï¿½"ï¿½ï¿½ï¿½ï¿½b$ï¿½6"ï¿½"XQï¿½ï¿½es^ï¿½K\7'bï¿½ï¿½ï¿½66ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½+Eï¿½Oï¿½ï¿½
ï¿½ï¿½EMï¿½ï¿½ï¿½ï¿½ï¿½ï¿½33ï¿½ï¿½uï¿½-ï¿½Bï¿½ï¿½Ù¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!ï¿½ï¿½Og%ï¿½Ð´y*ï¿½ï¿½ï¿½ï¿½ï¿½#<Rï¿½Gï¿½ï¿½ï¿½ï¿½iï¿½ï¿½W^ï¿½ï¿½;#ï¿½ï¿½ï¿½-/ï¿½3Jï¿½ï¿½rï¿½qaï¿½XÛµï¿½ï¿½âˆ ï¿½ï¿½ï¿½%ï¿½uï¿½ï¿½ï¿½ï¿½sÙ­YÌ¤ï¿½ï¿½ï¿½,ï¿½ï¿½+ï¿½ï¿½lï¿½o6qï¿½ï¿½a_;ï¿½ï¿½Fqiï¿½ï¿½ï¿½ï¿½iï¿½($ï¿½ï¿½8Tï¿½ï¿½Oï¿½>ï¿½ï¿½Ka{Ø„ï¿½<lwï¿½ï¿½hï¿½ï¿½9ï¿½0ï¿½(qã”ªï¿½ï¿½ï¿½;6ï¿½ï¿½;`fï¿½`ï¿½ï¿½%9pï¿½tï¿½4ï¿½ï¿½# t
ÜŽq]ï¿½?ï¿½ï¿½T}ï¿½ï¿½xï¿½ï¿½Aï¿½ï¿½9ï¿½k/ï¿½jï¿½qï¿½Oï¿½vxï¿½ï¿½ï¿½ï¿½'ï¿½9ajï¿½Jï¿½   DeXIfMM *           ï¿½i       &     ï¿½      %ï¿½       j    oIï¿½ï¿½  iTXtXML:com.adobe.xmp     <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="XMP Core 6.0.0">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:tiff="http://ns.adobe.com/tiff/1.0/"
            xmlns:exif="http://ns.adobe.com/exif/1.0/">
         <tiff:Orientation>1</tiff:Orientation>
         <exif:PixelXDimension>293</exif:PixelXDimension>
         <exif:PixelYDimension>106</exif:PixelYDimension>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
l0ï¿½5  lIDATxï¿½]	xUEï¿½>Y YHï¿½ï¿½ï¿½ï¿½HXHï¿½DDdwï¿½Glhmï¿½luï¿½Fï¿½ï¿½ï¿½vz>ï¿½ï¿½vï¿½[g[wTï¿½%HXdï¿½%a'+	[ !ï¿½Adï¿½_ï¿½.ï¿½ï¿½ï¿½GÖ—Ü¼wï¿½ï¿½ï¿½Wuï¿½Ö­[ï¿½×½ï¿½=uNï¿½[^Wï¿½^ï¿½N"ï¿½ï¿½  Xoï¿½ï¿½Cï¿½!ï¿½ï¿½B@HI.A@ï¿½BJï¿½ï¿½ï¿½ï¿½  )ï¿½5 ï¿½B@Hï¿½Rï¿½!ï¿½!%ï¿½Aï¿½R)Yï¿½;ï¿½2ï¿½ï¿½  ï¿½$×€  X
!%Kuï¿½TFï¿½ï¿½ï¿½K! ï¿½dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ `)ï¿½ï¿½,ï¿½RA@ï¿½ï¿½ï¿½+ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½^iï¿½ ï¿½PMï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CE@Hï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CE@Hï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CEï¿½å¤´nï¿½zJKKï¿½1>ï¿½Îï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½p))ï¿½ï¿½ï¿½Ó›oï¿½C.ï¿½ï¿½ï¿½ï¿½ï¿½YNï¿½ï¿½Cï¿½,ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½(.nï¿½ï¿½\pï¿½Gvï¿½ï¿½ï¿½p))ï¿½Zï¿½ï¿½Zï¿½jEï¿½^#$ï¿½ï¿½5%/oo
nï¿½ï¿½i9ï¿½hï¿½ï¿½7ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½A@ï¿½>ï¿½ï¿½ï¿½bAA>ï¿½Ø±ï¿½ï¿½1ï¿½ï¿½ï¿½nï¿½}EEï¿½ï¿½ï¿½lï¿½Â¢+4tHï¿½nm;ï¿½zÜ¸ï¿½4fï¿½hï¿½ï¿½ï¿½qZï¿½ï¿½$ï¿½ï¿½9Gv
ï¿½ï¿½Ò†ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æï¿½ï¿½ï¿½Gï¿½PjJ7ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½5kï¿½ï¿½Ë‹ï¿½B[)Rï¿½pï¿½Ä‰ï¿½c;vï¿½@ï¿½ï¿½ï¿½Fï¿½Õ«W())Emoï¿½ï¿½ï¿½
ï¿½ï¿½3(((ï¿½ï¿½Þ‘ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½ï¿½p)ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ã·PJï¿½ï¿½æ¿¼ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½Ktï¿½:ï¿½ï¿½ï¿½Gï¿½ï¿½Ggyï¿½ï¿½ï¿½wcï¿½yï¿½ï¿½*ï¿½K'ï¿½gï¿½ï¿½yï¿½Eï¿½ï¿½ï¿½%ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½Ñ!ï¿½mï¿½dCï¿½ï¿½ï¿½KH)99ï¿½RSSiï¿½ï¿½+ï¿½ï¿½ï¿½VÒ¼yï¿½ï¿½iS'Snï¿½eE>ï¿½>ï¿½ï¿½&Mï¿½Hï¿½oØï¿½ï¿½ï¿½>ï¿½@ï¿½Éžï¿½ï¿½ï¿½_-WVï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½[oï¿½KO>ï¿½ï¿½hï¿½
3ï¿½ï¿½#ï¿½RZï¿½zï¿½fï¿½9|X9ï¿½Oï¿½Fï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½Ç—BBBï¿½^t/ï¿½ï¿½ï¿½qï¿½3Hï¿½ï¿½wï¿½k×®ï¿½ï¿½ï¿½_ï¿½FFï¿½3gÎª]ï¿½Utï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½u-))ï¿½ï¿½ï¿½[iï¿½È‘ï¿½ï¿½[ï¿½ï¿½ï¿½3ï¿½ Ozï¿½M{Qrrï¿½:Sï¿½V-ï¿½qF9Dï¿½	ï¿½ï¿½Qï¿½ï¿½ï¿½mï¿½Fï¿½ï¿½yï¿½8aï¿½Ã’ï¿½ï¿½Zï¿½fï¿½ï¿½ï¿½ï¿½iPï¿½@5ï¿½iß¾xï¿½Û·/a8&"ï¿½ï¿½@ï¿½kJkØ‹Ö£{
wï¿½lï¿½vmï¿½ï¿½;ï¿½)ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½f>ï¿½ -^ï¿½zï¿½S(ï¿½ï¿½ï¿½ ï¿½VÔªï¿½ï¿½ï¿½ï¿½Iï¿½gï¿½~ï¿½)H0tï¿½ï¿½ï¿½Hï¿½/ï¿½ï¿½]ï¿½ï¿½Nï¿½Uuï¿½ï¿½Oï¿½ï¿½kUï¿½ ï¿½Aï¿½ï¿½URZï¿½j
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½w;ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½Oï¿½ï¿½<5IÙž:wï¿½)S&Qï¿½.]Ô±ï¿½ï¿½}ï¿½|ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½nï¿½Ô´Tï¿½ï¿½ï¿½Ý»ï¿½ï¿½ï¿½WÏžl@oDË¿ï¿½ï¿½ï¿½ï¿½T6g	ï¿½3ï¿½O3ï¿½Ä¶ï¿½  Xï¿½Z#ï¿½ï¿½ï¿½ï¿½Xï¿½09|ï¿½PjÒ¤ï¿½ï¿½V7oï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½5f$ï¿½ï¿½iÓ¦Í´kï¿½ï¿½lï¿½ERï¿½yï¿½tï¿½G
yzï¿½*# ï¿½ï¿½ï¿½ï¿½ï¿½dCï¿½6mJï¿½-xEMï¿½<sï¿½ï¿½ï¿½~ï¿½
Ïƒï¿½ï¿½@ï¿½ï¿½ï¿½n&ï¿½ï¿½2ï¿½ï¿½ï¿½9m|^ï¿½ezï¿½ï¿½Í™ï¿½=ï¿½ï¿½tï¿½|q[ï¿½Ò¢Eï¿½WSvï¿½ï¿½i8EFFÒ»ï¿½iï¿½ï¿½ï¿½
L'ï¿½S
*ï¿½+ï¿½Aï¿½ï¿½Ôš!fï¿½ï¿½uÔ–ï¿½ï¿½QQï¿½N[ï¿½ï¿½_@×®]ï¿½Ý»ï¿½ï¿½'Oï¿½|Ð°2xz ï¿½fï¿½ï¿½ï¿½`ÊŸ  x&ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½9ï¿½Mï¿½6tï¿½ï¿½hÕªï¿½ï¿½ï¿½ï¿½Oï¿½mMï¿½Ðµï¿½kjï¿½^9yï¿½g+
ï¿½3ï¿½BZ-@ï¿½+;;ï¿½ï¿½_ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½F}xï¿½eHp0EDtï¿½Æï¿½\ï¿½+ï¿½ï¿½ACï¿½!Pkï¿½RUï¿½ï¿½ï¿½Û¢ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½Ïœ×žï¿½ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ `ê…”ï¿½ï¿½L>7ï¿½Gï¿½ï¿½>rVA@pï¿½ï¿½Û“ï¿½ï¿½)Nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½P:8ï¿½#ï¿½$M\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4É˜Cï¿½ï¿½|9Oï¿½ï¿½oï¿½/ï¿½ï¿½}ï¿½ï¿½ï¿½Fï¿½'8Cï¿½4ï¿½2ï¿½ï¿½


)??_y
ï¿½ï¿½ï¿½ï¿½ï¿½'q:Iï¿½Aï¿½ï¿½p[Rï¿½ï¿½ï¿½Ô„ï¿½yRï¿½/_ï¿½ï¿½Mï¿½+)uï¿½ï¿½I*ï¿½ï¿½[ï¿½ï¿½&$ï¿½ï¿½ï¿½5ï¿½!5kÖŒ?.ï¿½|ï¿½ï¿½'ï¿½Aï¿½5ï¿½zï¿½ï¿½kï¿½Y'ï¿½j2ï¿½ï¿½ï¿½lHxaWï¿½Nï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½HIkI@q=tï¿½ï¿½Ô¸qï¿½j%
ï¿½@ï¿½ ï¿½ï¿½ï¿½7@ï¿½ï¿½Iï¿½ÚŽÚ—.]T3ï¿½KJJï¿½q9ï¿½  ï¿½ï¿½$%3!iRrï¿½^^vv6]ï¿½Xï¿½%ï¿½oï¿½ï¿½ï¿½ï¿½*#ï¿½vï¿½7ï¿½ï¿½&#ï¿½ï¿½ï¿½ï¿½>
!i$$ï¿½ï¿½ï¿½[ï¿½ï¿½#ï¿½)Yï¿½ï¿½&ï¿½ï¿½ ï¿½p+RÒÒ¡&)ï¿½t	Aï¿½ï¿½ï¿½%)		Yï¿½ï¿½ï¿½ï¿½	!ï¿½ï¿½ï¿½dn4ï¿½ï¿½ï¿½@ï¿½Aï¿½mIÉ¬-ï¿½ï¿½ï¿½5ï¿½yaï¿½%Zï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½	ï¿½ï¿½SU*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½oï¿½ï¿½Ê¡5Î›ï¿½{ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'qï¿½Ü–ï¿½êª¯Nï¿½<ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½ï¿½PRR/
qï¿½ï¿½ï¿½]'ï¿½ï¿½8EVï¿½<nÛ¾ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½}ï¿½EE4ï¿½/ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X.Lï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½n9Oï¿½fï¿½j7vï¿½ï¿½1:pï¿½ï¿½ï¿½%ï¿½Ðƒï¿½å••Ú…ï¿½%ï¿½ï¿½ï¿½ï¿½"|ï¿½ï¿½ï¿½+Ô¡}{ï¿½h]rb.ï¿½kï¿½ï¿½4oï¿½
ï¿½ï¿½	ï¿½ ï¿½ï¿½R%ï¿½ï¿½ï¿½sKï¿½|ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½1}ï¿½ï¿½R%ï¿½ï¿½ï¿½lï¿½"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|jZï¿½ï¿½ï¿½ï¿½!YeoDEï¿½ï¿½lvï¿½w!%'ï¿½BVV6ï¿½Zï¿½ï¿½RRR)_ï¿½ï¿½.AHï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½nï¿½A6ï¿½R.ï¿½Ö¡4uï¿½$ï¿½Ñ½ï¿½ï¿½Ò'cï¿½ï¿½ï¿½ï¿½ï¿½4ï¿½ï¿½ï¿½)==ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½G{ï¿½ï¿½5
ï¿½×¯/ï¿½ï¿½Iï¿½ï¿½Kï¿½\ï¿½ ^ï¿½ï¿½_?nï¿½Lï¿½ï¿½ï¿½_Aï¿½ï¿½ï¿½
/ï¿½Þ‰W;ï¿½ï¿½ï¿½ï¿½ï¿½4Zï¿½r-ï¿½ï¿½?}ï¿½ï¿½ï¿½;ï¿½4nsË–-lï¿½>|ï¿½Ö­ï¿½ï¿½ï¿½ï¿½sï¿½a^ï¿½Ð°0ï¿½Ý«ï¿½7nL9Rï¿½Û²]ï¿½ï¿½wï¿½|6ï¿½ï¿½ï¿½ï¿½ï¿½={ï¿½6ë—¨ï¿½xï¿½ï¿½ï¿½ï¿½å‡„ï¿½ï¿½ï¿½Í ï¿½ï¿½vÓ±ï¿½ï¿½TXTHO?ï¿½kï¿½ï¿½ï¿½Ï¾ï¿½Ó§Nyï¿½Ø±ï¿½|ï¿½ï¿½ï¿½Ï–}ï¿½>ï¿½ÝŸë¹‰2ï¿½fï¿½6ï¿½s
`ï¿½!ï¿½ï¿½xï¿½FÕ·ï¿½ï¿½Aï¿½ï¿½3C9-O>1ï¿½ï¿½ï¿½yï¿½ï¿½bzï¿½ï¿½ï¿½ï¿½dFDï¿½ï¿½)ï¿½'Ú¤a$ï¿½ï¿½[ï¿½"ï¿½ï¿½ï¿½gï¿½ï¿½{Gï¿½ï¿½I'ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½Ô‡ï¿½ï¿½6ï¿½1ï¿½`ï¿½F|,Xï¿½Ð¢uï¿½vï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½R^ï¿½	ï¿™%ï¿½ï¿½t$EEEï¿½ï¿½;ï¿½ï¿½	ï¿½ï¿½9ï¿½bï¿½<ï¿½ï¿½ï¿½ï¿½bzï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ý¯nï¿½l&ï¿½!ï¿½Q@@ ï¿½8ï¿½ï¿½Ãƒ
ï¿½ï¿½Umï¿½ï¿½Cï¿½ï¿½P<ï¿½ï¿½ï¿½Rï¿½{ï¿½ï¿½Ô¡C;^)8ï¿½ï¿½;N%ï¿½%ï¿½ï¿½KUï¿½Bï¿½Xï¿½ï¿½-Zï¿½ï¿½C|ï¿½C#Xï¿½7zï¿½Iï¿½:LPï¿½@&ï¿½(ï¿½ï¿½ï¿½_}ï¿½ï¿½ï¿½nï¿½I-}3ï¿½?ï¿½Ò”ï¿½oØ¤ï¿½>8oï¿½.áª¨ï¿½Ç“ï¿½ï¿½yï¿½ï¿½ï¿½ï¿½ï¿½JH8D[ï¿½mï¿½Awï¿½l3Frï¿½`Ã†
ï¿½ï¿½oï¿½O^ï¿½ï¿½ï¿½ï¿½ï¿½wRï¿½ï¿½Ô¿_ï¿½j+Vï¿½á¥·ï¿½(ï¿½:t0ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½!%%ï¿½ï¿½ï¿½Aï¿½Oï¿½:Cï¿½ï¿½ï¿½t<1ï¿½ï¿½ï¿½Cï¿½ï¿½
ï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½ï¿½Ú‚ï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½o#ï¿½Gï¿½I9ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½r@8ï¿½ï¿½(ï¿½SGjÕªï¿½"ï¿½]ï¿½~Vï¿½ï¿½ï¿½ï¿½vï¿½Ô¦ï¿½ï¿½Ã‡Viï¿½d_ï¿½QuD=Sï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½]ï¿½ï¿½`^ï¿½gÈ;ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½|ï¿½ï¿½}r<1ï¿½jï¿½3
ï¿½hï¿½ï¿½.ï¿½h%ï¿½ZIÉ©tï¿½bï¿½awÆŒitï¿½ï¿½!ï¿½ï¿½Mï¿½ï¿½ï¿½ï¿½Pï¿½|ï¿½@+ï¿½ï¿½ï¿½ï¿½Mï¿½?ï¿½ï¿½qQBï¿½ï¿½á‡•tï¿½ï¿½Q:$Fgï¿½R8mï¿½dï¿½ï¿½ï¿½S3yï¿½DZï¿½ï¿½bÚ¶m'ï¿½;Fï¿½ï¿½ï¿½ï¿½ï¿½08ï¿½ï¿½ï¿½d^6}p9ï¿½Ì‰ï¿½fßµkk	-ï¿½ï¿½W^242Ü˜ï¿½ï¿½Ö»ï¿½ï¿½ï¿½ÔŠoï¿½}á·†ï¿½Ù‹ï¿½xï¿½M^6}ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½Ö­[Uï¿½!|ï¿½ï¿½ï¿½ï¿½Ûµï¿½06oÞªHjï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½i-Aï¿½ï¿½Nï¿½_ï¿½>Å¤ï¿½ï¿½ï¿½Lï¿½ï¿½~ï¿½ï¿½ÖŽï¿½ï¿½ï¿½Tï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½ï¿½?<ï¿½~ï¿½ï¿½oï¿½ï¿½;Ç„ï¿½ï¿½Oï¿½Ic7ï¿½rï¿½ï¿½ï¿½Eï¿½ï¿½?Jï¿½ï¿½N-ï¿½XÚ¶mCï¿½ï¿½ï¿½kï¿½ï¿½ï¿½ï¿½tï¿½ï¿½oï¿½cï¿½ï¿½&.ï¿½sDD=ï¿½ï¿½ï¿½F9+ï¿½ï¿½7ï¿½ï¿½ ï¿½ï¿½ï¿½_ï¿½>Fï¿½+ï¿½1ï¿½pï¿½Eï¿½ï¿½tH1kGZï¿½-Zï¿½ï¿½$ï¿½m&cï¿½#xJï¿½$Ò£ï¿½)a];ï¿½ï¿½ï¿½ï¿½Yï¿½I4'ï¿½ï¿½ï¿½ï¿½1ï¿½&
ï¿½xï¿½ï¿½/ï¿½ï¿½ß‡ï¿½ï¿½.ï¿½6mï¿½ï¿½.#ï¿½ï¿½ï¿½kï¿½ï¿½mï¿½ï¿½ï¿½ï¿½+ï¿½Ïœï¿½Ò‹ï¿½eï¿½ï¿½<ï¿½ï¿½d	k3ï¿½BB^yï¿½rï¿½
ï¿½gÏž%hï¿½gyHfï¿½ ï¿½132NImZï¿½ï¿½ï¿½7|`ï¿½uï¿½ï¿½ÊšG;ï¿½ï¿½Í‚cÔ¹ï¿½ï¿½3'Ó¨Qwï¿½lï¿½oï¿½ï¿½&NWï¿½ï¿½ï¿½ï¿½3'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½á¸¹ï¿½Â˜ï¿½ï¿½ï¿½jï¿½h'ï¿½Dï¿½@^Zï¿½ï¿½lHCï¿½W6<q"]vtï¿½mï¿½DG+RJMMï¿½)ï¿½ï¿½ï¿½Xeï¿½oï¿½|BJzï¿½\ï¿½ï¿½yØ‡!ï¿½a~Reï¿½ï¿½ï¿½ï¿½G
ï¿½f$é§¶ï¿½"ï¿½Î®]ï¿½ï¿½ï¿½ï¿½ï¿½È‡n Gï¿½ï¿½YBCï¿½nï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½wï¿½ï¿½Ù¼Y.Þ·oï¿½ï¿½Øyï¿½ï¿½.ï¿½\.Dï¿½9ï¿½9ï¿½ï¿½]6ï¿½Å	?{)5}ZÆ„ï¿½ï¿½(nï¿½6Cï¿½ï¿½aï¿½ï¿½Ö­+=0cï¿½ï¿½x=Ý )ï¿½"-YWï¿½ï¿½yï¿½ï¿½Vy`ï¿½:}ï¿½ï¿½;ï¿½Â„Ã‚ï¿½ï¿½x!ï¿½ï¿½ï¿½;ï¿½ï¿½9
ï¿½rrlh6ï¿½xï¿½ï¿½5fï¿½ï¿½!n)9ï¿½5ï¿½ï¿½ï¿½,ï¿½ï¿½_ï¿½g;ï¿½!Íš6Sï¿½M_ï¿½Õ‘ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½ï¿½uï¿½
Stï¿½ï¿½ï¿½ï¿½ï¿½!|dï¿½ï¿½ï¿½rqï¿½rï¿½R9ï¿½ï¿½p#ï¿½5ï¿½Ø±ï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½`ï¿½ï¿½ï¿½aaGï¿½ï¿½ ;ï¿½GKï¿½ï¿½K/>ï¿½ï¿½
*ï¿½\e{]Uï¿½ï¿½6Wï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½
BÂ¹0M ï¿½ï¿½L
jA?ï¿½ï¿½ï¿½Wuï¿½'ï¿½BJz7Ð—_~Kï¿½ï¿½4{ï¿½ï¿½lè½ª.ï¿½6<ï¿½0{EZkIYYï¿½ï¿½ï¿½uï¿½	ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½kï¿½ï¿½|Xï¿½ah5ï¿½'ï¿½ï¿½fï¿½!ï¿½ï¿½4Mp&ï¿½[8ï¿½ï¿½ï¿½0CÎž=Çžï¿½<ï¿½ï¿½Cï¿½Þ½zï¿½ï¿½ï¿½Xï¿½ï¿½]Û¶ï¿½ï¿½0ï¿½ï¿½1ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½T^brï¿½'ï¿½LÊ†]pZï¿½ï¿½ï¿½ï¿½ï¿½Ï¯ï¿½	ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Ã§ï¿½ï¿½Nï¿½ï¿½ï¿½<ï¿½3ï¿½Ú¨Qc6ï¿½S	ï¿½ï¿½ï¿½Bï¿½KULkHï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½/ï¿½sï¿½ï¿½ï¿½ï¿½q!%=ï¿½':l ï¿½ï¿½K?7<mï¿½ ï¿½~ï¿½]#x(vï¿½á’ƒbï¿½ï¿½Wï¿½ï¿½{ï¿½Vï¿½={ï¿½ï¿½ï¿½ï¿½,8pï¿½Z
ï¿½ï¿½>ï¿½ï¿½kï¿½)ï¿½ï¿½vï¿½ï¿½
ï¿½q=y{Tf'ï¿½ï¿½5ï¿½É³ï¿½)ï¿½ï¿½ vï¿½ï¿½ï¿½6ï¿½=ï¿½^ÆKË¸~ï¿½ï¿½Ö‡ï¿½ï¿½+ï¿½Ü‰<ï¿½Cï¿½v)}ï¿½ï¿½rJIKeï¿½Rï¿½ï¿½!1mHeOï¿½Q&ï¿½^=#ï¿½bqCÃ–ï¿½ï¿½ï¿½d1ï¿½ï¿½bï¿½ï¿½Æï¿½ï¿½ï¿½`ï¿½ï¿½0ï¿½ï¿½ï¿½Afï¿½ï¿½bÚ‚n3
ï¿½Û§ï¿½aï¿½&vï¿½ï¿½ï¿½,ï¿½-Zï¿½gï¿½4{ï¿½Lï¿½3ZÅ‹YCï¿½ï¿½ï¿½?dBï¿½Qï¿½ï¿½Î?ï¿½ï¿½ï¿½pvpï¿½ï¿½ï¿½ï¿½ï¿½+ï¿½ï¿½e!Ï‚Wï¿½ï¿½	ï¿½ï¿½ï¿½}ï¿½a 0<ï¿½t=[3ï¿½ï¿½[	ï¿½(Jï¿½}ï¿½>ï¿½kdï¿½7vï¿½Þ«<wï¿½~zï¿½)9ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Öµ+ï¿½ï¿½Sxï¿½ï¿½ï¿½pï¿½m:ï¿½Þ¶gï¿½\ï¿½$ï¿½Ú‚.ï¿½~[ï¿½W%7vï¿½zWKÏ‹ï¿½ï¿½fï¿½ï¿½ï¿½F{ï¿½ï¿½cï¿½ï¿½Vc;%5ï¿½ï¿½ï¿½ï¿½VURï¿½q3ï¿½AEï¿½Eï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Yfï¿½ï¿½ï¿½CMï¿½Xï¿½r5a#ï¿½ï¿½ï¿½Ó¦Øœï¿½ï¿½ï¿½ï¿½ï¿½ï¿½WPï¿½{ï¿½ï¿½ï¿½	ï¿½hï¿½ï¿½9Mfyï¿½ï¿½5bï¿½nÓ¦ÍŠï¿½:uï¿½Dï¿½f=dxOï¿½eË¾0fï¿½ï¿½"ï¿½Iï¿½ï¿½WQï¿½ï¿½ï¿½bRï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½ ï¿½7jï¿½Hï¿½acï¿½ï¿½L`Bï¿½ï¿½kï¿½fï¿½cJï¿½oï¿½2ï¿½^'ï¿½ï¿½#ï¿½1ï¿½4Lï¿½xï¿½I	ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½=tï¿½esï¿½ï¿½!ï¿½%<ï¿½ï¿½ï¿½6x#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½V+ï¿½jï¿½2ï¿½Vï¿½a6.ï¿½ï¿½ï¿½Rï¿½Tï¿½Â“fIJ*3^ï¿½ï¿½ï¿½+xÅŠUÔžï¿½ï¿½#Gï¿½yï¿½ï¿½ï¿½;8))Ù˜ï¿½.l%ï¿½-pï¿½ï¿½[ï¿½ï¿½/Zï¿½4ï¿½ï¿½aï¿½ï¿½ï¿½ï¿½ï¿½hï¿½LNï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ub0ï¿½ï¿½ï¿½ï¿½ï¿½Ù‹ï¿½(?ï¿½eï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½É¬ï¿½a:Ú‡ï¿½3++[ï¿½ï¿½ï¿½uuï¿½ï¿½Xï¿½hJz%!ï¿½J-ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½.Ä™wÎ•ï¿½	jï¿½wEç©¬ï¿½ï¿½ï¿½ï¿½ï¿½6ï¿½n8ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½FMaï¿½)C@Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½vï¿½ï¿½ï¿½ÈŽï¿½Ý ;88Rï¿½Aï¿½ï¿½)9@ï¿½ï¿½ï¿½×ï¿½;ï¿½Hï¿½jï¿½O
ï¿½ï¿½:w/7ï¿½wPLï¿½ï¿½ï¿½"ï¿½È¿ï¿½ï¿½ï¿½ï¿½V!rPï¿½5jDï¿½Iï¿½ï¿½>X2ï¿½ï¿½)ï¿½V)Tï¿½ï¿½ï¿½M#IuKï¿½ï¿½qfoï¿½9nï¿½ï¿½Jï¿½Aï¿½nKJï¿½ï¿½o5ï¿½-8ï¿½ï¿½ï¿½l:ï¿½ï¿½ï¿½ï¿½ Pï¿½ï¿½ï¿½M	ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½"1ï¿½_>Wjï¿½ï¿½lï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Rï¿½b.ï¿½Jï¿½ï¿½<Í›~"ï¿½ï¿½ `
ï¿½jï¿½fO8ï¿½iï¿½a2ï¿½ï¿½wï¿½ï¿½ï¿½ï¿½Bï¿½#ï¿½Vï¿½dnï¿½ï¿½$MJpï¿½cï¿½ï¿½ï¿½"ï¿½ï¿½ `]Ü’ï¿½@DMH 'ï¿½ï¿½ï¿½;Kxï¿½Lï¿½GÖ½ ï¿½fï¿½ï¿½ï¿½Ú”@HÚ†Rï¿½ï¿½hï¿½ï¿½ï¿½ï¿½Æ„ï¿½ï¿½ï¿½iï¿½ï¿½Aï¿½ï¿½#%MFï¿½qï¿½ï¿½	ï¿½Bï¿½ï¿½7ï¿½ï¿½ï¿½ 4&ï¿½ï¿½ï¿½ï¿½3Wï¿½]#5<ï¿½#%ÝZï¿½)i1iA:ï¿½Dï¿½Dï¿½:ï¿½ï¿½ï¿½ï¿½ Pï¿½ï¿½%)imIBMHï¿½ï¿½g&$31ï¿½}ï¿½Aï¿½ï¿½ï¿½[ï¿½ï¿½Ñšï¿½ÖŠï¿½Ä„}ï¿½ï¿½ï¿½<:4ï¿½#qA@ï¿½{Ü–ï¿½4ï¿½ï¿½ï¿½ï¿½mIoCSï¿½iï¿½+ï¿½ï¿½ï¿½Pï¿½_Üšï¿½4!4ï¿½ï¿½>ï¿½.ï¿½nï¿½ï¿½ï¿½ï¿½@ï¿½"ï¿½Ö¤h5!A2ï¿½ï¿½=)Akï¿½ï¿½Æ¤`ï¿½?Aï¿½ï¿½p{Rï¿½ÈšIHï¿½9ÍœOï¿½%ï¿½ï¿½Gï¿½cH	ï¿½j2B\kDï¿½4ï¿½ï¿½ï¿½@ï¿½"ï¿½Qï¿½dï¿½Zï¿½ÈŒï¿½ï¿½ï¿½ psfï¿½uï¿½$5F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½3DEï¿½Aï¿½Xs    IENDï¿½B`ï¿½
--- END OF FILE 2025-06-18/server/slash-command.png ---


--- START OF FILE 2025-06-18/server/tools.mdx ---
---
title: Tools
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: 2025-06-18</Info>

The Model Context Protocol (MCP) allows servers to expose tools that can be invoked by
language models. Tools enable models to interact with external systems, such as querying
databases, calling APIs, or performing computations. Each tool is uniquely identified by
a name and includes metadata describing its schema.

## User Interaction Model

Tools in MCP are designed to be **model-controlled**, meaning that the language model can
discover and invoke tools automatically based on its contextual understanding and the
user's prompts.

However, implementations are free to expose tools through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

<Warning>

For trust & safety and security, there **SHOULD** always
be a human in the loop with the ability to deny tool invocations.

Applications **SHOULD**:

- Provide UI that makes clear which tools are being exposed to the AI model
- Insert clear visual indicators when tools are invoked
- Present confirmation prompts to the user for operations, to ensure a human is in the
  loop

</Warning>

## Capabilities

Servers that support tools **MUST** declare the `tools` capability:

```json
{
  "capabilities": {
    "tools": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the server will emit notifications when the list of
available tools changes.

## Protocol Messages

### Listing Tools

To discover available tools, clients send a `tools/list` request. This operation supports
[pagination](/specification/2025-06-18/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "get_weather",
        "title": "Weather Information Provider",
        "description": "Get current weather information for a location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "City name or zip code"
            }
          },
          "required": ["location"]
        }
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Calling Tools

To invoke a tool, clients send a `tools/call` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "get_weather",
    "arguments": {
      "location": "New York"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Current weather in New York:\nTemperature: 72Â°F\nConditions: Partly cloudy"
      }
    ],
    "isError": false
  }
}
```

### List Changed Notification

When the list of available tools changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant LLM
    participant Client
    participant Server

    Note over Client,Server: Discovery
    Client->>Server: tools/list
    Server-->>Client: List of tools

    Note over Client,LLM: Tool Selection
    LLM->>Client: Select tool to use

    Note over Client,Server: Invocation
    Client->>Server: tools/call
    Server-->>Client: Tool result
    Client->>LLM: Process result

    Note over Client,Server: Updates
    Server--)Client: tools/list_changed
    Client->>Server: tools/list
    Server-->>Client: Updated tools
```

## Data Types

### Tool

A tool definition includes:

- `name`: Unique identifier for the tool
- `title`: Optional human-readable name of the tool for display purposes.
- `description`: Human-readable description of functionality
- `inputSchema`: JSON Schema defining expected parameters
- `outputSchema`: Optional JSON Schema defining expected output structure
- `annotations`: optional properties describing tool behavior

<Warning>

For trust & safety and security, clients **MUST** consider
tool annotations to be untrusted unless they come from trusted servers.

</Warning>

### Tool Result

Tool results may contain [**structured**](#structured-content) or **unstructured** content.

**Unstructured** content is returned in the `content` field of a result, and can contain multiple content items of different types:

#### Text Content

```json
{
  "type": "text",
  "text": "Tool result text"
}
```

#### Image Content

```json
{
  "type": "image",
  "data": "base64-encoded-data",
  "mimeType": "image/png"
}
```

#### Audio Content

```json
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

#### Resource Links

A tool **MAY** return links to [Resources](/specification/2025-06-18/server/resources), to provide additional context
or data. In this case, the tool will return a URI that can be subscribed to or fetched by the client:

```json
{
  "type": "resource_link",
  "uri": "file:///project/src/main.rs",
  "name": "main.rs",
  "description": "Primary application entry point",
  "mimeType": "text/x-rust"
}
```

<Info>
  Resource links returned by tools are not guaranteed to appear in the results
  of a `resources/list` request.
</Info>

#### Embedded Resources

[Resources](/specification/2025-06-18/server/resources) **MAY** be embedded to provide additional context
or data using a suitable [URI scheme](./resources#common-uri-schemes). Servers that use embedded resources **SHOULD** implement the `resources` capability:

```json
{
  "type": "resource",
  "resource": {
    "uri": "file:///project/src/main.rs",
    "title": "Project Rust Main File",
    "mimeType": "text/x-rust",
    "text": "fn main() {\n    println!(\"Hello world!\");\n}"
  }
}
```

#### Structured Content

**Structured** content is returned as a JSON object in the `structuredContent` field of a result.

For backwards compatibility, a tool that returns structured content SHOULD also return functionally equivalent unstructured content.
(For example, serialized JSON can be returned in a `TextContent` block.)

#### Output Schema

Tools may also provide an output schema for validation of structured results.
If an output schema is provided:

- Servers **MUST** provide structured results that conform to this schema.
- Clients **SHOULD** validate structured results against this schema.

Example tool with output schema:

```json
{
  "name": "get_weather_data",
  "title": "Weather Data Retriever",
  "description": "Get current weather data for a location",
  "inputSchema": {
    "type": "object",
    "properties": {
      "location": {
        "type": "string",
        "description": "City name or zip code"
      }
    },
    "required": ["location"]
  },
  "outputSchema": {
    "type": "object",
    "properties": {
      "temperature": {
        "type": "number",
        "description": "Temperature in celsius"
      },
      "conditions": {
        "type": "string",
        "description": "Weather conditions description"
      },
      "humidity": {
        "type": "number",
        "description": "Humidity percentage"
      }
    },
    "required": ["temperature", "conditions", "humidity"]
  }
}
```

Example valid response for this tool:

```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "{\"temperature\": 22.5, \"conditions\": \"Partly cloudy\", \"humidity\": 65}"
      }
    ],
    "structuredContent": {
      "temperature": 22.5,
      "conditions": "Partly cloudy",
      "humidity": 65
    }
  }
}
```

Providing an output schema helps clients and LLMs understand and properly handle structured tool outputs by:

- Enabling strict schema validation of responses
- Providing type information for better integration with programming languages
- Guiding clients and LLMs to properly parse and utilize the returned data
- Supporting better documentation and developer experience

## Error Handling

Tools use two error reporting mechanisms:

1. **Protocol Errors**: Standard JSON-RPC errors for issues like:

   - Unknown tools
   - Invalid arguments
   - Server errors

2. **Tool Execution Errors**: Reported in tool results with `isError: true`:
   - API failures
   - Invalid input data
   - Business logic errors

Example protocol error:

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "error": {
    "code": -32602,
    "message": "Unknown tool: invalid_tool_name"
  }
}
```

Example tool execution error:

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Failed to fetch weather data: API rate limit exceeded"
      }
    ],
    "isError": true
  }
}
```

## Security Considerations

1. Servers **MUST**:

   - Validate all tool inputs
   - Implement proper access controls
   - Rate limit tool invocations
   - Sanitize tool outputs

2. Clients **SHOULD**:
   - Prompt for user confirmation on sensitive operations
   - Show tool inputs to the user before calling the server, to avoid malicious or
     accidental data exfiltration
   - Validate tool results before passing to LLM
   - Implement timeouts for tool calls
   - Log tool usage for audit purposes

--- END OF FILE 2025-06-18/server/tools.mdx ---


--- START OF FILE 2025-06-18/changelog.mdx ---
---
title: Key Changes
---

<div id="enable-section-numbers" />

This document lists changes made to the Model Context Protocol (MCP) specification since
the previous revision, [2025-03-26](/specification/2025-03-26).

## Major changes

1. Remove support for JSON-RPC **[batching](https://www.jsonrpc.org/specification#batch)**
   (PR [#416](https://github.com/modelcontextprotocol/specification/pull/416))
2. Add support for [structured tool output](/specification/2025-06-18/server/tools#structured-content)
   (PR [#371](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/371))
3. Classify MCP servers as [OAuth Resource Servers](/specification/2025-06-18/basic/authorization#authorization-server-discovery),
   adding protected resource metadata to discover the corresponding Authorization server.
   (PR [#338](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/338))
4. Require MCP clients to implement Resource Indicators as described in [RFC 8707](https://www.rfc-editor.org/rfc/rfc8707.html) to prevent
   malicious servers from obtaining access tokens.
   (PR [#734](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/734))
5. Clarify [security considerations](/specification/2025-06-18/basic/authorization#security-considerations) and best practices
   in the authorization spec and in a new [security best practices page](/specification/2025-06-18/basic/security_best_practices).
6. Add support for **[elicitation](/specification/2025-06-18/client/elicitation)**, enabling servers to request additional
   information from users during interactions.
   (PR [#382](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/382))
7. Add support for **[resource links](/specification/2025-06-18/server/tools#resource-links)** in
   tool call results. (PR [#603](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/603))
8. Require [negotiated protocol version to be specified](/specification/2025-06-18/basic/transports#protocol-version-header)
   via `MCP-Protocol-Version` header in subsequent requests when using HTTP (PR [#548](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/548)).
9. Change **SHOULD** to **MUST** in [Lifecycle Operation](/specification/2025-06-18/basic/lifecycle#operation)

## Other schema changes

1. Add `_meta` field to additional interface types (PR [#710](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/710)),
   and specify [proper usage](/specification/2025-06-18/basic#meta).
2. Add `context` field to `CompletionRequest`, providing for completion requests to include
   previously-resolved variables (PR [#598](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/598)).
3. Add `title` field for human-friendly display names, so that `name` can be used as a programmatic
   identifier (PR [#663](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/663))

## Full changelog

For a complete list of all changes that have been made since the last protocol revision,
[see GitHub](https://github.com/modelcontextprotocol/specification/compare/2025-03-26...2025-06-18).

--- END OF FILE 2025-06-18/changelog.mdx ---


--- START OF FILE 2025-06-18/index.mdx ---
---
title: Specification
---

<div id="enable-section-numbers" />

[Model Context Protocol](https://modelcontextprotocol.io) (MCP) is an open protocol that
enables seamless integration between LLM applications and external data sources and
tools. Whether you're building an AI-powered IDE, enhancing a chat interface, or creating
custom AI workflows, MCP provides a standardized way to connect LLMs with the context
they need.

This specification defines the authoritative protocol requirements, based on the
TypeScript schema in
[schema.ts](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-06-18/schema.ts).

For implementation guides and examples, visit
[modelcontextprotocol.io](https://modelcontextprotocol.io).

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [BCP 14](https://datatracker.ietf.org/doc/html/bcp14)
[[RFC2119](https://datatracker.ietf.org/doc/html/rfc2119)]
[[RFC8174](https://datatracker.ietf.org/doc/html/rfc8174)] when, and only when, they
appear in all capitals, as shown here.

## Overview

MCP provides a standardized way for applications to:

- Share contextual information with language models
- Expose tools and capabilities to AI systems
- Build composable integrations and workflows

The protocol uses [JSON-RPC](https://www.jsonrpc.org/) 2.0 messages to establish
communication between:

- **Hosts**: LLM applications that initiate connections
- **Clients**: Connectors within the host application
- **Servers**: Services that provide context and capabilities

MCP takes some inspiration from the
[Language Server Protocol](https://microsoft.github.io/language-server-protocol/), which
standardizes how to add support for programming languages across a whole ecosystem of
development tools. In a similar way, MCP standardizes how to integrate additional context
and tools into the ecosystem of AI applications.

## Key Details

### Base Protocol

- [JSON-RPC](https://www.jsonrpc.org/) message format
- Stateful connections
- Server and client capability negotiation

### Features

Servers offer any of the following features to clients:

- **Resources**: Context and data, for the user or the AI model to use
- **Prompts**: Templated messages and workflows for users
- **Tools**: Functions for the AI model to execute

Clients may offer the following features to servers:

- **Sampling**: Server-initiated agentic behaviors and recursive LLM interactions
- **Roots**: Server-initiated inquiries into uri or filesystem boundaries to operate in
- **Elicitation**: Server-initiated requests for additional information from users

### Additional Utilities

- Configuration
- Progress tracking
- Cancellation
- Error reporting
- Logging

## Security and Trust & Safety

The Model Context Protocol enables powerful capabilities through arbitrary data access
and code execution paths. With this power comes important security and trust
considerations that all implementors must carefully address.

### Key Principles

1. **User Consent and Control**

   - Users must explicitly consent to and understand all data access and operations
   - Users must retain control over what data is shared and what actions are taken
   - Implementors should provide clear UIs for reviewing and authorizing activities

2. **Data Privacy**

   - Hosts must obtain explicit user consent before exposing user data to servers
   - Hosts must not transmit resource data elsewhere without user consent
   - User data should be protected with appropriate access controls

3. **Tool Safety**

   - Tools represent arbitrary code execution and must be treated with appropriate
     caution.
     - In particular, descriptions of tool behavior such as annotations should be
       considered untrusted, unless obtained from a trusted server.
   - Hosts must obtain explicit user consent before invoking any tool
   - Users should understand what each tool does before authorizing its use

4. **LLM Sampling Controls**
   - Users must explicitly approve any LLM sampling requests
   - Users should control:
     - Whether sampling occurs at all
     - The actual prompt that will be sent
     - What results the server can see
   - The protocol intentionally limits server visibility into prompts

### Implementation Guidelines

While MCP itself cannot enforce these security principles at the protocol level,
implementors **SHOULD**:

1. Build robust consent and authorization flows into their applications
2. Provide clear documentation of security implications
3. Implement appropriate access controls and data protections
4. Follow security best practices in their integrations
5. Consider privacy implications in their feature designs

## Learn More

Explore the detailed specification for each protocol component:

<CardGroup cols={5}>
  <Card
    title="Architecture"
    icon="sitemap"
    href="/specification/2025-06-18/architecture"
  />
  <Card
    title="Base Protocol"
    icon="code"
    href="/specification/2025-06-18/basic"
  />
  <Card
    title="Server Features"
    icon="server"
    href="/specification/2025-06-18/server"
  />
  <Card
    title="Client Features"
    icon="user"
    href="/specification/2025-06-18/client"
  />
  <Card title="Contributing" icon="pencil" href="/development/contributing" />
</CardGroup>

--- END OF FILE 2025-06-18/index.mdx ---


--- START OF FILE draft/architecture/index.mdx ---
---
title: Architecture
---

<div id="enable-section-numbers" />

The Model Context Protocol (MCP) follows a client-host-server architecture where each
host can run multiple client instances. This architecture enables users to integrate AI
capabilities across applications while maintaining clear security boundaries and
isolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused
on context exchange and sampling coordination between clients and servers.

## Core Components

```mermaid
graph LR
    subgraph "Application Host Process"
        H[Host]
        C1[Client 1]
        C2[Client 2]
        C3[Client 3]
        H --> C1
        H --> C2
        H --> C3
    end

    subgraph "Local machine"
        S1[Server 1<br>Files & Git]
        S2[Server 2<br>Database]
        R1[("Local<br>Resource A")]
        R2[("Local<br>Resource B")]

        C1 --> S1
        C2 --> S2
        S1 <--> R1
        S2 <--> R2
    end

    subgraph "Internet"
        S3[Server 3<br>External APIs]
        R3[("Remote<br>Resource C")]

        C3 --> S3
        S3 <--> R3
    end
```

### Host

The host process acts as the container and coordinator:

- Creates and manages multiple client instances
- Controls client connection permissions and lifecycle
- Enforces security policies and consent requirements
- Handles user authorization decisions
- Coordinates AI/LLM integration and sampling
- Manages context aggregation across clients

### Clients

Each client is created by the host and maintains an isolated server connection:

- Establishes one stateful session per server
- Handles protocol negotiation and capability exchange
- Routes protocol messages bidirectionally
- Manages subscriptions and notifications
- Maintains security boundaries between servers

A host application creates and manages multiple clients, with each client having a 1:1
relationship with a particular server.

### Servers

Servers provide specialized context and capabilities:

- Expose resources, tools and prompts via MCP primitives
- Operate independently with focused responsibilities
- Request sampling through client interfaces
- Must respect security constraints
- Can be local processes or remote services

## Design Principles

MCP is built on several key design principles that inform its architecture and
implementation:

1. **Servers should be extremely easy to build**

   - Host applications handle complex orchestration responsibilities
   - Servers focus on specific, well-defined capabilities
   - Simple interfaces minimize implementation overhead
   - Clear separation enables maintainable code

2. **Servers should be highly composable**

   - Each server provides focused functionality in isolation
   - Multiple servers can be combined seamlessly
   - Shared protocol enables interoperability
   - Modular design supports extensibility

3. **Servers should not be able to read the whole conversation, nor "see into" other
   servers**

   - Servers receive only necessary contextual information
   - Full conversation history stays with the host
   - Each server connection maintains isolation
   - Cross-server interactions are controlled by the host
   - Host process enforces security boundaries

4. **Features can be added to servers and clients progressively**
   - Core protocol provides minimal required functionality
   - Additional capabilities can be negotiated as needed
   - Servers and clients evolve independently
   - Protocol designed for future extensibility
   - Backwards compatibility is maintained

## Capability Negotiation

The Model Context Protocol uses a capability-based negotiation system where clients and
servers explicitly declare their supported features during initialization. Capabilities
determine which protocol features and primitives are available during a session.

- Servers declare capabilities like resource subscriptions, tool support, and prompt
  templates
- Clients declare capabilities like sampling support and notification handling
- Both parties must respect declared capabilities throughout the session
- Additional capabilities can be negotiated through extensions to the protocol

```mermaid
sequenceDiagram
    participant Host
    participant Client
    participant Server

    Host->>+Client: Initialize client
    Client->>+Server: Initialize session with capabilities
    Server-->>Client: Respond with supported capabilities

    Note over Host,Server: Active Session with Negotiated Features

    loop Client Requests
        Host->>Client: User- or model-initiated action
        Client->>Server: Request (tools/resources)
        Server-->>Client: Response
        Client-->>Host: Update UI or respond to model
    end

    loop Server Requests
        Server->>Client: Request (sampling)
        Client->>Host: Forward to AI
        Host-->>Client: AI response
        Client-->>Server: Response
    end

    loop Notifications
        Server--)Client: Resource updates
        Client--)Server: Status changes
    end

    Host->>Client: Terminate
    Client->>-Server: End session
    deactivate Server
```

Each capability unlocks specific protocol features for use during the session. For
example:

- Implemented [server features](/specification/draft/server) must be advertised in the
  server's capabilities
- Emitting resource subscription notifications requires the server to declare
  subscription support
- Tool invocation requires the server to declare tool capabilities
- [Sampling](/specification/draft/client) requires the client to declare support in its
  capabilities

This capability negotiation ensures clients and servers have a clear understanding of
supported functionality while maintaining protocol extensibility.

--- END OF FILE draft/architecture/index.mdx ---


--- START OF FILE draft/basic/utilities/cancellation.mdx ---
---
title: Cancellation
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol (MCP) supports optional cancellation of in-progress requests
through notification messages. Either side can send a cancellation notification to
indicate that a previously-issued request should be terminated.

## Cancellation Flow

When a party wants to cancel an in-progress request, it sends a `notifications/cancelled`
notification containing:

- The ID of the request to cancel
- An optional reason string that can be logged or displayed

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/cancelled",
  "params": {
    "requestId": "123",
    "reason": "User requested cancellation"
  }
}
```

## Behavior Requirements

1. Cancellation notifications **MUST** only reference requests that:
   - Were previously issued in the same direction
   - Are believed to still be in-progress
2. The `initialize` request **MUST NOT** be cancelled by clients
3. Receivers of cancellation notifications **SHOULD**:
   - Stop processing the cancelled request
   - Free associated resources
   - Not send a response for the cancelled request
4. Receivers **MAY** ignore cancellation notifications if:
   - The referenced request is unknown
   - Processing has already completed
   - The request cannot be cancelled
5. The sender of the cancellation notification **SHOULD** ignore any response to the
   request that arrives afterward

## Timing Considerations

Due to network latency, cancellation notifications may arrive after request processing
has completed, and potentially after a response has already been sent.

Both parties **MUST** handle these race conditions gracefully:

```mermaid
sequenceDiagram
   participant Client
   participant Server

   Client->>Server: Request (ID: 123)
   Note over Server: Processing starts
   Client--)Server: notifications/cancelled (ID: 123)
   alt
      Note over Server: Processing may have<br/>completed before<br/>cancellation arrives
   else If not completed
      Note over Server: Stop processing
   end
```

## Implementation Notes

- Both parties **SHOULD** log cancellation reasons for debugging
- Application UIs **SHOULD** indicate when cancellation is requested

## Error Handling

Invalid cancellation notifications **SHOULD** be ignored:

- Unknown request IDs
- Already completed requests
- Malformed notifications

This maintains the "fire and forget" nature of notifications while allowing for race
conditions in asynchronous communication.

--- END OF FILE draft/basic/utilities/cancellation.mdx ---


--- START OF FILE draft/basic/utilities/ping.mdx ---
---
title: Ping
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol includes an optional ping mechanism that allows either party
to verify that their counterpart is still responsive and the connection is alive.

## Overview

The ping functionality is implemented through a simple request/response pattern. Either
the client or server can initiate a ping by sending a `ping` request.

## Message Format

A ping request is a standard JSON-RPC request with no parameters:

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "method": "ping"
}
```

## Behavior Requirements

1. The receiver **MUST** respond promptly with an empty response:

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {}
}
```

2. If no response is received within a reasonable timeout period, the sender **MAY**:
   - Consider the connection stale
   - Terminate the connection
   - Attempt reconnection procedures

## Usage Patterns

```mermaid
sequenceDiagram
    participant Sender
    participant Receiver

    Sender->>Receiver: ping request
    Receiver->>Sender: empty response
```

## Implementation Considerations

- Implementations **SHOULD** periodically issue pings to detect connection health
- The frequency of pings **SHOULD** be configurable
- Timeouts **SHOULD** be appropriate for the network environment
- Excessive pinging **SHOULD** be avoided to reduce network overhead

## Error Handling

- Timeouts **SHOULD** be treated as connection failures
- Multiple failed pings **MAY** trigger connection reset
- Implementations **SHOULD** log ping failures for diagnostics

--- END OF FILE draft/basic/utilities/ping.mdx ---


--- START OF FILE draft/basic/utilities/progress.mdx ---
---
title: Progress
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol (MCP) supports optional progress tracking for long-running
operations through notification messages. Either side can send progress notifications to
provide updates about operation status.

## Progress Flow

When a party wants to _receive_ progress updates for a request, it includes a
`progressToken` in the request metadata.

- Progress tokens **MUST** be a string or integer value
- Progress tokens can be chosen by the sender using any means, but **MUST** be unique
  across all active requests.

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "some_method",
  "params": {
    "_meta": {
      "progressToken": "abc123"
    }
  }
}
```

The receiver **MAY** then send progress notifications containing:

- The original progress token
- The current progress value so far
- An optional "total" value
- An optional "message" value

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/progress",
  "params": {
    "progressToken": "abc123",
    "progress": 50,
    "total": 100,
    "message": "Reticulating splines..."
  }
}
```

- The `progress` value **MUST** increase with each notification, even if the total is
  unknown.
- The `progress` and the `total` values **MAY** be floating point.
- The `message` field **SHOULD** provide relevant human readable progress information.

## Behavior Requirements

1. Progress notifications **MUST** only reference tokens that:

   - Were provided in an active request
   - Are associated with an in-progress operation

2. Receivers of progress requests **MAY**:
   - Choose not to send any progress notifications
   - Send notifications at whatever frequency they deem appropriate
   - Omit the total value if unknown

```mermaid
sequenceDiagram
    participant Sender
    participant Receiver

    Note over Sender,Receiver: Request with progress token
    Sender->>Receiver: Method request with progressToken

    Note over Sender,Receiver: Progress updates
    loop Progress Updates
        Receiver-->>Sender: Progress notification (0.2/1.0)
        Receiver-->>Sender: Progress notification (0.6/1.0)
        Receiver-->>Sender: Progress notification (1.0/1.0)
    end

    Note over Sender,Receiver: Operation complete
    Receiver->>Sender: Method response
```

## Implementation Notes

- Senders and receivers **SHOULD** track active progress tokens
- Both parties **SHOULD** implement rate limiting to prevent flooding
- Progress notifications **MUST** stop after completion

--- END OF FILE draft/basic/utilities/progress.mdx ---


--- START OF FILE draft/basic/authorization.mdx ---
---
title: Authorization
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

## Introduction

### Purpose and Scope

The Model Context Protocol provides authorization capabilities at the transport level,
enabling MCP clients to make requests to restricted MCP servers on behalf of resource
owners. This specification defines the authorization flow for HTTP-based transports.

### Protocol Requirements

Authorization is **OPTIONAL** for MCP implementations. When supported:

- Implementations using an HTTP-based transport **SHOULD** conform to this specification.
- Implementations using an STDIO transport **SHOULD NOT** follow this specification, and
  instead retrieve credentials from the environment.
- Implementations using alternative transports **MUST** follow established security best
  practices for their protocol.

### Standards Compliance

This authorization mechanism is based on established specifications listed below, but
implements a selected subset of their features to ensure security and interoperability
while maintaining simplicity:

- OAuth 2.1 IETF DRAFT ([draft-ietf-oauth-v2-1-13](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13))
- OAuth 2.0 Authorization Server Metadata
  ([RFC8414](https://datatracker.ietf.org/doc/html/rfc8414))
- OAuth 2.0 Dynamic Client Registration Protocol
  ([RFC7591](https://datatracker.ietf.org/doc/html/rfc7591))
- OAuth 2.0 Protected Resource Metadata ([RFC9728](https://datatracker.ietf.org/doc/html/rfc9728))

## Authorization Flow

### Roles

A protected _MCP server_ acts as an [OAuth 2.1 resource server](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-13.html#name-roles),
capable of accepting and responding to protected resource requests using access tokens.

An _MCP client_ acts as an [OAuth 2.1 client](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-13.html#name-roles),
making protected resource requests on behalf of a resource owner.

The _authorization server_ is responsible for interacting with the user (if necessary) and issuing access tokens for use at the MCP server.
The implementation details of the authorization server are beyond the scope of this specification. It may be hosted with the
resource server or a separate entity. The [Authorization Server Discovery section](#authorization-server-discovery)
specifies how an MCP server indicates the location of its corresponding authorization server to a client.

### Overview

1. Authorization servers **MUST** implement OAuth 2.1 with appropriate security
   measures for both confidential and public clients.

1. Authorization servers and MCP clients **SHOULD** support the OAuth 2.0 Dynamic Client Registration
   Protocol ([RFC7591](https://datatracker.ietf.org/doc/html/rfc7591)).

1. MCP servers **MUST** implement OAuth 2.0 Protected Resource Metadata ([RFC9728](https://datatracker.ietf.org/doc/html/rfc9728)).
   MCP clients **MUST** use OAuth 2.0 Protected Resource Metadata for authorization server discovery.

1. MCP authorization servers **MUST** provide OAuth 2.0 Authorization
   Server Metadata ([RFC8414](https://datatracker.ietf.org/doc/html/rfc8414)).
   MCP clients **MUST** use the OAuth 2.0 Authorization Server Metadata.

### Authorization Server Discovery

This section describes the mechanisms by which MCP servers advertise their associated
authorization servers to MCP clients, as well as the discovery process through which MCP
clients can determine authorization server endpoints and supported capabilities.

#### Authorization Server Location

MCP servers **MUST** implement the OAuth 2.0 Protected Resource Metadata ([RFC9728](https://datatracker.ietf.org/doc/html/rfc9728))
specification to indicate the locations of authorization servers. The Protected Resource Metadata document returned by the MCP server **MUST** include
the `authorization_servers` field containing at least one authorization server.

The specific use of `authorization_servers` is beyond the scope of this specification; implementers should consult
OAuth 2.0 Protected Resource Metadata ([RFC9728](https://datatracker.ietf.org/doc/html/rfc9728)) for
guidance on implementation details.

Implementors should note that Protected Resource Metadata documents can define multiple authorization servers. The responsibility for selecting which authorization server to use lies with the MCP client, following the guidelines specified in
[RFC9728 Section 7.6 "Authorization Servers"](https://datatracker.ietf.org/doc/html/rfc9728#name-authorization-servers).

MCP servers **MUST** use the HTTP header `WWW-Authenticate` when returning a _401 Unauthorized_ to indicate the location of the resource server metadata URL
as described in [RFC9728 Section 5.1 "WWW-Authenticate Response"](https://datatracker.ietf.org/doc/html/rfc9728#name-www-authenticate-response).

MCP clients **MUST** be able to parse `WWW-Authenticate` headers and respond appropriately to `HTTP 401 Unauthorized` responses from the MCP server.

#### Server Metadata Discovery

MCP clients **MUST** follow the OAuth 2.0 Authorization Server Metadata [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414)
specification to obtain the information required to interact with the authorization server.

#### Sequence Diagram

The following diagram outlines an example flow:

```mermaid
sequenceDiagram
    participant C as Client
    participant M as MCP Server (Resource Server)
    participant A as Authorization Server

    C->>M: MCP request without token
    M-->>C: HTTP 401 Unauthorized with WWW-Authenticate header
    Note over C: Extract resource_metadata<br />from WWW-Authenticate

    C->>M: GET /.well-known/oauth-protected-resource
    M-->>C: Resource metadata with authorization server URL
    Note over C: Validate RS metadata,<br />build AS metadata URL

    C->>A: GET /.well-known/oauth-authorization-server
    A-->>C: Authorization server metadata

    Note over C,A: OAuth 2.1 authorization flow happens here

    C->>A: Token request
    A-->>C: Access token

    C->>M: MCP request with access token
    M-->>C: MCP response
    Note over C,M: MCP communication continues with valid token
```

### Dynamic Client Registration

MCP clients and authorization servers **SHOULD** support the
OAuth 2.0 Dynamic Client Registration Protocol [RFC7591](https://datatracker.ietf.org/doc/html/rfc7591)
to allow MCP clients to obtain OAuth client IDs without user interaction. This provides a
standardized way for clients to automatically register with new authorization servers, which is crucial
for MCP because:

- Clients may not know all possible MCP servers and their authorization servers in advance.
- Manual registration would create friction for users.
- It enables seamless connection to new MCP servers and their authorization servers.
- Authorization servers can implement their own registration policies.

Any authorization servers that _do not_ support Dynamic Client Registration need to provide
alternative ways to obtain a client ID (and, if applicable, client credentials). For one of
these authorization servers, MCP clients will have to either:

1. Hardcode a client ID (and, if applicable, client credentials) specifically for the MCP client to use when
   interacting with that authorization server, or
2. Present a UI to users that allows them to enter these details, after registering an
   OAuth client themselves (e.g., through a configuration interface hosted by the
   server).

### Authorization Flow Steps

The complete Authorization flow proceeds as follows:

```mermaid
sequenceDiagram
    participant B as User-Agent (Browser)
    participant C as Client
    participant M as MCP Server (Resource Server)
    participant A as Authorization Server

    C->>M: MCP request without token
    M->>C: HTTP 401 Unauthorized with WWW-Authenticate header
    Note over C: Extract resource_metadata URL from WWW-Authenticate

    C->>M: Request Protected Resource Metadata
    M->>C: Return metadata

    Note over C: Parse metadata and extract authorization server(s)<br/>Client determines AS to use

    C->>A: GET /.well-known/oauth-authorization-server
    A->>C: Authorization server metadata response

    alt Dynamic client registration
        C->>A: POST /register
        A->>C: Client Credentials
    end

    Note over C: Generate PKCE parameters<br/>Include resource parameter
    C->>B: Open browser with authorization URL + code_challenge + resource
    B->>A: Authorization request with resource parameter
    Note over A: User authorizes
    A->>B: Redirect to callback with authorization code
    B->>C: Authorization code callback
    C->>A: Token request + code_verifier + resource
    A->>C: Access token (+ refresh token)
    C->>M: MCP request with access token
    M-->>C: MCP response
    Note over C,M: MCP communication continues with valid token
```

#### Resource Parameter Implementation

MCP clients **MUST** implement Resource Indicators for OAuth 2.0 as defined in [RFC 8707](https://www.rfc-editor.org/rfc/rfc8707.html)
to explicitly specify the target resource for which the token is being requested. The `resource` parameter:

1. **MUST** be included in both authorization requests and token requests.
2. **MUST** identify the MCP server that the client intends to use the token with.
3. **MUST** use the canonical URI of the MCP server as defined in [RFC 8707 Section 2](https://www.rfc-editor.org/rfc/rfc8707.html#name-access-token-request).

##### Canonical Server URI

For the purposes of this specification, the canonical URI of an MCP server is defined as the resource identifier as specified in
[RFC 8707 Section 2](https://www.rfc-editor.org/rfc/rfc8707.html#section-2) and aligns with the `resource` parameter in
[RFC 9728](https://datatracker.ietf.org/doc/html/rfc9728).

MCP clients **SHOULD** provide the most specific URI that they can for the MCP server they intend to access, following the guidance in [RFC 8707](https://www.rfc-editor.org/rfc/rfc8707). While the canonical form uses lowercase scheme and host components, implementations **SHOULD** accept uppercase scheme and host components for robustness and interoperability.

Examples of valid canonical URIs:

- `https://mcp.example.com/mcp`
- `https://mcp.example.com`
- `https://mcp.example.com:8443`
- `https://mcp.example.com/server/mcp` (when path component is necessary to identify individual MCP server)

Examples of invalid canonical URIs:

- `mcp.example.com` (missing scheme)
- `https://mcp.example.com#fragment` (contains fragment)

> **Note:** While both `https://mcp.example.com/` (with trailing slash) and `https://mcp.example.com` (without trailing slash) are technically valid absolute URIs according to [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986), implementations **SHOULD** consistently use the form without the trailing slash for better interoperability unless the trailing slash is semantically significant for the specific resource.

For example, if accessing an MCP server at `https://mcp.example.com`, the authorization request would include:

```
&resource=https%3A%2F%2Fmcp.example.com
```

MCP clients **MUST** send this parameter regardless of whether authorization servers support it.

### Access Token Usage

#### Token Requirements

Access token handling when making requests to MCP servers **MUST** conform to the requirements defined in
[OAuth 2.1 Section 5 "Resource Requests"](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#section-5).
Specifically:

1. MCP client **MUST** use the Authorization request header field defined in
   [OAuth 2.1 Section 5.1.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#section-5.1.1):

```
Authorization: Bearer <access-token>
```

Note that authorization **MUST** be included in every HTTP request from client to server,
even if they are part of the same logical session.

2. Access tokens **MUST NOT** be included in the URI query string

Example request:

```http
GET /mcp HTTP/1.1
Host: mcp.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

#### Token Handling

MCP servers, acting in their role as an OAuth 2.1 resource server, **MUST** validate access tokens as described in
[OAuth 2.1 Section 5.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#section-5.2).
MCP servers **MUST** validate that access tokens were issued specifically for them as the intended audience,
according to [RFC 8707 Section 2](https://www.rfc-editor.org/rfc/rfc8707.html#section-2).
If validation fails, servers **MUST** respond according to
[OAuth 2.1 Section 5.3](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#section-5.3)
error handling requirements. Invalid or expired tokens **MUST** receive a HTTP 401
response.

MCP clients **MUST NOT** send tokens to the MCP server other than ones issued by the MCP server's authorization server.

Authorization servers **MUST** only accept tokens that are valid for use with their
own resources.

MCP servers **MUST NOT** accept or transit any other tokens.

### Error Handling

Servers **MUST** return appropriate HTTP status codes for authorization errors:

| Status Code | Description  | Usage                                      |
| ----------- | ------------ | ------------------------------------------ |
| 401         | Unauthorized | Authorization required or token invalid    |
| 403         | Forbidden    | Invalid scopes or insufficient permissions |
| 400         | Bad Request  | Malformed authorization request            |

## Security Considerations

Implementations **MUST** follow OAuth 2.1 security best practices as laid out in [OAuth 2.1 Section 7. "Security Considerations"](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#name-security-considerations).

### Token Audience Binding and Validation

[RFC 8707](https://www.rfc-editor.org/rfc/rfc8707.html) Resource Indicators provide critical security benefits by binding tokens to their intended
audiences **when the Authorization Server supports the capability**. To enable current and future adoption:

- MCP clients **MUST** include the `resource` parameter in authorization and token requests as specified in the [Resource Parameter Implementation](#resource-parameter-implementation) section
- MCP servers **MUST** validate that tokens presented to them were specifically issued for their use

The [Security Best Practices document](/specification/draft/basic/security_best_practices#token-passthrough)
outlines why token audience validation is crucial and why token passthrough is explicitly forbidden.

### Token Theft

Attackers who obtain tokens stored by the client, or tokens cached or logged on the server can access protected resources with
requests that appear legitimate to resource servers.

Clients and servers **MUST** implement secure token storage and follow OAuth best practices,
as outlined in [OAuth 2.1, Section 7.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#section-7.1).

Authorization servers **SHOULD** issue short-lived access tokens to reduce the impact of leaked tokens.
For public clients, authorization servers **MUST** rotate refresh tokens as described in [OAuth 2.1 Section 4.3.1 "Token Endpoint Extension"](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#section-4.3.1).

### Communication Security

Implementations **MUST** follow [OAuth 2.1 Section 1.5 "Communication Security"](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#section-1.5).

Specifically:

1. All authorization server endpoints **MUST** be served over HTTPS.
1. All redirect URIs **MUST** be either `localhost` or use HTTPS.

### Authorization Code Protection

An attacker who has gained access to an authorization code contained in an authorization response can try to redeem the authorization code for an access token or otherwise make use of the authorization code.
(Further described in [OAuth 2.1 Section 7.5](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#section-7.5))

To mitigate this, MCP clients **MUST** implement PKCE according to [OAuth 2.1 Section 7.5.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#section-7.5.2).
PKCE helps prevent authorization code interception and injection attacks by requiring clients to create a secret verifier-challenge pair, ensuring that only the original requestor can exchange an authorization code for tokens.

### Open Redirection

An attacker may craft malicious redirect URIs to direct users to phishing sites.

MCP clients **MUST** have redirect URIs registered with the authorization server.

Authorization servers **MUST** validate exact redirect URIs against pre-registered values to prevent redirection attacks.

MCP clients **SHOULD** use and verify state parameters in the authorization code flow
and discard any results that do not include or have a mismatch with the original state.

Authorization servers **MUST** take precautions to prevent redirecting user agents to untrusted URI's, following suggestions laid out in [OAuth 2.1 Section 7.12.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#section-7.12.2)

Authorization servers **SHOULD** only automatically redirect the user agent if it trusts the redirection URI. If the URI is not trusted, the authorization server MAY inform the user and rely on the user to make the correct decision.

### Confused Deputy Problem

Attackers can exploit MCP servers acting as intermediaries to third-party APIs, leading to [confused deputy vulnerabilities](/specification/draft/basic/security_best_practices#confused-deputy-problem).
By using stolen authorization codes, they can obtain access tokens without user consent.

MCP proxy servers using static client IDs **MUST** obtain user consent for each dynamically
registered client before forwarding to third-party authorization servers (which may require additional consent).

### Access Token Privilege Restriction

An attacker can gain unauthorized access or otherwise compromise a MCP server if the server accepts tokens issued for other resources.

This vulnerability has two critical dimensions:

1. **Audience validation failures.** When an MCP server doesn't verify that tokens were specifically intended for it (for example, via the audience claim, as mentioned in [RFC9068](https://www.rfc-editor.org/rfc/rfc9068.html)), it may accept tokens originally issued for other services. This breaks a fundamental OAuth security boundary, allowing attackers to reuse legitimate tokens across different services than intended.
2. **Token passthrough.** If the MCP server not only accepts tokens with incorrect audiences but also forwards these unmodified tokens to downstream services, it can potentially cause the ["confused deputy" problem](#confused-deputy-problem), where the downstream API may incorrectly trust the token as if it came from the MCP server or assume the token was validated by the upstream API. See the [Token Passthrough section](/specification/draft/basic/security_best_practices#token-passthrough) of the Security Best Practices guide for additional details.

MCP servers **MUST** validate access tokens before processing the request, ensuring the access token is issued specifically for the MCP server, and take all necessary steps to ensure no data is returned to unauthorized parties.

A MCP server **MUST** follow the guidelines in [OAuth 2.1 - Section 5.2](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-13.html#section-5.2) to validate inbound tokens.

MCP servers **MUST** only accept tokens specifically intended for themselves and **MUST** reject tokens that do not include them in the audience claim or otherwise verify that they are the intended recipient of the token. See the [Security Best Practices Token Passthrough section](/specification/draft/basic/security_best_practices#token-passthrough) for details.

If the MCP server makes requests to upstream APIs, it may act as an OAuth client to them. The access token used at the upstream API is a seperate token, issued by the upstream authorization server. The MCP server **MUST NOT** pass through the token it received from the MCP client.

MCP clients **MUST** implement and use the `resource` parameter as defined in [RFC 8707 - Resource Indicators for OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8707.html)
to explicitly specify the target resource for which the token is being requested. This requirement aligns with the recommendation in
[RFC 9728 Section 7.4](https://datatracker.ietf.org/doc/html/rfc9728#section-7.4). This ensures that access tokens are bound to their intended resources and
cannot be misused across different services.

--- END OF FILE draft/basic/authorization.mdx ---


--- START OF FILE draft/basic/index.mdx ---
---
title: Overview
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol consists of several key components that work together:

- **Base Protocol**: Core JSON-RPC message types
- **Lifecycle Management**: Connection initialization, capability negotiation, and
  session control
- **Authorization**: Authentication and authorization framework for HTTP-based transports
- **Server Features**: Resources, prompts, and tools exposed by servers
- **Client Features**: Sampling and root directory lists provided by clients
- **Utilities**: Cross-cutting concerns like logging and argument completion

All implementations **MUST** support the base protocol and lifecycle management
components. Other components **MAY** be implemented based on the specific needs of the
application.

These protocol layers establish clear separation of concerns while enabling rich
interactions between clients and servers. The modular design allows implementations to
support exactly the features they need.

## Messages

All messages between MCP clients and servers **MUST** follow the
[JSON-RPC 2.0](https://www.jsonrpc.org/specification) specification. The protocol defines
these types of messages:

### Requests

Requests are sent from the client to the server or vice versa, to initiate an operation.

```typescript
{
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

- Requests **MUST** include a string or integer ID.
- Unlike base JSON-RPC, the ID **MUST NOT** be `null`.
- The request ID **MUST NOT** have been previously used by the requestor within the same
  session.

### Responses

Responses are sent in reply to requests, containing the result or error of the operation.

```typescript
{
  jsonrpc: "2.0";
  id: string | number;
  result?: {
    [key: string]: unknown;
  }
  error?: {
    code: number;
    message: string;
    data?: unknown;
  }
}
```

- Responses **MUST** include the same ID as the request they correspond to.
- **Responses** are further sub-categorized as either **successful results** or
  **errors**. Either a `result` or an `error` **MUST** be set. A response **MUST NOT**
  set both.
- Results **MAY** follow any JSON object structure, while errors **MUST** include an
  error code and message at minimum.
- Error codes **MUST** be integers.

### Notifications

Notifications are sent from the client to the server or vice versa, as a one-way message.
The receiver **MUST NOT** send a response.

```typescript
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

- Notifications **MUST NOT** include an ID.

## Auth

MCP provides an [Authorization](/specification/draft/basic/authorization) framework for use with HTTP.
Implementations using an HTTP-based transport **SHOULD** conform to this specification,
whereas implementations using STDIO transport **SHOULD NOT** follow this specification,
and instead retrieve credentials from the environment.

Additionally, clients and servers **MAY** negotiate their own custom authentication and
authorization strategies.

For further discussions and contributions to the evolution of MCPâ€™s auth mechanisms, join
us in
[GitHub Discussions](https://github.com/modelcontextprotocol/specification/discussions)
to help shape the future of the protocol!

## Schema

The full specification of the protocol is defined as a
[TypeScript schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/draft/schema.ts).
This is the source of truth for all protocol messages and structures.

There is also a
[JSON Schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/draft/schema.json),
which is automatically generated from the TypeScript source of truth, for use with
various automated tooling.

### General fields

#### `_meta`

The `_meta` property/parameter is reserved by MCP to allow clients and servers
to attach additional metadata to their interactions.

Certain key names are reserved by MCP for protocol-level metadata, as specified below;
implementations MUST NOT make assumptions about values at these keys.

Additionally, definitions in the [schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/draft/schema.ts)
may reserve particular names for purpose-specific metadata, as declared in those definitions.

**Key name format:** valid `_meta` key names have two segments: an optional **prefix**, and a **name**.

**Prefix:**

- If specified, MUST be a series of labels separated by dots (`.`), followed by a slash (`/`).
  - Labels MUST start with a letter and end with a letter or digit; interior characters can be letters, digits, or hyphens (`-`).
- Any prefix beginning with zero or more valid labels, followed by `modelcontextprotocol` or `mcp`, followed by any valid label,
  is **reserved** for MCP use.
  - For example: `modelcontextprotocol.io/`, `mcp.dev/`, `api.modelcontextprotocol.org/`, and `tools.mcp.com/` are all reserved.

**Name:**

- Unless empty, MUST begin and end with an alphanumeric character (`[a-z0-9A-Z]`).
- MAY contain hyphens (`-`), underscores (`_`), dots (`.`), and alphanumerics in between.

--- END OF FILE draft/basic/index.mdx ---


--- START OF FILE draft/basic/lifecycle.mdx ---
---
title: Lifecycle
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol (MCP) defines a rigorous lifecycle for client-server
connections that ensures proper capability negotiation and state management.

1. **Initialization**: Capability negotiation and protocol version agreement
2. **Operation**: Normal protocol communication
3. **Shutdown**: Graceful termination of the connection

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Initialization Phase
    activate Client
    Client->>+Server: initialize request
    Server-->>Client: initialize response
    Client--)Server: initialized notification

    Note over Client,Server: Operation Phase
    rect rgb(200, 220, 250)
        note over Client,Server: Normal protocol operations
    end

    Note over Client,Server: Shutdown
    Client--)-Server: Disconnect
    deactivate Server
    Note over Client,Server: Connection closed
```

## Lifecycle Phases

### Initialization

The initialization phase **MUST** be the first interaction between client and server.
During this phase, the client and server:

- Establish protocol version compatibility
- Exchange and negotiate capabilities
- Share implementation details

The client **MUST** initiate this phase by sending an `initialize` request containing:

- Protocol version supported
- Client capabilities
- Client implementation information

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "roots": {
        "listChanged": true
      },
      "sampling": {},
      "elicitation": {}
    },
    "clientInfo": {
      "name": "ExampleClient",
      "title": "Example Client Display Name",
      "version": "1.0.0"
    }
  }
}
```

The server **MUST** respond with its own capabilities and information:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "logging": {},
      "prompts": {
        "listChanged": true
      },
      "resources": {
        "subscribe": true,
        "listChanged": true
      },
      "tools": {
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "ExampleServer",
      "title": "Example Server Display Name",
      "version": "1.0.0"
    },
    "instructions": "Optional instructions for the client"
  }
}
```

After successful initialization, the client **MUST** send an `initialized` notification
to indicate it is ready to begin normal operations:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized"
}
```

- The client **SHOULD NOT** send requests other than
  [pings](/specification/draft/basic/utilities/ping) before the server has responded to the
  `initialize` request.
- The server **SHOULD NOT** send requests other than
  [pings](/specification/draft/basic/utilities/ping) and
  [logging](/specification/draft/server/utilities/logging) before receiving the `initialized`
  notification.

#### Version Negotiation

In the `initialize` request, the client **MUST** send a protocol version it supports.
This **SHOULD** be the _latest_ version supported by the client.

If the server supports the requested protocol version, it **MUST** respond with the same
version. Otherwise, the server **MUST** respond with another protocol version it
supports. This **SHOULD** be the _latest_ version supported by the server.

If the client does not support the version in the server's response, it **SHOULD**
disconnect.

<Note>
If using HTTP, the client **MUST** include the `MCP-Protocol-Version:
<protocol-version>` HTTP header on all subsequent requests to the MCP
server.
For details, see [the Protocol Version Header section in Transports](/specification/draft/basic/transports#protocol-version-header).
</Note>

#### Capability Negotiation

Client and server capabilities establish which optional protocol features will be
available during the session.

Key capabilities include:

| Category | Capability     | Description                                                                          |
| -------- | -------------- | ------------------------------------------------------------------------------------ |
| Client   | `roots`        | Ability to provide filesystem [roots](/specification/draft/client/roots)             |
| Client   | `sampling`     | Support for LLM [sampling](/specification/draft/client/sampling) requests            |
| Client   | `elicitation`  | Support for server [elicitation](/specification/draft/client/elicitation) requests   |
| Client   | `experimental` | Describes support for non-standard experimental features                             |
| Server   | `prompts`      | Offers [prompt templates](/specification/draft/server/prompts)                       |
| Server   | `resources`    | Provides readable [resources](/specification/draft/server/resources)                 |
| Server   | `tools`        | Exposes callable [tools](/specification/draft/server/tools)                          |
| Server   | `logging`      | Emits structured [log messages](/specification/draft/server/utilities/logging)       |
| Server   | `completions`  | Supports argument [autocompletion](/specification/draft/server/utilities/completion) |
| Server   | `experimental` | Describes support for non-standard experimental features                             |

Capability objects can describe sub-capabilities like:

- `listChanged`: Support for list change notifications (for prompts, resources, and
  tools)
- `subscribe`: Support for subscribing to individual items' changes (resources only)

### Operation

During the operation phase, the client and server exchange messages according to the
negotiated capabilities.

Both parties **SHOULD**:

- Respect the negotiated protocol version
- Only use capabilities that were successfully negotiated

### Shutdown

During the shutdown phase, one side (usually the client) cleanly terminates the protocol
connection. No specific shutdown messages are definedâ€”instead, the underlying transport
mechanism should be used to signal connection termination:

#### stdio

For the stdio [transport](/specification/draft/basic/transports), the client **SHOULD** initiate
shutdown by:

1. First, closing the input stream to the child process (the server)
2. Waiting for the server to exit, or sending `SIGTERM` if the server does not exit
   within a reasonable time
3. Sending `SIGKILL` if the server does not exit within a reasonable time after `SIGTERM`

The server **MAY** initiate shutdown by closing its output stream to the client and
exiting.

#### HTTP

For HTTP [transports](/specification/draft/basic/transports), shutdown is indicated by closing the
associated HTTP connection(s).

## Timeouts

Implementations **SHOULD** establish timeouts for all sent requests, to prevent hung
connections and resource exhaustion. When the request has not received a success or error
response within the timeout period, the sender **SHOULD** issue a [cancellation
notification](/specification/draft/basic/utilities/cancellation) for that request and stop waiting for
a response.

SDKs and other middleware **SHOULD** allow these timeouts to be configured on a
per-request basis.

Implementations **MAY** choose to reset the timeout clock when receiving a [progress
notification](/specification/draft/basic/utilities/progress) corresponding to the request, as this
implies that work is actually happening. However, implementations **SHOULD** always
enforce a maximum timeout, regardless of progress notifications, to limit the impact of a
misbehaving client or server.

## Error Handling

Implementations **SHOULD** be prepared to handle these error cases:

- Protocol version mismatch
- Failure to negotiate required capabilities
- Request [timeouts](#timeouts)

Example initialization error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Unsupported protocol version",
    "data": {
      "supported": ["2024-11-05"],
      "requested": "1.0.0"
    }
  }
}
```

--- END OF FILE draft/basic/lifecycle.mdx ---


--- START OF FILE draft/basic/security_best_practices.mdx ---
---
title: Security Best Practices
---

<div id="enable-section-numbers" />

## Introduction

### Purpose and Scope

This document provides security considerations for the Model Context Protocol (MCP), complementing the MCP Authorization specification. This document identifies security risks, attack vectors, and best practices specific to MCP implementations.

The primary audience for this document includes developers implementing MCP authorization flows, MCP server operators, and security professionals evaluating MCP-based systems. This document should be read alongside the MCP Authorization specification and [OAuth 2.0 security best practices](https://datatracker.ietf.org/doc/html/rfc9700).

## Attacks and Mitigations

This section gives a detailed description of attacks on MCP implementations, along with potential countermeasures.

### Confused Deputy Problem

Attackers can exploit MCP servers proxying other resource servers, creating "[confused deputy](https://en.wikipedia.org/wiki/Confused_deputy_problem)" vulnerabilities.

#### Terminology

**MCP Proxy Server**
: An MCP server that connects MCP clients to third-party APIs, offering MCP features while delegating operations and acting as a single OAuth client to the third-party API server.

**Third-Party Authorization Server**
: Authorization server that protects the third-party API. It may lack dynamic client registration support, requiring MCP proxy to use a static client ID for all requests.

**Third-Party API**
: The protected resource server that provides the actual API functionality. Access to this
API requires tokens issued by the third-party authorization server.

**Static Client ID**
: A fixed OAuth 2.0 client identifier used by the MCP proxy server when communicating with
the third-party authorization server. This Client ID refers to the MCP server acting as a client
to the Third-Party API. It is the same value for all MCP server to Third-Party API interactions regardless of
which MCP client initiated the request.

#### Architecture and Attack Flows

##### Normal OAuth proxy usage (preserves user consent)

```mermaid
sequenceDiagram
    participant UA as User-Agent (Browser)
    participant MC as MCP Client
    participant M as MCP Proxy Server
    participant TAS as Third-Party Authorization Server

    Note over UA,M: Initial Auth flow completed

    Note over UA,TAS: Step 1: Legitimate user consent for Third Party Server

    M->>UA: Redirect to third party authorization server
    UA->>TAS: Authorization request (client_id: mcp-proxy)
    TAS->>UA: Authorization consent screen
    Note over UA: Review consent screen
    UA->>TAS: Approve
    TAS->>UA: Set consent cookie for client ID: mcp-proxy
    TAS->>UA: 3P Authorization code + redirect to mcp-proxy-server.com
    UA->>M: 3P Authorization code
    Note over M,TAS: Exchange 3P code for 3P token
    Note over M: Generate MCP authorization code
    M->>UA: Redirect to MCP Client with MCP authorization code

    Note over M,UA: Exchange code for token, etc.
```

##### Malicious OAuth proxy usage (skips user consent)

```mermaid
sequenceDiagram
    participant UA as User-Agent (Browser)
    participant M as MCP Proxy Server
    participant TAS as Third-Party Authorization Server
    participant A as Attacker


    Note over UA,A: Step 2: Attack (leveraging existing cookie, skipping consent)
    A->>M: Dynamically register malicious client, redirect_uri: attacker.com
    A->>UA: Sends malicious link
    UA->>TAS: Authorization request (client_id: mcp-proxy) + consent cookie
    rect rgba(255, 17, 0, 0.67)
    TAS->>TAS: Cookie present, consent skipped
    end

   TAS->>UA: 3P Authorization code + redirect to mcp-proxy-server.com
   UA->>M: 3P Authorization code
   Note over M,TAS: Exchange 3P code for 3P token
   Note over M: Generate MCP authorization code
   M->>UA: Redirect to attacker.com with MCP Authorization code
   UA->>A: MCP Authorization code delivered to attacker.com
   Note over M,A: Attacker exchanges MCP code for MCP token
   A->>M: Attacker impersonates user to MCP server
```

#### Attack Description

When an MCP proxy server uses a static client ID to authenticate with a third-party
authorization server that does not support dynamic client registration, the following
attack becomes possible:

1. A user authenticates normally through the MCP proxy server to access the third-party API
2. During this flow, the third-party authorization server sets a cookie on the user agent
   indicating consent for the static client ID
3. An attacker later sends the user a malicious link containing a crafted authorization request which contains a malicious redirect URI along with a new dynamically registered client ID
4. When the user clicks the link, their browser still has the consent cookie from the previous legitimate request
5. The third-party authorization server detects the cookie and skips the consent screen
6. The MCP authorization code is redirected to the attacker's server (specified in the crafted redirect_uri during dynamic client registration)
7. The attacker exchanges the stolen authorization code for access tokens for the MCP server without the user's explicit approval
8. Attacker now has access to the third-party API as the compromised user

#### Mitigation

MCP proxy servers using static client IDs **MUST** obtain user consent for each dynamically
registered client before forwarding to third-party authorization servers (which may require additional consent).

### Token Passthrough

"Token passthrough" is an anti-pattern where an MCP server accepts tokens from an MCP client without validating that the tokens were properly issued _to the MCP server_ and "passing them through" to the downstream API.

#### Risks

Token passthrough is explicitly forbidden in the [authorization specification](/specification/draft/basic/authorization) as it introduces a number of security risks, that include:

- **Security Control Circumvention**
  - The MCP Server or downstream APIs might implement important security controls like rate limiting, request validation, or traffic monitoring, that depend on the token audience or other credential constraints. If clients can obtain and use tokens directly with the downstream APIs without the MCP server validating them properly or ensuring that the tokens are issued for the right service, they bypass these controls.
- **Accountability and Audit Trail Issues**
  - The MCP Server will be unable to identify or distinguish between MCP Clients when clients are calling with an upstream-issued access token which may be opaque to the MCP Server.
  - The downstream Resource Serverâ€™s logs may show requests that appear to come from a different source with a different identity, rather than the MCP server that is actually forwarding the tokens.
  - Both factors make incident investigation, controls, and auditing more difficult.
  - If the MCP Server passes tokens without validating their claims (e.g., roles, privileges, or audience) or other metadata, a malicious actor in possession of a stolen token can use the server as a proxy for data exfiltration.
- **Trust Boundary Issues**
  - The downstream Resource Server grants trust to specific entities. This trust might include assumptions about origin or client behavior patterns. Breaking this trust boundary could lead to unexpected issues.
  - If the token is accepted by multiple services without proper validation, an attacker compromising one service can use the token to access other connected services.
- **Future Compatibility Risk**
  - Even if an MCP Server starts as a "pure proxy" today, it might need to add security controls later. Starting with proper token audience separation makes it easier to evolve the security model.

#### Mitigation

MCP servers **MUST NOT** accept any tokens that were not explicitly issued for the MCP server.

### Session Hijacking

Session hijacking is an attack vector where a client is provided a session ID by the server, and an unauthorized party is able to obtain and use that same session ID to impersonate the original client and perform unauthorized actions on their behalf.

#### Session Hijack Prompt Injection

```mermaid
sequenceDiagram
    participant Client
    participant ServerA
    participant Queue
    participant ServerB
    participant Attacker

    Client->>ServerA: Initialize (connect to streamable HTTP server)
    ServerA-->>Client: Respond with session ID

    Attacker->>ServerB: Access/guess session ID
    Note right of Attacker: Attacker knows/guesses session ID

    Attacker->>ServerB: Trigger event (malicious payload, using session ID)
    ServerB->>Queue: Enqueue event (keyed by session ID)

    ServerA->>Queue: Poll for events (using session ID)
    Queue-->>ServerA: Event data (malicious payload)

    ServerA-->>Client: Async response (malicious payload)
    Client->>Client: Acts based on malicious payload
```

#### Session Hijack Impersonation

```mermaid
sequenceDiagram
    participant Client
    participant Server
    participant Attacker

    Client->>Server: Initialize (login/authenticate)
    Server-->>Client: Respond with session ID (persistent session created)

    Attacker->>Server: Access/guess session ID
    Note right of Attacker: Attacker knows/guesses session ID

    Attacker->>Server: Make API call (using session ID, no re-auth)
    Server-->>Attacker: Respond as if Attacker is Client (session hijack)
```

#### Attack Description

When you have multiple stateful HTTP servers that handle MCP requests, the following attack vectors are possible:

**Session Hijack Prompt Injection**

1. The client connects to **Server A** and receives a session ID.
1. The attacker obtains an existing session ID and sends a malicious event to **Server B** with said session ID.

   - When a server supports [redelivery/resumable streams](/specification/draft/basic/transports#resumability-and-redelivery), deliberately terminating the request before receiving the response could lead to it being resumed by the original client via the GET request for server sent events.
   - If a particular server initiates server sent events as a consequence of a tool call such as a `notifications/tools/list_changed`, where it is possible to affect the tools that are offered by the server, a client could end up with tools that they were not aware were enabled.

1. **Server B** enqueues the event (associated with session ID) into a shared queue.
1. **Server A** polls the queue for events using the session ID and retrieves the malicious payload.
1. **Server A** sends the malicious payload to the client as an asynchronous or resumed response.
1. The client receives and acts on the malicious payload, leading to potential compromise.

**Session Hijack Impersonation**

1. The MCP client authenticates with the MCP server, creating a persistent session ID.
2. The attacker obtains the session ID.
3. The attacker makes calls to the MCP server using the session ID.
4. MCP server does not check for additional authorization and treats the attacker as a legitimate user, allowing unauthorized access or actions.

#### Mitigation

To prevent session hijacking and event injection attacks, the following mitigations should be implemented:

MCP servers that implement authorization **MUST** verify all inbound requests.
MCP Servers **MUST NOT** use sessions for authentication.

MCP servers **MUST** use secure, non-deterministic session IDs.
Generated session IDs (e.g., UUIDs) **SHOULD** use secure random number generators. Avoid predictable or sequential session identifiers that could be guessed by an attacker. Rotating or expiring session IDs can also reduce the risk.

MCP servers **SHOULD** bind session IDs to user-specific information.
When storing or transmitting session-related data (e.g., in a queue), combine the session ID with information unique to the authorized user, such as their internal user ID. Use a key format like `<user_id>:<session_id>`. This ensures that even if an attacker guesses a session ID, they cannot impersonate another user as the user ID is derived from the user token and not provided by the client.

MCP servers can optionally leverage additional unique identifiers.

--- END OF FILE draft/basic/security_best_practices.mdx ---


--- START OF FILE draft/basic/transports.mdx ---
---
title: Transports
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

MCP uses JSON-RPC to encode messages. JSON-RPC messages **MUST** be UTF-8 encoded.

The protocol currently defines two standard transport mechanisms for client-server
communication:

1. [stdio](#stdio), communication over standard in and standard out
2. [Streamable HTTP](#streamable-http)

Clients **SHOULD** support stdio whenever possible.

It is also possible for clients and servers to implement
[custom transports](#custom-transports) in a pluggable fashion.

## stdio

In the **stdio** transport:

- The client launches the MCP server as a subprocess.
- The server reads JSON-RPC messages from its standard input (`stdin`) and sends messages
  to its standard output (`stdout`).
- Messages are individual JSON-RPC requests, notifications, or responses.
- Messages are delimited by newlines, and **MUST NOT** contain embedded newlines.
- The server **MAY** write UTF-8 strings to its standard error (`stderr`) for logging
  purposes. Clients **MAY** capture, forward, or ignore this logging.
- The server **MUST NOT** write anything to its `stdout` that is not a valid MCP message.
- The client **MUST NOT** write anything to the server's `stdin` that is not a valid MCP
  message.

```mermaid
sequenceDiagram
    participant Client
    participant Server Process

    Client->>+Server Process: Launch subprocess
    loop Message Exchange
        Client->>Server Process: Write to stdin
        Server Process->>Client: Write to stdout
        Server Process--)Client: Optional logs on stderr
    end
    Client->>Server Process: Close stdin, terminate subprocess
    deactivate Server Process
```

## Streamable HTTP

<Info>

This replaces the [HTTP+SSE
transport](/specification/2024-11-05/basic/transports#http-with-sse) from
protocol version 2024-11-05. See the [backwards compatibility](#backwards-compatibility)
guide below.

</Info>

In the **Streamable HTTP** transport, the server operates as an independent process that
can handle multiple client connections. This transport uses HTTP POST and GET requests.
Server can optionally make use of
[Server-Sent Events](https://en.wikipedia.org/wiki/Server-sent_events) (SSE) to stream
multiple server messages. This permits basic MCP servers, as well as more feature-rich
servers supporting streaming and server-to-client notifications and requests.

The server **MUST** provide a single HTTP endpoint path (hereafter referred to as the
**MCP endpoint**) that supports both POST and GET methods. For example, this could be a
URL like `https://example.com/mcp`.

#### Security Warning

When implementing Streamable HTTP transport:

1. Servers **MUST** validate the `Origin` header on all incoming connections to prevent DNS rebinding attacks
2. When running locally, servers **SHOULD** bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)
3. Servers **SHOULD** implement proper authentication for all connections

Without these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.

### Sending Messages to the Server

Every JSON-RPC message sent from the client **MUST** be a new HTTP POST request to the
MCP endpoint.

1. The client **MUST** use HTTP POST to send JSON-RPC messages to the MCP endpoint.
2. The client **MUST** include an `Accept` header, listing both `application/json` and
   `text/event-stream` as supported content types.
3. The body of the POST request **MUST** be a single JSON-RPC _request_, _notification_, or _response_.
4. If the input is a JSON-RPC _response_ or _notification_:
   - If the server accepts the input, the server **MUST** return HTTP status code 202
     Accepted with no body.
   - If the server cannot accept the input, it **MUST** return an HTTP error status code
     (e.g., 400 Bad Request). The HTTP response body **MAY** comprise a JSON-RPC _error
     response_ that has no `id`.
5. If the input is a JSON-RPC _request_, the server **MUST** either
   return `Content-Type: text/event-stream`, to initiate an SSE stream, or
   `Content-Type: application/json`, to return one JSON object. The client **MUST**
   support both these cases.
6. If the server initiates an SSE stream:
   - The SSE stream **SHOULD** eventually include JSON-RPC _response_ for the
     JSON-RPC _request_ sent in the POST body.
   - The server **MAY** send JSON-RPC _requests_ and _notifications_ before sending the
     JSON-RPC _response_. These messages **SHOULD** relate to the originating client
     _request_.
   - The server **SHOULD NOT** close the SSE stream before sending the JSON-RPC _response_
     for the received JSON-RPC _request_, unless the [session](#session-management)
     expires.
   - After the JSON-RPC _response_ has been sent, the server **SHOULD** close the SSE
     stream.
   - Disconnection **MAY** occur at any time (e.g., due to network conditions).
     Therefore:
     - Disconnection **SHOULD NOT** be interpreted as the client cancelling its request.
     - To cancel, the client **SHOULD** explicitly send an MCP `CancelledNotification`.
     - To avoid message loss due to disconnection, the server **MAY** make the stream
       [resumable](#resumability-and-redelivery).

### Listening for Messages from the Server

1. The client **MAY** issue an HTTP GET to the MCP endpoint. This can be used to open an
   SSE stream, allowing the server to communicate to the client, without the client first
   sending data via HTTP POST.
2. The client **MUST** include an `Accept` header, listing `text/event-stream` as a
   supported content type.
3. The server **MUST** either return `Content-Type: text/event-stream` in response to
   this HTTP GET, or else return HTTP 405 Method Not Allowed, indicating that the server
   does not offer an SSE stream at this endpoint.
4. If the server initiates an SSE stream:
   - The server **MAY** send JSON-RPC _requests_ and _notifications_ on the stream.
   - These messages **SHOULD** be unrelated to any concurrently-running JSON-RPC
     _request_ from the client.
   - The server **MUST NOT** send a JSON-RPC _response_ on the stream **unless**
     [resuming](#resumability-and-redelivery) a stream associated with a previous client
     request.
   - The server **MAY** close the SSE stream at any time.
   - The client **MAY** close the SSE stream at any time.

### Multiple Connections

1. The client **MAY** remain connected to multiple SSE streams simultaneously.
2. The server **MUST** send each of its JSON-RPC messages on only one of the connected
   streams; that is, it **MUST NOT** broadcast the same message across multiple streams.
   - The risk of message loss **MAY** be mitigated by making the stream
     [resumable](#resumability-and-redelivery).

### Resumability and Redelivery

To support resuming broken connections, and redelivering messages that might otherwise be
lost:

1. Servers **MAY** attach an `id` field to their SSE events, as described in the
   [SSE standard](https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation).
   - If present, the ID **MUST** be globally unique across all streams within that
     [session](#session-management)â€”or all streams with that specific client, if session
     management is not in use.
2. If the client wishes to resume after a broken connection, it **SHOULD** issue an HTTP
   GET to the MCP endpoint, and include the
   [`Last-Event-ID`](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-last-event-id-header)
   header to indicate the last event ID it received.
   - The server **MAY** use this header to replay messages that would have been sent
     after the last event ID, _on the stream that was disconnected_, and to resume the
     stream from that point.
   - The server **MUST NOT** replay messages that would have been delivered on a
     different stream.

In other words, these event IDs should be assigned by servers on a _per-stream_ basis, to
act as a cursor within that particular stream.

### Session Management

An MCP "session" consists of logically related interactions between a client and a
server, beginning with the [initialization phase](/specification/draft/basic/lifecycle). To support
servers which want to establish stateful sessions:

1. A server using the Streamable HTTP transport **MAY** assign a session ID at
   initialization time, by including it in an `Mcp-Session-Id` header on the HTTP
   response containing the `InitializeResult`.
   - The session ID **SHOULD** be globally unique and cryptographically secure (e.g., a
     securely generated UUID, a JWT, or a cryptographic hash).
   - The session ID **MUST** only contain visible ASCII characters (ranging from 0x21 to
     0x7E).
2. If an `Mcp-Session-Id` is returned by the server during initialization, clients using
   the Streamable HTTP transport **MUST** include it in the `Mcp-Session-Id` header on
   all of their subsequent HTTP requests.
   - Servers that require a session ID **SHOULD** respond to requests without an
     `Mcp-Session-Id` header (other than initialization) with HTTP 400 Bad Request.
3. The server **MAY** terminate the session at any time, after which it **MUST** respond
   to requests containing that session ID with HTTP 404 Not Found.
4. When a client receives HTTP 404 in response to a request containing an
   `Mcp-Session-Id`, it **MUST** start a new session by sending a new `InitializeRequest`
   without a session ID attached.
5. Clients that no longer need a particular session (e.g., because the user is leaving
   the client application) **SHOULD** send an HTTP DELETE to the MCP endpoint with the
   `Mcp-Session-Id` header, to explicitly terminate the session.
   - The server **MAY** respond to this request with HTTP 405 Method Not Allowed,
     indicating that the server does not allow clients to terminate sessions.

### Sequence Diagram

```mermaid
sequenceDiagram
    participant Client
    participant Server

    note over Client, Server: initialization

    Client->>+Server: POST InitializeRequest
    Server->>-Client: InitializeResponse<br>Mcp-Session-Id: 1868a90c...

    Client->>+Server: POST InitializedNotification<br>Mcp-Session-Id: 1868a90c...
    Server->>-Client: 202 Accepted

    note over Client, Server: client requests
    Client->>+Server: POST ... request ...<br>Mcp-Session-Id: 1868a90c...

    alt single HTTP response
      Server->>Client: ... response ...
    else server opens SSE stream
      loop while connection remains open
          Server-)Client: ... SSE messages from server ...
      end
      Server-)Client: SSE event: ... response ...
    end
    deactivate Server

    note over Client, Server: client notifications/responses
    Client->>+Server: POST ... notification/response ...<br>Mcp-Session-Id: 1868a90c...
    Server->>-Client: 202 Accepted

    note over Client, Server: server requests
    Client->>+Server: GET<br>Mcp-Session-Id: 1868a90c...
    loop while connection remains open
        Server-)Client: ... SSE messages from server ...
    end
    deactivate Server

```

### Protocol Version Header

If using HTTP, the client **MUST** include the `MCP-Protocol-Version:
<protocol-version>` HTTP header on all subsequent requests to the MCP
server, allowing the MCP server to respond based on the MCP protocol version.

For example: `MCP-Protocol-Version: 2025-06-18`

The protocol version sent by the client **SHOULD** be the one [negotiated during
initialization](/specification/draft/basic/lifecycle#version-negotiation).

For backwards compatibility, if the server does _not_ receive an `MCP-Protocol-Version`
header, and has no other way to identify the version - for example, by relying on the
protocol version negotiated during initialization - the server **SHOULD** assume protocol
version `2025-03-26`.

If the server receives a request with an invalid or unsupported
`MCP-Protocol-Version`, it **MUST** respond with `400 Bad Request`.

### Backwards Compatibility

Clients and servers can maintain backwards compatibility with the deprecated [HTTP+SSE
transport](/specification/2024-11-05/basic/transports#http-with-sse) (from
protocol version 2024-11-05) as follows:

**Servers** wanting to support older clients should:

- Continue to host both the SSE and POST endpoints of the old transport, alongside the
  new "MCP endpoint" defined for the Streamable HTTP transport.
  - It is also possible to combine the old POST endpoint and the new MCP endpoint, but
    this may introduce unneeded complexity.

**Clients** wanting to support older servers should:

1. Accept an MCP server URL from the user, which may point to either a server using the
   old transport or the new transport.
2. Attempt to POST an `InitializeRequest` to the server URL, with an `Accept` header as
   defined above:
   - If it succeeds, the client can assume this is a server supporting the new Streamable
     HTTP transport.
   - If it fails with an HTTP 4xx status code (e.g., 405 Method Not Allowed or 404 Not
     Found):
     - Issue a GET request to the server URL, expecting that this will open an SSE stream
       and return an `endpoint` event as the first event.
     - When the `endpoint` event arrives, the client can assume this is a server running
       the old HTTP+SSE transport, and should use that transport for all subsequent
       communication.

## Custom Transports

Clients and servers **MAY** implement additional custom transport mechanisms to suit
their specific needs. The protocol is transport-agnostic and can be implemented over any
communication channel that supports bidirectional message exchange.

Implementers who choose to support custom transports **MUST** ensure they preserve the
JSON-RPC message format and lifecycle requirements defined by MCP. Custom transports
**SHOULD** document their specific connection establishment and message exchange patterns
to aid interoperability.

--- END OF FILE draft/basic/transports.mdx ---


--- START OF FILE draft/client/elicitation.mdx ---
---
title: Elicitation
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

<Note>

Elicitation is newly introduced in this version of the MCP specification and its design may evolve in future protocol versions.

</Note>

The Model Context Protocol (MCP) provides a standardized way for servers to request additional
information from users through the client during interactions. This flow allows clients to
maintain control over user interactions and data sharing while enabling servers to gather
necessary information dynamically.
Servers request structured data from users with JSON schemas to validate responses.

## User Interaction Model

Elicitation in MCP allows servers to implement interactive workflows by enabling user input
requests to occur _nested_ inside other MCP server features.

Implementations are free to expose elicitation through any interface pattern that suits
their needs&mdash;the protocol itself does not mandate any specific user interaction
model.

<Warning>

For trust & safety and security:

- Servers **MUST NOT** use elicitation to request sensitive information.

Applications **SHOULD**:

- Provide UI that makes it clear which server is requesting information
- Allow users to review and modify their responses before sending
- Respect user privacy and provide clear decline and cancel options

</Warning>

## Capabilities

Clients that support elicitation **MUST** declare the `elicitation` capability during
[initialization](/specification/draft/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "elicitation": {}
  }
}
```

## Protocol Messages

### Creating Elicitation Requests

To request information from a user, servers send an `elicitation/create` request:

#### Simple Text Request

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "elicitation/create",
  "params": {
    "message": "Please provide your GitHub username",
    "requestedSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      },
      "required": ["name"]
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "action": "accept",
    "content": {
      "name": "octocat"
    }
  }
}
```

#### Structured Data Request

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "elicitation/create",
  "params": {
    "message": "Please provide your contact information",
    "requestedSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Your full name"
        },
        "email": {
          "type": "string",
          "format": "email",
          "description": "Your email address"
        },
        "age": {
          "type": "number",
          "minimum": 18,
          "description": "Your age"
        }
      },
      "required": ["name", "email"]
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "action": "accept",
    "content": {
      "name": "Monalisa Octocat",
      "email": "octocat@github.com",
      "age": 30
    }
  }
}
```

**Reject Response Example:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "action": "decline"
  }
}
```

**Cancel Response Example:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "action": "cancel"
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant User
    participant Client
    participant Server

    Note over Server,Client: Server initiates elicitation
    Server->>Client: elicitation/create

    Note over Client,User: Human interaction
    Client->>User: Present elicitation UI
    User-->>Client: Provide requested information

    Note over Server,Client: Complete request
    Client-->>Server: Return user response

    Note over Server: Continue processing with new information
```

## Request Schema

The `requestedSchema` field allows servers to define the structure of the expected response using a restricted subset of JSON Schema. To simplify implementation for clients, elicitation schemas are limited to flat objects with primitive properties only:

```json
"requestedSchema": {
  "type": "object",
  "properties": {
    "propertyName": {
      "type": "string",
      "title": "Display Name",
      "description": "Description of the property"
    },
    "anotherProperty": {
      "type": "number",
      "minimum": 0,
      "maximum": 100
    }
  },
  "required": ["propertyName"]
}
```

### Supported Schema Types

The schema is restricted to these primitive types:

1. **String Schema**

   ```json
   {
     "type": "string",
     "title": "Display Name",
     "description": "Description text",
     "minLength": 3,
     "maxLength": 50,
     "pattern": "^[A-Za-z]+$",
     "format": "email"
   }
   ```

   Supported formats: `email`, `uri`, `date`, `date-time`

2. **Number Schema**

   ```json
   {
     "type": "number", // or "integer"
     "title": "Display Name",
     "description": "Description text",
     "minimum": 0,
     "maximum": 100
   }
   ```

3. **Boolean Schema**

   ```json
   {
     "type": "boolean",
     "title": "Display Name",
     "description": "Description text",
     "default": false
   }
   ```

4. **Enum Schema**
   ```json
   {
     "type": "string",
     "title": "Display Name",
     "description": "Description text",
     "enum": ["option1", "option2", "option3"],
     "enumNames": ["Option 1", "Option 2", "Option 3"]
   }
   ```

Clients can use this schema to:

1. Generate appropriate input forms
2. Validate user input before sending
3. Provide better guidance to users

Note that complex nested structures, arrays of objects, and other advanced JSON Schema features are intentionally not supported to simplify client implementation.

## Response Actions

Elicitation responses use a three-action model to clearly distinguish between different user actions:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "action": "accept", // or "decline" or "cancel"
    "content": {
      "propertyName": "value",
      "anotherProperty": 42
    }
  }
}
```

The three response actions are:

1. **Accept** (`action: "accept"`): User explicitly approved and submitted with data

   - The `content` field contains the submitted data matching the requested schema
   - Example: User clicked "Submit", "OK", "Confirm", etc.

2. **Decline** (`action: "decline"`): User explicitly declined the request

   - The `content` field is typically omitted
   - Example: User clicked "Reject", "Decline", "No", etc.

3. **Cancel** (`action: "cancel"`): User dismissed without making an explicit choice
   - The `content` field is typically omitted
   - Example: User closed the dialog, clicked outside, pressed Escape, etc.

Servers should handle each state appropriately:

- **Accept**: Process the submitted data
- **Decline**: Handle explicit decline (e.g., offer alternatives)
- **Cancel**: Handle dismissal (e.g., prompt again later)

## Security Considerations

1. Servers **MUST NOT** request sensitive information through elicitation
2. Clients **SHOULD** implement user approval controls
3. Both parties **SHOULD** validate elicitation content against the provided schema
4. Clients **SHOULD** provide clear indication of which server is requesting information
5. Clients **SHOULD** allow users to decline elicitation requests at any time
6. Clients **SHOULD** implement rate limiting
7. Clients **SHOULD** present elicitation requests in a way that makes it clear what information is being requested and why

--- END OF FILE draft/client/elicitation.mdx ---


--- START OF FILE draft/client/roots.mdx ---
---
title: Roots
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol (MCP) provides a standardized way for clients to expose
filesystem "roots" to servers. Roots define the boundaries of where servers can operate
within the filesystem, allowing them to understand which directories and files they have
access to. Servers can request the list of roots from supporting clients and receive
notifications when that list changes.

## User Interaction Model

Roots in MCP are typically exposed through workspace or project configuration interfaces.

For example, implementations could offer a workspace/project picker that allows users to
select directories and files the server should have access to. This can be combined with
automatic workspace detection from version control systems or project files.

However, implementations are free to expose roots through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Capabilities

Clients that support roots **MUST** declare the `roots` capability during
[initialization](/specification/draft/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "roots": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the client will emit notifications when the list of roots
changes.

## Protocol Messages

### Listing Roots

To retrieve roots, servers send a `roots/list` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "roots/list"
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "roots": [
      {
        "uri": "file:///home/user/projects/myproject",
        "name": "My Project"
      }
    ]
  }
}
```

### Root List Changes

When roots change, clients that support `listChanged` **MUST** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/roots/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Server
    participant Client

    Note over Server,Client: Discovery
    Server->>Client: roots/list
    Client-->>Server: Available roots

    Note over Server,Client: Changes
    Client--)Server: notifications/roots/list_changed
    Server->>Client: roots/list
    Client-->>Server: Updated roots
```

## Data Types

### Root

A root definition includes:

- `uri`: Unique identifier for the root. This **MUST** be a `file://` URI in the current
  specification.
- `name`: Optional human-readable name for display purposes.

Example roots for different use cases:

#### Project Directory

```json
{
  "uri": "file:///home/user/projects/myproject",
  "name": "My Project"
}
```

#### Multiple Repositories

```json
[
  {
    "uri": "file:///home/user/repos/frontend",
    "name": "Frontend Repository"
  },
  {
    "uri": "file:///home/user/repos/backend",
    "name": "Backend Repository"
  }
]
```

## Error Handling

Clients **SHOULD** return standard JSON-RPC errors for common failure cases:

- Client does not support roots: `-32601` (Method not found)
- Internal errors: `-32603`

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Roots not supported",
    "data": {
      "reason": "Client does not have roots capability"
    }
  }
}
```

## Security Considerations

1. Clients **MUST**:

   - Only expose roots with appropriate permissions
   - Validate all root URIs to prevent path traversal
   - Implement proper access controls
   - Monitor root accessibility

2. Servers **SHOULD**:
   - Handle cases where roots become unavailable
   - Respect root boundaries during operations
   - Validate all paths against provided roots

## Implementation Guidelines

1. Clients **SHOULD**:

   - Prompt users for consent before exposing roots to servers
   - Provide clear user interfaces for root management
   - Validate root accessibility before exposing
   - Monitor for root changes

2. Servers **SHOULD**:
   - Check for roots capability before usage
   - Handle root list changes gracefully
   - Respect root boundaries in operations
   - Cache root information appropriately

--- END OF FILE draft/client/roots.mdx ---


--- START OF FILE draft/client/sampling.mdx ---
---
title: Sampling
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to request LLM
sampling ("completions" or "generations") from language models via clients. This flow
allows clients to maintain control over model access, selection, and permissions while
enabling servers to leverage AI capabilities&mdash;with no server API keys necessary.
Servers can request text, audio, or image-based interactions and optionally include
context from MCP servers in their prompts.

## User Interaction Model

Sampling in MCP allows servers to implement agentic behaviors, by enabling LLM calls to
occur _nested_ inside other MCP server features.

Implementations are free to expose sampling through any interface pattern that suits
their needs&mdash;the protocol itself does not mandate any specific user interaction
model.

<Warning>

For trust & safety and security, there **SHOULD** always
be a human in the loop with the ability to deny sampling requests.

Applications **SHOULD**:

- Provide UI that makes it easy and intuitive to review sampling requests
- Allow users to view and edit prompts before sending
- Present generated responses for review before delivery

</Warning>

## Capabilities

Clients that support sampling **MUST** declare the `sampling` capability during
[initialization](/specification/draft/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "sampling": {}
  }
}
```

## Protocol Messages

### Creating Messages

To request a language model generation, servers send a `sampling/createMessage` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "What is the capital of France?"
        }
      }
    ],
    "modelPreferences": {
      "hints": [
        {
          "name": "claude-3-sonnet"
        }
      ],
      "intelligencePriority": 0.8,
      "speedPriority": 0.5
    },
    "systemPrompt": "You are a helpful assistant.",
    "maxTokens": 100
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "role": "assistant",
    "content": {
      "type": "text",
      "text": "The capital of France is Paris."
    },
    "model": "claude-3-sonnet-20240307",
    "stopReason": "endTurn"
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Server
    participant Client
    participant User
    participant LLM

    Note over Server,Client: Server initiates sampling
    Server->>Client: sampling/createMessage

    Note over Client,User: Human-in-the-loop review
    Client->>User: Present request for approval
    User-->>Client: Review and approve/modify

    Note over Client,LLM: Model interaction
    Client->>LLM: Forward approved request
    LLM-->>Client: Return generation

    Note over Client,User: Response review
    Client->>User: Present response for approval
    User-->>Client: Review and approve/modify

    Note over Server,Client: Complete request
    Client-->>Server: Return approved response
```

## Data Types

### Messages

Sampling messages can contain:

#### Text Content

```json
{
  "type": "text",
  "text": "The message content"
}
```

#### Image Content

```json
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/jpeg"
}
```

#### Audio Content

```json
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

### Model Preferences

Model selection in MCP requires careful abstraction since servers and clients may use
different AI providers with distinct model offerings. A server cannot simply request a
specific model by name since the client may not have access to that exact model or may
prefer to use a different provider's equivalent model.

To solve this, MCP implements a preference system that combines abstract capability
priorities with optional model hints:

#### Capability Priorities

Servers express their needs through three normalized priority values (0-1):

- `costPriority`: How important is minimizing costs? Higher values prefer cheaper models.
- `speedPriority`: How important is low latency? Higher values prefer faster models.
- `intelligencePriority`: How important are advanced capabilities? Higher values prefer
  more capable models.

#### Model Hints

While priorities help select models based on characteristics, `hints` allow servers to
suggest specific models or model families:

- Hints are treated as substrings that can match model names flexibly
- Multiple hints are evaluated in order of preference
- Clients **MAY** map hints to equivalent models from different providers
- Hints are advisory&mdash;clients make final model selection

For example:

```json
{
  "hints": [
    { "name": "claude-3-sonnet" }, // Prefer Sonnet-class models
    { "name": "claude" } // Fall back to any Claude model
  ],
  "costPriority": 0.3, // Cost is less important
  "speedPriority": 0.8, // Speed is very important
  "intelligencePriority": 0.5 // Moderate capability needs
}
```

The client processes these preferences to select an appropriate model from its available
options. For instance, if the client doesn't have access to Claude models but has Gemini,
it might map the sonnet hint to `gemini-1.5-pro` based on similar capabilities.

## Error Handling

Clients **SHOULD** return errors for common failure cases:

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -1,
    "message": "User rejected sampling request"
  }
}
```

## Security Considerations

1. Clients **SHOULD** implement user approval controls
2. Both parties **SHOULD** validate message content
3. Clients **SHOULD** respect model preference hints
4. Clients **SHOULD** implement rate limiting
5. Both parties **MUST** handle sensitive data appropriately

--- END OF FILE draft/client/sampling.mdx ---


--- START OF FILE draft/server/utilities/completion.mdx ---
---
title: Completion
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to offer
argument autocompletion suggestions for prompts and resource URIs. This enables rich,
IDE-like experiences where users receive contextual suggestions while entering argument
values.

## User Interaction Model

Completion in MCP is designed to support interactive user experiences similar to IDE code
completion.

For example, applications may show completion suggestions in a dropdown or popup menu as
users type, with the ability to filter and select from available options.

However, implementations are free to expose completion through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Capabilities

Servers that support completions **MUST** declare the `completions` capability:

```json
{
  "capabilities": {
    "completions": {}
  }
}
```

## Protocol Messages

### Requesting Completions

To get completion suggestions, clients send a `completion/complete` request specifying
what is being completed through a reference type:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "code_review"
    },
    "argument": {
      "name": "language",
      "value": "py"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "completion": {
      "values": ["python", "pytorch", "pyside"],
      "total": 10,
      "hasMore": true
    }
  }
}
```

For prompts or URI templates with multiple arguments, clients should include previous completions in the `context.arguments` object to provide context for subsequent requests.

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "code_review"
    },
    "argument": {
      "name": "framework",
      "value": "fla"
    },
    "context": {
      "arguments": {
        "language": "python"
      }
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "completion": {
      "values": ["flask"],
      "total": 1,
      "hasMore": false
    }
  }
}
```

### Reference Types

The protocol supports two types of completion references:

| Type           | Description                 | Example                                             |
| -------------- | --------------------------- | --------------------------------------------------- |
| `ref/prompt`   | References a prompt by name | `{"type": "ref/prompt", "name": "code_review"}`     |
| `ref/resource` | References a resource URI   | `{"type": "ref/resource", "uri": "file:///{path}"}` |

### Completion Results

Servers return an array of completion values ranked by relevance, with:

- Maximum 100 items per response
- Optional total number of available matches
- Boolean indicating if additional results exist

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client: User types argument
    Client->>Server: completion/complete
    Server-->>Client: Completion suggestions

    Note over Client: User continues typing
    Client->>Server: completion/complete
    Server-->>Client: Refined suggestions
```

## Data Types

### CompleteRequest

- `ref`: A `PromptReference` or `ResourceReference`
- `argument`: Object containing:
  - `name`: Argument name
  - `value`: Current value
- `context`: Object containing:
  - `arguments`: A mapping of already-resolved argument names to their values.

### CompleteResult

- `completion`: Object containing:
  - `values`: Array of suggestions (max 100)
  - `total`: Optional total matches
  - `hasMore`: Additional results flag

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Method not found: `-32601` (Capability not supported)
- Invalid prompt name: `-32602` (Invalid params)
- Missing required arguments: `-32602` (Invalid params)
- Internal errors: `-32603` (Internal error)

## Implementation Considerations

1. Servers **SHOULD**:

   - Return suggestions sorted by relevance
   - Implement fuzzy matching where appropriate
   - Rate limit completion requests
   - Validate all inputs

2. Clients **SHOULD**:
   - Debounce rapid completion requests
   - Cache completion results where appropriate
   - Handle missing or partial results gracefully

## Security

Implementations **MUST**:

- Validate all completion inputs
- Implement appropriate rate limiting
- Control access to sensitive suggestions
- Prevent completion-based information disclosure

--- END OF FILE draft/server/utilities/completion.mdx ---


--- START OF FILE draft/server/utilities/logging.mdx ---
---
title: Logging
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to send
structured log messages to clients. Clients can control logging verbosity by setting
minimum log levels, with servers sending notifications containing severity levels,
optional logger names, and arbitrary JSON-serializable data.

## User Interaction Model

Implementations are free to expose logging through any interface pattern that suits their
needs&mdash;the protocol itself does not mandate any specific user interaction model.

## Capabilities

Servers that emit log message notifications **MUST** declare the `logging` capability:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

## Log Levels

The protocol follows the standard syslog severity levels specified in
[RFC 5424](https://datatracker.ietf.org/doc/html/rfc5424#section-6.2.1):

| Level     | Description                      | Example Use Case           |
| --------- | -------------------------------- | -------------------------- |
| debug     | Detailed debugging information   | Function entry/exit points |
| info      | General informational messages   | Operation progress updates |
| notice    | Normal but significant events    | Configuration changes      |
| warning   | Warning conditions               | Deprecated feature usage   |
| error     | Error conditions                 | Operation failures         |
| critical  | Critical conditions              | System component failures  |
| alert     | Action must be taken immediately | Data corruption detected   |
| emergency | System is unusable               | Complete system failure    |

## Protocol Messages

### Setting Log Level

To configure the minimum log level, clients **MAY** send a `logging/setLevel` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "logging/setLevel",
  "params": {
    "level": "info"
  }
}
```

### Log Message Notifications

Servers send log messages using `notifications/message` notifications:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/message",
  "params": {
    "level": "error",
    "logger": "database",
    "data": {
      "error": "Connection failed",
      "details": {
        "host": "localhost",
        "port": 5432
      }
    }
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Configure Logging
    Client->>Server: logging/setLevel (info)
    Server-->>Client: Empty Result

    Note over Client,Server: Server Activity
    Server--)Client: notifications/message (info)
    Server--)Client: notifications/message (warning)
    Server--)Client: notifications/message (error)

    Note over Client,Server: Level Change
    Client->>Server: logging/setLevel (error)
    Server-->>Client: Empty Result
    Note over Server: Only sends error level<br/>and above
```

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Invalid log level: `-32602` (Invalid params)
- Configuration errors: `-32603` (Internal error)

## Implementation Considerations

1. Servers **SHOULD**:

   - Rate limit log messages
   - Include relevant context in data field
   - Use consistent logger names
   - Remove sensitive information

2. Clients **MAY**:
   - Present log messages in the UI
   - Implement log filtering/search
   - Display severity visually
   - Persist log messages

## Security

1. Log messages **MUST NOT** contain:

   - Credentials or secrets
   - Personal identifying information
   - Internal system details that could aid attacks

2. Implementations **SHOULD**:
   - Rate limit messages
   - Validate all data fields
   - Control log access
   - Monitor for sensitive content

--- END OF FILE draft/server/utilities/logging.mdx ---


--- START OF FILE draft/server/utilities/pagination.mdx ---
---
title: Pagination
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol (MCP) supports paginating list operations that may return
large result sets. Pagination allows servers to yield results in smaller chunks rather
than all at once.

Pagination is especially important when connecting to external services over the
internet, but also useful for local integrations to avoid performance issues with large
data sets.

## Pagination Model

Pagination in MCP uses an opaque cursor-based approach, instead of numbered pages.

- The **cursor** is an opaque string token, representing a position in the result set
- **Page size** is determined by the server, and clients **MUST NOT** assume a fixed page
  size

## Response Format

Pagination starts when the server sends a **response** that includes:

- The current page of results
- An optional `nextCursor` field if more results exist

```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {
    "resources": [...],
    "nextCursor": "eyJwYWdlIjogM30="
  }
}
```

## Request Format

After receiving a cursor, the client can _continue_ paginating by issuing a request
including that cursor:

```json
{
  "jsonrpc": "2.0",
  "method": "resources/list",
  "params": {
    "cursor": "eyJwYWdlIjogMn0="
  }
}
```

## Pagination Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: List Request (no cursor)
    loop Pagination Loop
      Server-->>Client: Page of results + nextCursor
      Client->>Server: List Request (with cursor)
    end
```

## Operations Supporting Pagination

The following MCP operations support pagination:

- `resources/list` - List available resources
- `resources/templates/list` - List resource templates
- `prompts/list` - List available prompts
- `tools/list` - List available tools

## Implementation Guidelines

1. Servers **SHOULD**:

   - Provide stable cursors
   - Handle invalid cursors gracefully

2. Clients **SHOULD**:

   - Treat a missing `nextCursor` as the end of results
   - Support both paginated and non-paginated flows

3. Clients **MUST** treat cursors as opaque tokens:
   - Don't make assumptions about cursor format
   - Don't attempt to parse or modify cursors
   - Don't persist cursors across sessions

## Error Handling

Invalid cursors **SHOULD** result in an error with code -32602 (Invalid params).

--- END OF FILE draft/server/utilities/pagination.mdx ---


--- START OF FILE draft/server/index.mdx ---
---
title: Overview
---

<Info>**Protocol Revision**: draft</Info>

Servers provide the fundamental building blocks for adding context to language models via
MCP. These primitives enable rich interactions between clients, servers, and language
models:

- **Prompts**: Pre-defined templates or instructions that guide language model
  interactions
- **Resources**: Structured data or content that provides additional context to the model
- **Tools**: Executable functions that allow models to perform actions or retrieve
  information

Each primitive can be summarized in the following control hierarchy:

| Primitive | Control                | Description                                        | Example                         |
| --------- | ---------------------- | -------------------------------------------------- | ------------------------------- |
| Prompts   | User-controlled        | Interactive templates invoked by user choice       | Slash commands, menu options    |
| Resources | Application-controlled | Contextual data attached and managed by the client | File contents, git history      |
| Tools     | Model-controlled       | Functions exposed to the LLM to take actions       | API POST requests, file writing |

Explore these key primitives in more detail below:

<CardGroup cols={3}>
  <Card
    title="Prompts"
    icon="message"
    href="/specification/draft/server/prompts"
  />
  <Card
    title="Resources"
    icon="file-lines"
    href="/specification/draft/server/resources"
  />
  <Card title="Tools" icon="wrench" href="/specification/draft/server/tools" />
</CardGroup>

--- END OF FILE draft/server/index.mdx ---


--- START OF FILE draft/server/prompts.mdx ---
---
title: Prompts
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to expose prompt
templates to clients. Prompts allow servers to provide structured messages and
instructions for interacting with language models. Clients can discover available
prompts, retrieve their contents, and provide arguments to customize them.

## User Interaction Model

Prompts are designed to be **user-controlled**, meaning they are exposed from servers to
clients with the intention of the user being able to explicitly select them for use.

Typically, prompts would be triggered through user-initiated commands in the user
interface, which allows users to naturally discover and invoke available prompts.

For example, as slash commands:

![Example of prompt exposed as slash command](/specification/draft/server/slash-command.png)

However, implementors are free to expose prompts through any interface pattern that suits
their needs&mdash;the protocol itself does not mandate any specific user interaction
model.

## Capabilities

Servers that support prompts **MUST** declare the `prompts` capability during
[initialization](/specification/draft/basic/lifecycle#initialization):

```json
{
  "capabilities": {
    "prompts": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the server will emit notifications when the list of
available prompts changes.

## Protocol Messages

### Listing Prompts

To retrieve available prompts, clients send a `prompts/list` request. This operation
supports [pagination](/specification/draft/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "prompts/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "prompts": [
      {
        "name": "code_review",
        "title": "Request Code Review",
        "description": "Asks the LLM to analyze code quality and suggest improvements",
        "arguments": [
          {
            "name": "code",
            "description": "The code to review",
            "required": true
          }
        ]
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Getting a Prompt

To retrieve a specific prompt, clients send a `prompts/get` request. Arguments may be
auto-completed through [the completion API](/specification/draft/server/utilities/completion).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "prompts/get",
  "params": {
    "name": "code_review",
    "arguments": {
      "code": "def hello():\n    print('world')"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "description": "Code review prompt",
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "Please review this Python code:\ndef hello():\n    print('world')"
        }
      }
    ]
  }
}
```

### List Changed Notification

When the list of available prompts changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/prompts/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Discovery
    Client->>Server: prompts/list
    Server-->>Client: List of prompts

    Note over Client,Server: Usage
    Client->>Server: prompts/get
    Server-->>Client: Prompt content

    opt listChanged
      Note over Client,Server: Changes
      Server--)Client: prompts/list_changed
      Client->>Server: prompts/list
      Server-->>Client: Updated prompts
    end
```

## Data Types

### Prompt

A prompt definition includes:

- `name`: Unique identifier for the prompt
- `title`: Optional human-readable name of the prompt for display purposes.
- `description`: Optional human-readable description
- `arguments`: Optional list of arguments for customization

### PromptMessage

Messages in a prompt can contain:

- `role`: Either "user" or "assistant" to indicate the speaker
- `content`: One of the following content types:

#### Text Content

Text content represents plain text messages:

```json
{
  "type": "text",
  "text": "The text content of the message"
}
```

This is the most common content type used for natural language interactions.

#### Image Content

Image content allows including visual information in messages:

```json
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/png"
}
```

The image data **MUST** be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where visual context is important.

#### Audio Content

Audio content allows including audio information in messages:

```json
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

The audio data MUST be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where audio context is important.

#### Embedded Resources

Embedded resources allow referencing server-side resources directly in messages:

```json
{
  "type": "resource",
  "resource": {
    "uri": "resource://example",
    "name": "example",
    "title": "My Example Resource",
    "mimeType": "text/plain",
    "text": "Resource content"
  }
}
```

Resources can contain either text or binary (blob) data and **MUST** include:

- A valid resource URI
- The appropriate MIME type
- Either text content or base64-encoded blob data

Embedded resources enable prompts to seamlessly incorporate server-managed content like
documentation, code samples, or other reference materials directly into the conversation
flow.

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Invalid prompt name: `-32602` (Invalid params)
- Missing required arguments: `-32602` (Invalid params)
- Internal errors: `-32603` (Internal error)

## Implementation Considerations

1. Servers **SHOULD** validate prompt arguments before processing
2. Clients **SHOULD** handle pagination for large prompt lists
3. Both parties **SHOULD** respect capability negotiation

## Security

Implementations **MUST** carefully validate all prompt inputs and outputs to prevent
injection attacks or unauthorized access to resources.

--- END OF FILE draft/server/prompts.mdx ---


--- START OF FILE draft/server/resource-picker.png ---
ï¿½PNG

   
IHDR   ï¿½   ï¿½   ï¿½Ä¶  `iCCPICC Profile  (ï¿½uï¿½;HAï¿½ï¿½h$Dï¿½ï¿½H!Qï¿½*ï¿½ï¿½ï¿½rF,ï¿½ XQï¿½ï¿½Kï¿½ï¿½dï¿½wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6bciï¿½ï¿½BÒ‰ï¿½ï¿½"ï¿½ï¿½B4ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½3ï¿½ ï¿½%ï¿½gï¿½	ium]ï¿½!
?Âšnï¿½ï¿½ï¿½.P	ï¿½ï¿½ï¿½ï¿½ï¿½z7&fÍ¤cRï¿½rp68$oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½~Pï¿½tï¿½mï¿½ï¿½ï¿½;6|Hï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½-ï¿½5kï¿½2Iï¿½{ï¿½^ï¿½rï¿½ï¿½Ä‘lï¿½oï¿½qï¿½ï¿½Ö¿vï¿½ï¿½ï¿½Eï¿½0ï¿½0Rï¿½Ã¤ï¿½ï¿½
ï¿½P ÓŸ"ï¿½?}Jï¿½/ï¿½2ï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½Â¤ï¿½ï¿½Qï¿½ï¿½qDï¿½eLR*ï¿½Þ¿ï¿½ï¿½zGï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%Pï¿½ï¿½×®7z\7Lï¿½ï¿½ï¿½u=uï¿½ï¿½ï¿½[ï¿½@Ï›ã¼Ž ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½qï¿½@ï¿½#Pï¿½|.Laï¿½vY'   beXIfMM *           ï¿½i       &     ï¿½ï¿½       Pï¿½       ï¿½ï¿½       ï¿½    ASCII   Screenshot9UD  =iTXtXML:com.adobe.xmp     <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="XMP Core 6.0.0">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:exif="http://ns.adobe.com/exif/1.0/"
            xmlns:tiff="http://ns.adobe.com/tiff/1.0/">
         <exif:PixelYDimension>181</exif:PixelYDimension>
         <exif:UserComment>Screenshot</exif:UserComment>
         <exif:PixelXDimension>174</exif:PixelXDimension>
         <tiff:Orientation>1</tiff:Orientation>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
oPï¿½=  3HIDATxï¿½}ï¿½Õ‘nMMï¿½fA(ï¿½0BFH"ï¿½dlï¿½ï¿½ï¿½ï¿½omdï¿½ï¿½ï¿½9ï¿½. ï¿½kï¿½g>{ï¿½kï¿½
ï¿½È€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½EAHï¿½ï¿½rï¿½H3ï¿½hï¿½hï¿½ï¿½ï¿½ï¿½ï¿½Ü¾}cï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½V×©:uï¿½Ô©S]}ï¿½oß¢ï¿½ï¿½Sï¿½Qï¿½rï¿½Xï¿½eï¿½ï¿½1ï¿½ï¿½Þ‘ï¿½EDï¿½,ï¿½_ï¿½RQï¿½ ï¿½ï¿½ï¿½Wï¿½Hzdï¿½L,P,N+ï¿½?2ï¿½ï¿½ï¿½ï¿½x"ï¿½ï¿½ï¿½i%ï¿½f
ï¿½ï¿½Pï¿½^]]Mï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Bï¿½wï¿½*%+ï¿½ï¿½fï¿½Lï¿½ï¿½ wï¿½ï¿½i:]}ï¿½Uqï¿½oXOï¿½>ï¿½;ï¿½ï¿½ï¿½[izï¿½4ï¿½ï¿½ï¿½wï¿½ï¿½C@ï¿½ï¿½;ï¿½ï¿½.ï¿½[ï¿½>kï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½hï¿½ï¿½IT\TL}ï¿½iï¿½Õ¯~ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6å—¿ï¿½5=ï¿½ï¿½v9çœ³éš«ï¿½ï¿½;vï¿½ï¿½Iï¿½ï¿½7ï¿½ï¿½-ï¿½ï¿½ï¿½ï¿½6Û cAï¿½ï¿½ï¿½
Zï¿½Nï¿½ï¿½ï¿½kï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½
ï¿½æš«hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~''ï¿½ï¿½UWï¿½Oï¿½sï¿½Rï¿½-iï¿½%ï¿½ï¿½ï¿½!ï¿½ï¿½ï¿½XW\~-ï¿½Åƒï¿½ï¿½~ï¿½ï¿½wï¿½ï¿½ï¿½ï¿½ï¿½|9mÝ¶=ï¿½ï¿½1cï¿½Ò‹/ï¿½H+Vï¿½ï¿½ï¿½ï¿½Ú½ï¿½=ï¿½ï¿½È‘#ï¿½c[L_ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>!ï¿½ï¿½ï¿½]Kç·ï¿½ wÌ˜1ï¿½ï¿½Ö›ï¿½/~ï¿½ï¿½=ï¿½ï¿½@!ï¿½nï¿½ï¿½Îªï¿½*8ï¿½)=Dï¿½ï¿½pÐ›nï¿½ï¿½+ï¿½N#zï¿½
"<ï¿½z.ï¿½.ï¿½ï¿½Wnï¿½5kï¿½Òµ<ï¿½Cï¿½ï¿½uz0nï¿½XZï¿½ï¿½
zsï¿½ï¿½Jï¿½ï¿½Gï¿½ï¿½]D]]ï¿½Bï¿½|,ï¿½ï¿½ï¿½ï¿½ï¿½r
}ï¿½ï¿½Rï¿½?ï¿½ï¿½ï¿½ï¿½N+Jï¿½+.ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4oï¿½\Ú¶mï¿½ï¿½ï¿½ ;wî¤†ï¿½ï¿½ï¿½=Wï¿½ï¿½wï¿½Fwï¿½ï¿½}ï¿½ï¿½ï¿½oï¿½)ï¿½Nï¿½ï¿½oï¿½I<ï¿½ï¿½ï¿½%ï¿½Lï¿½:Eï¿½ï¿½ï¿½H;/ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8pï¿½ï¿½m JFï¿½lï¿½9.ï¿½Ù¹nÎš(^SSMï¿½ï¿½ï¿½ï¿½ï¿½dï¿½-rï¿½WGï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bÖ‘ï¿½Dï¿½_ï¿½ï¿½ujDeÔŸwÞ¹ï¿½Uï¿½ï¿½Aï¿½m`ï¿½ï¿½ï¿½Ó§ï¿½/ï¿½ï¿½ï¿½xï¿½v[ï¿½ï¿½ï¿½aÃ†ï¿½ï¿½ï¿½_Kï¿½ï¿½ï¿½ï¿½yï¿½ï¿½sï¿½Csï¿½Ì¦qï¿½ï¿½qï¿½ï¿½ï¿½z0ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½|{ï¿½ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½	/ï¿½8Ï|/=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½Oï¿½mï¿½1ï¿½Aï¿½ï¿½4oï¿½<qï¿½W^yï¿½ï¿½{ï¿½o4ï¿½ï¿½VUEXTpï¿½9sï¿½ï¿½ï¿½É“%yï¿½ï¿½ï¿½i5/ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½hÏžï¿½4fï¿½hï¿½ï¿½ï¿½ï¿½ï¿½{~(iï¿½ï¿½ï¿½ï¿½yA\ï¿½ï¿½ï¿½ï¿½ï¿½`>nï¿½ï¿½Kï¿½ï¿½3ï¿½R'ï¿½;Ð¥Xï¿½)ï¿½ï¿½cï¿½ï¿½xH"Ú¦+ï¿½~|pz8
"3rTï¿½!ï¿½ï¿½Oï¿½ï¿½)?ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½Aï¿½~ï¿½Cï¿½ï¿½ï¿½|ï¿½
Gï¿½ï¿½ï¿½4ï¿½ï¿½ï¿½ï¿½O[ï¿½DWg-ï¿½?ï¿½>ï¿½ï¿½%tï¿½ï¿½ï¿½"Qï¿½bagjgï¿½ï¿½Gï¿½*ï¿½ï¿½K_ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½}ï½’ï¿½xï¿½
Ú·oï¿½ï¿½!Ò®]ï¿½Vï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½ï¿½~{mÙ²ï¿½^}Mï¿½6Uï¿½Qï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½#nÙºï¿½ï¿½0ï¿½yï¿½fBï¿½EyGd8<ï¿½ï¿½ï¿½_ï¿½	Nï¿½h-|ÌœÙ”ï¿½ï¿½ï¿½&ï¿½eBHï¿½ï¿½ï¿½M%W`Ä†Jï¿½ï¿½d#
ï¿½~ï¿½ï¿½BM/ï¿½ tï¿½uï¿½cï¿½ï¿½hï¿½ï¿½ï¿½Nï¿½o_ï¿½ï¿½:ï¿½`ï¿½ï¿½ï¿½Q>]#ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½-{ï¿½ï¿½ï¿½É·ï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½.à¨¸ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½ï¿½fï¿½ï¿½ß¡/ï¿½k4ï¿½ï¿½sï¿½ï¿½.ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½>"ï¿½|ï¿½ï¿½Iï¿½"ï¿½ï¿½ï¿½Î¦Mï¿½hï¿½"ï¿½*î¸»ï¿½ï¿½JKJï¿½ï¿½HwOï¿½fcï¿½Ä‰tï¿½I'ï¿½%lï¿½ï¿½Å´uï¿½6ï¿½%ï¿½}ï¿½ï¿½ï¿½qMPï¿½ï¿½9Xjaå¸ˆï¿½,ï¿½7Çµï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½:/ï¿½×­[*ï¿½ï¿½Q4Smï¿½ï¿½p|ï¿½ï¿½9ï¿½ï¿½D?É‘cï¿½ï¿½ä°›ï¿½wttï¿½iï¿½ï¿½~ï¿½ï¿½ï¿½i,ç²‹ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½bpÂ¦3ï¿½Zï¿½ï¿½#äŠ½ï¿½ï¿½ï¿½^|ï¿½%zï¿½ï¿½ï¿½ï¿½ï¿½qï¿½xï¿½É¿P
çµ¼-ï¿½Qï¿½ï¿½?ï¿½ï¿½ÚšZzï¿½hï¿½ï¿½ï¿½ï¿½ï¿½>vï¿½ï¿½ï¿½Úµï¿½Qï¿½v^uZÐ‚wWsXdï¿½ï¿½sï¿½ ï¿½%ï¿½ï¿½%+ï¿½ï¿½~FBJï¿½
Nï¿½Mï¿½#kï¿½vï¿½ï¿½ï¿½3ï¿½Å¿ï¿½ï¿½/ï¿½ï¿½nï¿½ï¿½tEï¿½)wï¿½ï¿½Eï¿½ï¿½+n\ï¿½ï¿½?ï¿½ï¿½*++]ï¿½]ï¿½v'ï¿½ï¿½rï¿½gï¿½Rï¿½ï¿½ï¿½ß–S	_ï¿½ï¿½WHï¿½0~ï¿½Iï¿½446ï¿½ï¿½ï¿½ï¿½ï¿½ 4ï¿½iï¿½ï¿½/ï¿½ï¿½Ø¸ï¿½Ë¦ï¿½A]ï¿½a9-ï¿½ï¿½ï¿½ï¿½l ï¿½ï¿½,ï¿½=Fï¿½ï¿½gï¿½u
^8Nï¿½pï¿½dï¿½#"2ï¿½ï¿½ï¿½ï¿½Ô¡ï¿½tà©œï¿½6]ï¿½ï¿½.*ï¿½ï¿½ï¿½Iï¿½Nï¿½Ygï¿½ï¿½N*Ò€3Nï¿½hï¿½ï¿½;ï¿½ï¿½uï¿½2ï¿½Tjï¿½s\ï¿½Oï¿½Û½8mFï¿½ZerRGOw7ï¿½ï¿½ï¿½ï¿½dï¿½@ï¿½fÏžï¿½gï¿½9ï¿½=Â§ï¿½ï¿½è¬³Î’(Ð±ï¿½>ï¿½,ï¿½Ó“O
;ï¿½ï¿½Qï¿½ï¿½ï¿½bï¿½tï¿½xï¿½'jï¿½ï¿½ï¿½ï¿½ï¿½q:ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½yï¿½mhï¿½oWKï¿½ï¿½ï¿½2ï¿½~ï¿½@ï¿½7UQï¿½iï¿½wWï¿½DZï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½	mWï¿½pP@ï¿½ï¿½ï¿½-ï¿½Ö·ï¿½{ï¿½qï¿½%ï¿½Ð±"Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½sï¿½%ï¿½!ï¿½ï¿½ï¿½Uï¿½ptÐµï¿½Ò›ï¿½7ï¿½ï¿½Qï¿½r
>wï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½|ï¿½ï¿½v~9..~&Lï¿½@ï¿½ï¿½=ï¿½ï¿½ï¿½kï¿½ï¿½ï¿½/ï¿½Vï¿½ï¿½|>uï¿½:ï¿½ï¿½ï¿½ï¿½ï¿½g-_Pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½rï¿½fï¿½Fï¿½pnï¿½ï¿½ï¿½ï¿½0oï¿½!Õ¸ï¿½ï¿½2iï¿½Dzooï¿½ï¿½ï¿½H
ï¿½td7ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½Xï¿½Ò….ï¿½?>ï¿½È¯ï¿½ï¿½ï¿½?Bï¿½Gï¿½fï¿½C6lï¿½ï¿½ï¿½z/ï¿½uï¿½8yï¿½ï¿½ï¿½ï¿½@ï¿½nlhï¿½ï¿½ï¿½p.ï¿½ï¿½R:ï¿½Çˆvmï¿½?Ò˜ï¿½ï¿½rï¿½ï¿½wHï¿½{ï¿½<ï¿½Sï¿½ï¿½gï¿½ï¿½}ï¿½fï¿½~8+\vï¿½ï¿½4mï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½Úªï¿½ï¿½ï¿½ï¿½ï¿½PGGxï¿½EMMï¿½tl'MMï¿½%ï¿½ï¿½ï¿½apXï¿½ï¿½Î¾!ï¿½Ó¢wï¿½ï¿½ï¿½ï¿½|	ï¿½tï¿½Sï¿½ï¿½#ï¿½ï¿½ï¿½Mï¿½Lï¿½ï¿½cï¿½ï¿½ï¿½ï¿½Uï¿½ï¿½mï¿½ï¿½ï¿½(ï¿½U:ï¿½ï¿½ï¿½QT"[]ï¿½<Iï¿½ï¿½>ï¿½ï¿½ï¿½$nAbaï¿½p ikï¿½ï¿½,ï¿½ZQQÉ»ï¿½Oï¿½ï¿½#Gï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½o]m$]`ï¿½ï¿½ï¿½ï¿½ï¿½Fï¿½*ï¿½ï¿½ Yï¿½}Vï¿½ï¿½ï¿½qï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½FLï¿½?ï¿½ï¿½}6ï¿½ï¿½%ï¿½Pï¿½Lï¿½ï¿½ï¿½#Yï¿½ï¿½luNï¿½ï¿½ï¿½o#ï¿½)ï¿½ï¿½rï¿½`ï¿½ï¿½ï¿½?~ï¿½ï¿½Q>Rï¿½Äµ@Bï¿½ï¿½ï¿½ï¿½r\lï¿½`ï¿½ï¿½?
ï¿½'ï¿½ï¿½ï¿½ï¿½=9ï¿½ï¿½ï¿½FVï¿½\ï¿½;kï¿½@ï¿½Mfï¿½4rï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½ï¿½ Nï¿½ï¿½ï¿½í‹»sï¿½.ï¿½`Z 7ï¿½8ï¿½ï¿½33ï¿½gqq0*ï¿½ï¿½ï¿½rï¿½Qn.ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½w0g,ï¿½[,Pï¿½h+NÄÇ™Ç¢ï¿½ï¿½?ï¿½xï¿½8ï¿½ï¿½iï¿½Aï¿½iï¿½49.TKï¿½};ï¿½Aï¿½ï¿½r\ï¿½YWoï¿½9ï¿½ï¿½ï¿½ï¿½ì¸©s[?zoï¿½Qï¿½hï¿½ï¿½/ï¿½O8ï¿½E.ï¿½ï¿½<ï¿½ï¿½O'ï¿½ï¿½DZï¿½ï¿½ï¿½cï¿½ï¿½?Åï¿½ï¿½Ñ·ï¿½Dhï¿½W#k6ï¿½0?Nï¿½ï¿½+gï¿½Tï¿½@2ï¿½ï¿½ï¿½ï¿½ï¿½qï¿½rï¿½dï¿½ï¿½&ï¿½=Fï¿½ï¿½ï¿½hKKï¿½\ï¿½ï¿½ï¿½D(dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½}ï¿½ï¿½^?ï¿½ï¿½*++ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½]ï¿½@D^ï¿½ï¿½o^ï¿½ï¿½&mï¿½ï¿½ï¿½NpGï¿½ÏƒÜ§ï¿½Dï¿½ï¿½$ï¿½ï¿½Ç‹ï¿½ä†…ï¿½_ï¿½(ï¿½ï¿½ï¿½ï¿½Tï¿½[Sï¿½~ï¿½ï¿½ï¿½eï¿½xyï¿½ï¿½ï¿½<ï¿½$yBYï¿½ï¿½y\ï¿½7ï¿½ï¿½f!9Dï¿½pï¿½
ï¿½eï¿½ï¿½ï¿½Zï¿½;Wï¿½ï¿½ï¿½>Å®Cï¿½ï¿½V0ï¿½
ï¿½ï¿½Dï¿½ï¿½ï¿½Yï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½B CPï¿½aë»lï¿½ï¿½ï¿½ï¿½d#e";ï¿½ï¿½S(9ï¿½ï¿½>ï¿½aï¿½ï¿½dï¿½ï¿½ï¿½ï¿½`dï¿½ï¿½ï¿½ iï¿½'tï¿½ï¿½iï¿½TtD\ï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½D8ï¿½ï¿½gï¿½ï¿½ï¿½ï¿½Oz;Xï¿½ï¿½ï¿½,ï¿½Nï¿½Qm7!#ï¿½ï¿½ï¿½ï¿½ï¿½qZs!fG\Gï¿½ï¿½ï¿½ï¿½ï¿½ZtEï¿½ï¿½F0SXï¿½ï¿½Ü„C"ï¿½ï¿½ï¿½Aï¿½ï¿½-ï¿½ï¿½ï¿½;ï¿½ï¿½,_ï¿½ï¿½k~Ì«ï¿½4
ï¿½ï¿½Qï¿½-Ç•ï¿½Df$ï¿½ï¿½]Lï¿½Eï¿½ï¿½ï¿½ï¿½ ï¿½Ô¨7%ï¿½7ï¿½Qï¿½ï¿½â¢ Sï¿½uÊ¥x&<Ù´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½LxTï¿½ï¿½ï¿½ï¿½]nï¿½WÌ¥zfï¿½sjctï¿½ï¿½Xï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç¤aAï¿½Xï¿½x|ï¿½Kn
6ï¿½9rï¿½d/7ï¿½>.{B'ï¿½rï¿½?ï¿½ï¿½t	ï¿½Ö|ï¿½
0ï¿½ï¿½.ï¿½C HqÚ«ï¿½ï¿½99'-^ï¿½^e6Ó‚ï¿½xTF&<fï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½MRï¿½,Æ¤2ï¿½ï¿½7ï¿½>ï¿½ï¿½xï¿½ï¿½ï¿½&ï¿½Ñ¹89>DyÅ…b>ï¿½
9ï¿½IWkï¿½?ï¿½ï¿½ï¿½ï¿½JJï¿½0ï¿½Gï¿½L:ï¿½fï¿½/ Q	bï¿½Rï¿½ï¿½ï¿½Mï¿½DlØ 0ï¿½ï¿½ï¿½Rï¿½&ï¿½hï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½Ü›ï¿½ï¿½ï¿½?ï¿½hï¿½ï¿½+'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½æ¸eï¿½ï¿½ï¿½KPbAï¿½JCnBï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½Jï¿½x,ï¿½ï¿½aï¿½09.7:ï¿½ï¿½ï¿½L@ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<!+Tï¿½!'ï¿½ï¿½ï¿½ï¿½ï¿½ar\g|ï¿½8ï¿½@6xï¿½sSï¿½ï¿½9ï¿½~ï¿½|oï¿½ï¿½GWKhï¿½Tï¿½Éµï¿½!#×¾Oï¿½vyï¿½quï¿½`ï¿½xWï¿½Hï¿½.ï¿½Bï¿½ï¿½,Y,:ï¿½0dï¿½Ô¨ï¿½ 0}<2ï¿½ï¿½/ï¿½Hï¿½%ï¿½ï¿½ï¿½+2ï¿½4aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,zï¿½ï¿½JMCFï¿½Nhï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½q3ï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½3Xxï¿½	=ï¿½ï¿½ï¿½ï¿½Í³
ï¿½ï¿½ï¿½Gs7VÑ€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!Ë²3-?Eï¿½ï¿½(=ï¿½ï¿½ï¿½uÅ£ï¿½dï¿½oï¿½9ï¿½ï¿½ï¿½Bï¿½ ï¿½8~ï¿½eï¿½
ï¿½ï¿½H×ŸÎ/ï¿½ÆºÚ¼LJG}:ï¿½dtï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½\ï¿½ï¿½gï¿½Qï¿½-ï¿½oï¿½ï¿½ï¿½gï¿½,N×¯ï¿½{nï¿½B8ï¿½Q$O::ï¿½Oï¿½8_ï¿½}Wï¿½Nï¿½ï¿½ï¿½Ulï¿½ï¿½ï¿½&ï¿½ï¿½Qvï¿½ï¿½gï¿½ï¿½__Bï¿½^r)-ï¿½ï¿½ï¿½ï¿½ï¿½/ï¿½Iï¿½Cï¿½2ï¿½ï¿½3ï¿½Iï¿½GTï¿½ï¿½ï¿½'ï¿½ï¿½Bï¿½yï¿½ï¿½;ï¿½ivXrï¿½ï¿½ï¿½[Lï¿½ï¿½ï¿½gMï¿½E?Ë–-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aGCï¿½ï¿½?ï¿½ï¿½A:ï¿½pï¿½ï¿½Å’ï¿½zï¿½ï¿½Ò¥K%Â£%.ï¿½uN^}ï¿½ï¿½Eï¿½ï¿½ï¿½}\ï¿½ï¿½ï¿½8t1ï¿½ï¿½ï¿½|ï¿½!ï¿½ï¿½ï¿½yï¿½vï¿½9sï¿½ï¿½ï¿½eï¿½ï¿½ï¿½lï¿½Q7ï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½zï¿½QCï¿½ï¿½>ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{6\ï¿½i"L9ï¿½ï¿½ï¿½ï¿½t4ï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ì´œï¿½"ï¿½ ï¿½"Ç½ï¿½ï¿½ï¿½ï¿½ï¿½9?)$Cï¿½Cyï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½y5ï¿½ï¿½ï¿½ièŽ£ï¿½QOZpï¿½ï¿½ï¿½ï¿½EZ8ï¿½uÑ8-ç·ˆï¿½ï¿½ï¿½Dï¿½0ï¿½}Xï¿½Aï¿½	ï¿½ï¿½ï¿½;ï¿½b $Hï¿½ï¿½ï¿½zï¿½ï¿½<ï¿½}9ï¿½;ï¿½ï¿½ï¿½NÎ˜ï¿½ï¿½ï¿½ï¿½Wï¿½5gï¿½Û‘vï¿½ã´ˆï¿½Ïiï»Ÿï¿½sï¿½kï¿½tï¿½ï¿½'ï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½>S\ï¿½ï¿½qï¿½mm>ï¿½}9ï¿½V{['Gï¿½4ß€0}ï¿½-ï¿½fï¿½1ï¿½ÂŽr ï¿½ï¿½JNï¿½M8ï¿½ï¿½Ï‘vï¿½wï¿½ÒªUï¿½ï¿½8#ï¿½ï¿½sï¿½tcJï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½{qmï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½Ç™ï¿½ï¿½ï¿½ï¿½jï¿½#ï¿½#.Jlï¿½6(.aPÂï¿½50 ï¿½ï¿½ï¿½Vï¿½ ï¿½Eï¿½ï¿½ï¿½iï¿½ï¿½ï¿½-ï¿½ï¿½ï¿½qï¿½ï¿½ï¿½ï¿½^cï¿½ï¿½ï¿½ï¿½:"ï¿½ï¿½@ï¿½}\]&ï¿½dMï¿½ï¿½Vhï¿½ï¿½ï¿½ï¿½ï¿½\N0QWï¿½Zï¿½ï¿½nï¿½]ï¿½:iï¿½ï¿½ï¿½KgÈ±KØ¸-ï¿½=ï¿½ï¿½ï¿½ï¿½zï¿½ï¿½mï¿½s`ï¿½ï¿½6vï¿½Wï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Xeï¿½ï¿½OÖ‡ï¿½ï¿½ï¿½J&Cï¿½Qï¿½9nï¿½Xï¿½ï¿½ ï¿½wï¿½ !;>ï¿½rziyï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½È‘ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½&G<Å½ï¿½Kï¿½+ï¿½ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½:ï¿½ï¿½sï¿½ï·¿ï¿½mN~ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6aï¿½ï¿½ï¿½ï¿½+^N	ï¿½ï¿½AEï¿½k/ï¿½+ï¿½ï¿½ï¿½ï¿½EMMï¿½8F!Lï¿½ï¿½ï¿½aMu5ï¿½wï¿½Yï¿½& Ò¢Hf<ï¿½=ï¿½%ï¿½z\Bï¿½ï¿½*ï¿½n`r56ï¿½ï¿½ï¿½)Kw<ru\ÙŽ)ï¿½ï¿½>rï¿½fï¿½ï¿½ï¿½ï¿½Ã€5ï¿½Uï¿½;.Æ…"ï¿½.CIï¿½&ï¿½ï¿½"ï¿½ï¿½qï¿½YCï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½1TQ5ï¿½ï¿½ï¿½oï¿½:ï¿½ï¿½ï¿½<.ï¿½ï¿½.ï¿½|aï¿½an8ì“¯ï¿½Ã¦TN-ï¿½Lï¿½{a0ï¿½ï¿½Vï¿½ï¿½ï¿½Îµï¿½pï¿½$ï¿½8ï¿½HQï¿½ï¿½ï¿½ï¿½Aï¿½Ê²ï¿½Ã–kï¿½ï¿½~ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½Ç•ï¿½Ú¯ï¿½ï¿½`Sï¿½T|Xï¿½0ï¿½ï¿½dï¿½Ê¬+&>ï¿½*ï¿½Bï¿½[u4ï¿½ï¿½gzï¿½ï¿½Ï±ï¿½ï¿½zï¿½yï¿½ï¿½Qï¿½ï¿½ï¿½&N_[ï¿½}Ì¼ï¿½ï¿½kZÉ³ï¿½cP(ï¿½Xï¿½Lï¿½5ï¿½ï¿½ï¿½sï¿½ï¿½<ï¿½ï¿½ï¿½ 
ï¿½ï¿½uï¿½ï¿½Wï¿½Cï¿½ï¿½ï¿½ãkï¿½ï¿½ï¿½8ï¿½ï¿½NNd
B_wï¿½8+ï¿½ qï¿½ï¿½z+ï¿½ï¿½ï¿½$ï¿½"*A,`ï¿½,ï¿½ï¿½ï¿½<ï¿½ÍŒ.ï¿½ï¿½ï¿½'Ó¬@ï¿½ï¿½Nï¿½ï¿½ï¿½@ï¿½8ï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½j:]Dï¿½ï¿½<ï¿½+ï¿½mVï¿½(ï¿½ï¿½6ï¿½(ï¿½xï¿½ï¿½ï¿½f*Wï¿½i_^\ï¿½>ï¿½ï¿½Qï¿½d}{r\g@ï¿½Zï¿½sï¿½4Pq/Lï¿½Kï¿½ï¿½ï¿½Uï¿½Aï¿½W"ï¿½ï¿½Þš0qï¿½65ï¿½ï¿½Oï¿½]Ï‰3B|ï¿½b1ï¿½ï¿½H)1'1r
ï¿½Pï¿½xï¿½ï¿½*ï¿½ï¿½Imï¿½ï¿½%ï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½jxï¿½iï¿½*ï¿½ï¿½mkï¿½ï¿½sfï¿½*U%wï¿½ï¿½APï¿½ï¿½ï¿½ï¿½ï¿½Ag-ï¿½$ï¿½éŽ¡ï¿½ï¿½;V>?ï¿½Jï¿½ï¿½ ï¿½Wl~ï¿½m\ï¿½ï¿½ï¿½ï¿½Ü¯ï¿½ï¿½ï¿½Û¸ê±—8J&<ï¿½3ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç“ï¿½7ï¿½ï¿½
cï¿½aï¿½ï¿½.Í˜	ax6ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*ï¿½pï¿½>ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½ypï¿½ï¿½t2ï¿½ï¿½3ï¿½#Sï¿½X&ï¿½ï¿½v2iï¿½ï¿½ ï¿½
Cï¿½Ä²Lï¿½ï¿½1ï¿½x)ï¿½x&|ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½,ï¿½ï¿½
Û™Vï¿½qï¿½ï¿½ï¿½vï¿½n.ï¿½ï¿½v C!X ï¿½ï¿½qÓ*vNï¿½ï¿½lï¿½ï¿½VQmï¿½Y@ï¿½ï¿½E|5ï¿½ï¿½ï¿½ ï¿½ï¿½zï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç•ï¿½Vï¿½+É½ï¿½hï¿½ï¿½ï¿½K{ï¿½ï¿½ï¿½;U%bï¿½ï¿½#ï¿½7ï¿½ï¿½ï¿½ï¿½jï¿½jï¿½ï¿½jï¿½WTpï¿½ï¿½Gï¿½R?.ï¿½ï¿½ï¿½Imï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½3^nWï¿½ï¿½n,ï¿½ï¿½Ð°ï¿½gï¿½D\ï¿½}C9#qx
ï¿½ï¿½mï¿½
ï¿½13ï¿½ï¿½ï¿½@#Fï¿½Sooï¿½ï¿½wRwOï¿½ï¿½ï¿½rc"<ï¿½[^VFUÃªï¿½ï¿½!ï¿½ï¿½ï¿½Ctï¿½ï¿½ï¿½ï¿½Xfï¿½Å—e ï¿½ï¿½Ð¡kï¿½ÐŸÇ­ï¿½ï¿½ï¿½ï¿½ï¿½r;v4ï¿½tjï¿½8ï¿½:+ï¿½5iï¿½ï¿½%ï¿½Å´gï¿½>vîž¤|ï¿½ï¿½ï¿½@ï¿½ï¿½9ï¿½Ï’5[N+ï¿½+hï¿½ï¿½qtï¿½ï¿½ï¿½ï¿½ï¿½a7Â¦3ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½,#ï¿½~#~ï¿½zï¿½ï¿½Kï¿½ï¿½ï¿½|ï¿½Ï¡ï¿½ï¿½ ï¿½ï¿½ï¿½qï¿½ï¿½8lï¿½KW\ï¿½ï¿½ï¿½ï¿½c8ï¿½vwï¿½1Û‚6h;vï¿½(G#[ï¿½ï¿½Pkï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½=Lï¿½ï¿½Sï¿½Ãšï¿½ï¿½ï¿½Yï¿½uï¿½Aï¿½@ï¿½]ï¿½8ï¿½ï¿½ï¿½ï¿½Ñœï¿½Vï¿½ï¿½yGï¿½ï¿½ï¿½ï¿½Wr^!ï¿½ï¿½ï¿½mï¿½hcXï¿½={ï¿½ï¿½<.bï¿½ï¿½=ï¿½5ï¿½ï¿½ï¿½-ï¿½ï¿½Ø¾}|ï¿½ï¿½ï¿½Bï¿½ZZZï¿½Ý†ï¿½Bï¿½ï¿½myVA#nï¿½ï¿½ï¿½g>sï¿½ï¿½"nï¿½
ï¿½ï¿½jï¿½ï¿½ï¿½+ï¿½ï¿½5ï¿½^ï¿½Úµ{/ï¿½xï¿½ï¿½8ï¿½ï¿½sÎ¤ï¿½Æï¿½G{"ï¿½sØ‰ï¿½ï¿½Vï¿½mï¿½ï¿½ï¿½oï¿½Yqï¿½dï¿½ï¿½bvï¿½Lï¿½*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½7ï¿½Cï¿½5"rï¿½ï¿½
ï¿½ï¿½ï¿½pÚ¹gï¿½ï¿½:/ï¿½u+^]ï¿½Ó‚d7bÑ¢ï¿½ï¿½m7ï¿½ï¿½Gï¿½ï¿½Y@ï¿½ï¿½ï¿½ï¿½Sï¿½ï¿½~p7ï¿½Í£ÎŸw^(zï¿½ï¿½QCï¿½ï¿½eï¿½ï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½V(ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½6ï¿½2ï¿½Yï¿½uZï¿½ï¿½ï¿½[ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,, ï¿½ï¿½ï¿½ï—”ï¿½ï¿½ï¿½gS1ï¿½ï¿½=?ï¿½Û‘`ï¿½ï¿½gï¿½?zï¿½9nï¿½ï¿½ï¿½,ï¿½#ï¿½jï¿½VÔï¿½iï¿½ï¿½o ï¿½ï¿½%xï¿½ï¿½'ï¿½Dï¿½ï¿½ï¿½ï¿½___o3ï¿½Ó¿ï¿½|3Nï¿½tï¿½=ï¿½g3pï¿½Xï¿½/ï¿½ï¿½"ï¿½ï¿½ï¿½@ï¿½ï¿½s\^ï¿½ï¿½ï¿½d1ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½yï¿½9n
ï¿½ï¿½-7ï¿½_Þ£Î‹ï¿½ï¿½n~ï¿½Lw#ï¿½ï¿½y.ï¿½ZQï¿½ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Muï¿½9ï¿½y=lï¿½ï¿½5bDï¿½ï¿½`8.ï¿½Gï¿½8/G^L(ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½nï¿½ï¿½ï¿½%ï¿½ï¿½ï¿½ï¿½,ï¿½ 8hï¿½+ï¿½ï¿½Gï¿½9ï¿½ï¿½ï¿½t'ï¿½Mk;ï¿½ï¿½ï¿½r^<ï¿½0eï¿½ï¿½usï¿½ ï¿½Ö¯x#ï¿½'<xï¿½ï¿½o~Mï¿½ï¿½ï¿½Bw#.ï¿½Õ‰ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½g"ï¿½Fï¿½ï¿½ï¿½kï¿½ï¿½:ßˆï¿½-/ï¿½ï¿½Nï¿½Ç %+gï¿½uN2RTï¿½ï¿½ï¿½Tï¿½nï¿½ï¿½ï¿½8ç½›ï¿½#/ï¿½ï¿½ï¿½ï¿½?6ï¿½3xï¿½ï¿½Jï¿½ï¿½qï¿½0ï¿½jVï¿½F^Å½Ð—ï¿½M5ï¿½*lEï¿½ï¿½ï¿½ÚŽï¿½ï¿½Q
ï¿½ï¿½wï¿½Vï¿½ï¿½Î«ï¿½
kï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½ï¿½<Xï¿½Dï¿½[0É’6ï¿½G^3Ï©ï¿½ß¨ï¿½ï¿½^?Iï¿½^ï¿½ï¿½ï¿½qï¿½ï¿½B\Nï¿½ï¿½+ï¿½
ï¿½gï¿½ï¿½#ï¿½j9xï¿½ï¿½ï¿½y?7`ï¿½ï¿½bï¿½ï¿½
T[[PRï¿½<hï¿½ï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½ï¿½uï¿½Mkï¿½ï¿½ï¿½ï¿½9Pï¿½ï¿½	ï¿½ï¿½ï¿½ï¿½q|ï¿½ï¿½}gï¿½6zyyiï¿½ï¿½ï¿½ï¿½ï¿½sR!]@Xï¿½R:;;ï¿½nWYi)ï¿½ï¿½ï¿½ï¿½n
%ï¿½O8-ï¿½ï¿½xï¿½m_Î¼QÄ™ï¿½Hï¿½ï¿½ï¿½ï¿½apRï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wÅŠï¿½ï¿½ï¿½Ï¿iï¿½ï¿½9ï¿½ï¿½|Aï¿½Fq\,ï¿½ï¿½ï¿½ERWWï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ð‹ï¿½ï¿½ï¿½
ï¿½TR\ï¿½ï¿½ï¿½ï¿½i'L<ï¿½ï¿½ï¿½Û©ï¿½~8Kï¿½JPdï¿½ï¿½Gï¿½wï¿½ï¿½?ï¿½O/ï¿½ï¿½ï¿½ï¿½3ï¿½RÍ·wï¿½sï¿½%ï¿½"ï¿½ï¿½ï¿½b`ï¿½ï¿½y#9ÂŸï¿½9ï¿½Ã‘2tï¿½ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½Wï¿½Ïš5Kï¿½vÂ„ï¿½ï¿½ï¿½ï¿½3ï¿½ï¿½q\3ï¿½ï¿½ï¿½ï¿½Gï¿½+^ï¿½ï¿½á¼™Î¿ï¿½ï¿½ï¿½?ï¿½ï¿½Ãï¿½ï¿½Tqï¿½p<ï¿½xï¿½ï¿½aï¿½Ó9Bï¿½ï¿½ï¿½ï¿½(ï¿½fï¿½xï¿½ï¿½ï¿½ï¿½#ï¿½Dï¿½Vï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½ï¿½"/;ï¿½D\xnï¿½ï¿½_ï¿½ï¿½ï¿½2ÇŽNï¿½uÂ¹8ï¿½|ï¿½F}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½DNï¿½iVï¿½\ï¿½>-ï¿½ï¿½ï¿½{]ï¿½Ê§ï¿½ï¿½pï¿½=ï¿½3je9ï¿½ï¿½Oï¿½Qï¿½ï¿½ï¿½ï¿½>ï¿½Yï¿½ï¿½ï¿½qï¿½ï¿½qï¿½1ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½7ï¿½Gï¿½ï¿½ï¿½nï¿½yï¿½]wGÍˆAï¿½Ãœï¿½qï¿½Wï¿½Ë¼oï¿½mï¿½ï¿½ï¿½ï¿½C~ï¿½ï¿½wï¿½SÏ¿8ï¿½o;ï¿½Jwï¿½qU9KYq<OEWï¿½ï¿½PÕŠï¿½ï¿½Z@ï¿½;ï¿½ï¿½Oï¿½ï¿½gï¿½gï¿½ï¿½?ï¿½#ï¿½\ï¿½ï¿½ï¿½O{ï¿½Î™ï¿½nï¿½ï¿½ï¿½(Wzï¿½ï¿½OJ7ï¿½Fï¿½Cï¿½pï¿½RÞ¢ï¿½ve/oSb{ï¿½ï¿½{#2pD\\ï¿½`gï¿½ï¿½ï¿½Wï¿½Cï¿½qÍ¾4ï¿½21ï¿½ï¿½LÂ‘ï¿½-ï¿½Gï¿½JkuFuï¿½
~!ï¿½j;ï¿½ï¿½ ï¿½-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'ï¿½7ï¿½ï¿½6YNï¿½ï¿½
Mï¿½ï¿½ï¿½ï¿½vï¿½ceï¿½ï¿½4+(^hKHEï¿½ï¿½ï¿½Ç€Z Nï¿½ï¿½ï¿½ï¿½fï¿½hï¿½?D^Lï¿½wï¿½ï¿½tï¿½ï¿½ï¿½ï¿½<ï¿½`ï¿½dï¿½ï¿½ï¿½$#3ï¿½iiVï¿½i[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½N
ï¿½Q=ï¿½s\ï¿½=Öˆï¿½ï¿½;8(ï¿½F\ãœˆï¿½ï¿½ï¿½P#ï¿½ï¿½^ï¿½HWï¿½Ô•ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½gu:ï¿½Gï¿½:ï¿½ï¿½=Vï¿½lï¿½;Sï¿½<ï¿½ï¿½ï¿½mVï¿½ Wï¿½kï¿½8`ï¿½rï¿½S-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½qï¿½GÜ“ï¿½"ï¿½ï¿½+IO9ï¿½ï¿½jï¿½Md;ß™ï¿½;ï¿½ï¿½ï¿½ï¿½QqRï¿½rï¿½ï¿½ÚŠï¿½"-w\ï¿½ECï¿½ï¿½6ï¿½xï¿½ï¿½r\ï¿½lï¿½ï¿½IqIï¿½%(>dg,R\,tï¿½ï¿½ï¿½yTFwï¿½ï¿½ï¿½ <ï¿½ï¿½!mï¿½8ï¿½ï¿½\ï¿½?ï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½69á¬¤ï¿½ur['ï¿½ï¿½Hï¿½,ï¿½ï¿½7ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½qï¿½ï¿½ï¿½?Iï¿½ï¿½s\ï¿½,.r5ï¿½ï¿½ï¿½k0:ï¿½Eeï¿½Z ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ç¸ºï¿½ï¿½F\'vï¿½ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½=ï¿½ï¿½;o'ï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½&ï¿½ï¿½gï¿½ï¿½ï¿½}s\^'ï¿½Zï¿½yaJï¿½Quæ ´ï¿½<ï¿½eï¿½ï¿½ï¿½-ï¿½g;ß™ï¿½{r\dï¿½ï¿½Eq/T.o=:EQï¿½ï¿½9ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½:2MQï¿½jF3ahÌ›ï¿½ï¿½1ï¿½ï¿½;ï¿½*8Î NaC5ï¿½cï¿½+ï¿½GGï¿½ÒƒBï¿½Bï¿½vï¿½pï¿½ï¿½mï¿½ï¿½ï¿½}bï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½cSuï¿½@×¥* ru:oï¿½ï¿½ï¿½;g~Lï¿½Sï¿½ï¿½ï¿½ï¿½Z7ï¿½ï¿½ï¿½qï¿½ï¿½Cï¿½ï¿½?ï¿½ ï¿½
ï¿½Å¸ï¿½ï¿½ï¿½8ï¿½ ï¿½ï¿½ï¿½ï¿½×Ÿï¿½ï¿½>ï¿½zï¿½ï¿½MCB_qÔï¿½+ï¿½ï¿½$ï¿½ï¿½4ï¿½5ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½Qï¿½ï¿½H<ï¿½ï¿½Kï¿½T&iï¿½ï¿½ï¿½:ï¿½B
ï¿½ï¿½;CV3ï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½w>\ï¿½<==Ö€;uï¿½xï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½;ï¿½QGWï¿½wï¿½ZÚºiË®6ï¿½ï¿½ï¿½~ï¿½jHvï¿½kï¿½ï¿½fï¿½ï¿½wï¿½^ï¿½ï¿½7-xï¿½Qgwuï¿½ï¿½ï¿½|<ï¿½ï¿½/ï¿½ï¿½<ï¿½ï¿½GÚï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½stï¿½Sï¿½Oï¿½qï¿½ï¿½x4ï¿½ï¿½ï¿½ï¿½ï¿½Ï¡1ï¿½É.ï¿½ï¿½Thï¿½ï¿½ï¿½ï¿½Apå‡¾ï¿½ï¿½ï¿½ï¿½ï¿½VÓºï¿½ï¿½,ï¿½e~ï¿½Eï¿½ï¿½-9ï¿½Úï¿½ï¿½?{ï¿½ï¿½_ï¿½ï¿½ï¿½'ï¿½V&ï¿½W.ï¿½(8>^Yï¿½L?|x
:ï¿½C#ï¿½Wï¿½ï¿½[Ï£)'ï¿½S[g}ï¿½gï¿½Ñ³ï¿½ï¿½ÞŠï¿½ï¿½ï¿½ï¿½x}ð²©´|ï¿½ï¿½ï¿½ï¿½^ï¿½ï¿½tï¿½ï¿½ï¿½|ï¿½ï¿½ï¿½#W6ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½ï¿½^ï¿½0ï¿½ï¿½e!ï¿½zRï¿½ï¿½vï¿½nï¿½ï¿½
Úºï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Dï¿½fï¿½+ï¿½1ï¿½ï¿½/_ï¿½6HÞ’ï¿½ï¿½{ï¿½
ï¿½w"ï¿½ï¿½ï¿½&ÆšOï¿½
q3ï¿½ï¿½vfWï¿½
&	]ze
ï¿½ï¿½ï¿½Ñ‹ï¿½ï¿½xï¿½{ï¿½ï¿½ï¿½}pï¿½ï¿½ï¿½ï¿½.ï¿½?ï¿½>{ï¿½ï¿½3}$;qï¿½^ï¿½ï¿½ï¿½ï¿½â´¥%ï¿½ï¿½`ï¿½Cï¿½ï¿½ï¿½ï¿½kï¿½yï¿½aw4~i;Õ³ï¿½ï¿½[ï¿½ï¿½ï¿½?ï¿½#zï¿½ï¿½ï¿½ï¿½gï¿½Eï¿½`ï¿½ï¿½dï¿½ï¿½?ï¿½@^{ï¿½Yï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½+ï¿½k1Eï¿½ï¿½`'=ï¿½ï¿½&^ï¿½Eï¿½ï¿½ï¿½,N;wï¿½hï¿½ï¿½ï¿½ï¿½ï¿½VÓ½ï¿½YK+ï¿½5}0ì§±ï¿½5ï¿½d1ï¿½ï¿½$:ï¿½ï¿½Wï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½-ï¿½+WQï¿½Oï¿½ÅŠï¿½`ï¿½ï¿½}ï¿½)|Í¦ï¿½8ï¿½ï¿½ï¿½ï¿½h2ï¿½=sUUï¿½Ñ¿ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½5ï¿½ï¿½0GÖ²2^Qï¿½jï¿½\0ï¿½>ï¿½x=ï¿½ï¿½Vï¿½ï¿½ï¿½_ï¿½g^ï¿½Eï¿½ï¿½ï¿½lï¿½ï¿½KÛ¤ï¿½ï¿½ï¿½
ÇŸï¿½Qsï¿½ï¿½fzbï¿½6ï¿½ï¿½qBï¿½ï¿½?xï¿½ï¿½T_SFï¿½-ï¿½ï¿½8ï¿½'ï¿½Wï¿½ï¿½lï¿½ï¿½ß¶qï¿½~ï¿½ï¿½zuï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½zsï¿½Aï¿½ï¿½oï¿½<ï¿½ï¿½Ó—Ã´zï¿½ï¿½=ï¿½qPì‡ˆï¿½y	2ï¿½0cï¿½ï¿½ï¿½rï¿½ï¿½pï¿½k(ï¿½JWï¿½eï¿½Gï¿½Ö‰ï¿½ï¿½ï¿½ï¿½ï¿½DUfvSï¿½dß ~/ï¿½:ï¿½zï¿½Ëžï¿½ï¿½fï¿½wï¿½_I;ï¿½!D0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4v>Dï¿½ï¿½ï¿½ï¿½NKï¿½ï¿½ï¿½]ï¿½Ìœ2\ï¿½oï¿½d^È‡ï¿½vï¿½ï¿½.7ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Î†ï¿½ï¿½4ï¿½Fï¿½ï¿½ï¿½ï¿½`ï¿½Oï¿½ï¿½ï¿½uï¿½4}Bï¿½È›zï¿½yï¿½*roï¿½ï¿½?ï¿½[IXï¿½Uï¿½ï¿½|ï¿½iï¿½1äºƒe?ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Uï¿½;^jï¿½å®Bï¿½ï¿½K8+Ñ¶ï¿½ï¿½zMï¿½sï¿½6ï¿½ï¿½ï¿½_&9ï¿½mï¿½ï¿½ï¿½'6ï¿½)yï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½ï¿½Zï¿½a?]:b<=ï¿½ï¿½nj=ï¿½-N=ï¿½xï¿½o_H5ï¿½ï¿½Wï¿½9ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|Ñ‡2ï¿½|ï¿½ï¿½&
ï¿½oAtï¿½ï¿½ï¿½ï¿½ï¿½ï¿½N|ï¿½Dï¿½ï¸„&ï¿½ï¿½ï¿½/ï¿½ï¿½èƒ‹ï¿½ï¿½ï¿½ï¿½ï¿½3ï¿½ï¿½_ï¿½ï¿½ï¿½0ï¿½[ï¿½ï¿½Lï¿½ï¿½ï¿½\pcitï¿½ï¿½ï¿½ ï¿½ï¿½F>1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½g>ï¿½rï¿½3gï¿½tï¿½,ï¿½rï¿½Â‰ï¿½è³›ï¿½?yï¿½~ï¿½ï¿½zï¿½Ä»ï¿½=ï¿½ï¿½ÞŠn6ï¿½ï¿½l ï¿½ï¿½ï¿½ï¿½ÎŸDï¿½<ï¿½ï¿½ï¿½ï¿½ï¿½iGï¿½ï¿½ï¿½ï¿½/ï¿½ï¿½Ç¯>ï¿½f8ï¿½"ï¿½ï¿½L&ï¿½8ï¿½]{ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½w$~aï¿½^ï¿½ï¿½=ï¿½(ï¿½ï¿½ï¿½ï¿½b/U"6?ï¿½Qï¿½ï¿½!ï¿½ÅºPï¿½7+.Wï¿½ï¿½Ø±ï¿½"
'ï¿½ï¿½p0 ï¿½Wo:ï¿½ï¿½}ï¿½kreï¿½ï¿½{ï¿½sgï¿½ï¿½]ï¿½@ï¿½:ï¿½{ï¿½//ï¿½ï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½ï¿½W3ï¿½ï¿½"3ï¿½ï¿½4Swï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/+vï¿½ï¿½ï¿½ï¿½Mï¿½ï¿½ï¿½4zeï¿½q:ï¿½ï¿½h)ï¿½M.ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½8ï¿½ï¿½Bï¿½Fï¿½ï¿½ï¿½?ï¿½dï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½l?ï¿½iï¿½ï¿½
ï¿½ï¿½ï¿½Fï¿½ï¿½+nï¿½.?uzï¿½Pï¿½ï¿½ZÉ¹ï¿½_ï¿½ï¿½a:cï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½G:ï¿½ÒCï¿½PWEï¿½Uï¿½ï¿½Kï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½}4zDï¿½DHIJ-z*ï¿½~ï¿½ï¿½ï¿½ï¿½Ó¨ï¿½Õœ&ï¿½Bï¿½ï¿½ï¿½rï¿½ï¿½Fï¿½ï¿½ï¿½Y9ï¿½ï¿½\ï¿½ï¿½
\ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½Aï¿½$ï¿½ï¿½Jï¿½ï¿½}ï¿½;[ï¿½ï¿½ï¿½ï¿½CMmï¿½cï¿½qDï¿½ï¿½ÙŠï¿½bï¿½-ï¿½Ç«*ï¿½y'ï¿½Fï¿½ï¿½ï¿½{ï¿½ï¿½Fï¿½ï¿½Mtï¿½F?ï¿½ï¿½eLCï¿½ï¿½0ï¿½ï¿½ï¿½%ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½Hï¿½ï¿½~ï¿½Y&ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½r\6]vï¿½]ï¿½Zï¿½ï¿½XIJï¿½ï¿½$0çˆ£wï¿½VsQ1ï¿½cs ï¿½ï¿½=ï¿½Vï¿½ï¿½Xï¿½ï¿½ï¿½r\ï¿½$r(ï¿½ï¿½[iï¿½t6Xcï¿½Bï¿½ï¿½ï¿½Wï¿½
ï¿½ï¿½WKXï¿½ï¿½8ï¿½ï¿½ï¿½'ï¿½ï¿½lLï¿½ï¿½
ï¿½ï¿½'Â†ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½
ï¿½ï¿½ï¿½ï¿½x"'Kxï¿½ï¿½PMRHï¿½ï¿½ï¿½Mï¿½ï¿½=ï¿½ï¿½GO5#Iï¿½o .ï¿½ï¿½ï¿½/l{ï¿½ï¿½
1y	9ï¿½BYï¿½Åµ]}Kï¿½ï¿½ï¿½Â±q0ï¿½ï¿½Q
ï¿½>q'Jgï¿½ï¿½ï¿½ï¿½qCï¿½Pï¿½0ï¿½Øˆï¿½ï¿½2ï¿½~ï¿½ï¿½Zï¿½Ü¨ï¿½ï¿½F6ï¿½xï¿½â¹©ï¿½ï¿½ï¿½ï¿½Yï¿½pï¿½ï¿½ï¿½ï¿½jï¿½^ï¿½ZÅœï¿½lhn+y/ï¿½'(ï¿½ï¿½ï¿½ï¿½,qï¿½1ï¿½ÛŸï¿½n,Yï¿½ï¿½pï¿½|ï¿½ï¿½iO:ï¿½ï¿½ï¿½×žï¿½ï¿½ï¿½Bï¿½ï¿½H?ï¿½ï¿½".`ï¿½Sï¿½ï¿½Cï¿½+	ï¿½,ï¿½ï¿½+ï¿½ï¿½>ï¿½dï¿½ï¿½Hï¿½k
9fxBï¿½ï¿½Oï¿½7ï¿½>.k):ï¿½ÞŸï¿½ï¿½f*.(ï¿½ï¿½Y-ï¿½ï¿½ï¿½;ï¿½ï¿½Cï¿½ï¿½{ï¿½ï¿½ï¿½VB"Nbï¿½uï¿½ï¿½!]ï¿½ï¿½`ï¿½Ã….,
ï¿½jï¿½Gp(Ùï¿½
3hï¿½Qï¿½3<ï¿½qï¿½ï¿½ï¿½Y*ï¿½ï¿½aï¿½Iï¿½ï¿½-sï¿½ï¿½qï¿½3ï¿½ï¿½aï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½Cï¿½EWï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½/vï¿½ï¿½ï¿½ï¿½N`QrÂ€Pï¿½ï¿½ï¿½ï¿½ï¿½820ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½l{
ï¿½}xï¿½dï¿½Bï¿½ï¿½e|@ï¿½yr\ï¿½spFï¿½rï¿½ï¿½toÄï¿½<ï¿½ï¿½
ï¿½ï¿½jaï¿½/ï¿½Ð—nx`Dw&ï¿½crï¿½ï¿½ï¿½ï¿½Eï¿½U6ï¿½ï¿½ï¿½ï¿½ï¿½r\ï¿½4gï¿½ ï¿½Eï¿½ï¿½Å…b>ï¿½Nqï¿½ËŠï¿½cï¿½"ï¿½ï¿½Rï¿½qï¿½ï¿½uï¿½ï¿½ï¿½3ï¿½ï¿½\ï¿½_ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½Nï¿½9ï¿½nÄ…sï¿½%Muaï¿½ï¿½rLï¿½ï¿½ï¿½"Ý‡7ï¿½aï¿½mï¿½ï¿½*Bï¿½ï¿½ï¿½$ë²¢ï¿½
Y
ï¿½4ï¿½Wï¿½vï¿½ï¿½Aï¿½<ï¿½2Oï¿½ï¿½ebÂ»ï¿½ï¿½9ï¿½Ü[ï¿½{Pï¿½ï¿½dWï¿½ï¿½ Uï¿½ï¿½ï¿½Mï¿½Iï¿½/ï¿½ï¿½>Tï¿½gf$6>ï¿½]ï¿½ï¿½Oï¿½Þ“ï¿½cï¿½ï¿½ï¿½ï¿½sï¿½pï¿½ï¿½sï¿½hï¿½nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6ï¿½Ñ¾ï¿½ï¿½ï¿½ï¿½ï¿½y5Rï¿½dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½oï¿½)ï¿½ï¿½r*-ï¿½ï¿½ï¿½ï¿½Rï¿½ï¿½ï¿½1^q2ï¿½'ï¿½ï¿½ï¿½[h~`ï¿½fï¿½Qï¿½9.\ï¿½%ï¿½ï¿½0ï¿½ï¿½2Ç¡ï¿½ï¿½Ø¡ 1ï¿½^vï¿½ï¿½#ï¿½ï¿½ï¿½Fï¿½ï¿½TRZBï¿½ï¿½m`*ï¿½W*ï¿½,Ç¨ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½N\Fï¿½U5ï¿½Wï¿½ï¿½[ï¿½Caï¿½ï¿½ï¿½gï¿½~ï¿½ï¿½ï¿½ï¿½sï¿½|ï¿½45ï¿½ï¿½ï¿½BÃï¿½çºº:ï¿½Pï¿½~~cï¿½ï¿½ï¿½Ruu
ï¿½ï¿½ï¿½qDMWï¿½ï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½!ï¿½_:ï¿½ï¿½J=ï¿½T];ï¿½eï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½Þ™ï¿½XNï¿½
ï¿½ï¿½qï¿½ï¿½].ï¿½9[ï¿½ï¿½ï¿½ï¿½Î¸ï¿½ï¿½hï¿½ï¿½ï¿½pï¿½ï¿½QLï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½i[ì¥ºï¿½j1ï¿½ï¿½ï¿½ï¿½ï¿½Vï¿½ï¿½&ï¿½ï¿½rï¿½ï¿½ï¿½ï¿½nï¿½ï¿½Ê¨ï¿½ï¿½ ï¿½Û³ï¿½Fï¿½Oeâ¼…1ï¿½Ø¨ï¿½ï¿½yCï¿½
0ï¿½ï¿½#Yï¿½ï¿½ï¿½9ï¿½ï¿½0	fï¿½ÅŽï¿½ï¿½ï¿½8ï¿½Mcï¿½Zh8Vfoo'ï¿½4ï¿½ï¿½ï¿½ï¿½ï¿½Ð¨Qchï¿½ï¿½1ï¿½ï¿½ï¿½Cï¿½[[WÇ²FÓ°ï¿½rÚ·{;Gaï¿½Fï¿½Bï¿½ï¿½>p:Prï¿½ï¿½Tï¿½Ýˆï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½\qï¿½(;Äªï¿½ï¿½ï¿½2ï¿½ï¿½ï¿½&ï¿½PHï¿½Qvï¿½ï¿½{wSÍ°a4rï¿½(ï¿½ï¿½ï¿½ï¿½yn<ï¿½4ï¿½ï¿½ï¿½Fï¿½ï¿½]ï¿½wQgGï¿½
ï¿½nï¿½Iï¿½'4?Hï¿½_\ï¿½+ï¿½lï¿½Eï¿½3ï¿½ï¿½ï¿½ï¿½JIï¿½,ï¿½ï¿½Ý¬hï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½*xï¿½Aï¿½ï¿½ï¿½Cï¿½|ï¿½-ï¿½Ó»;ï¿½ï¿½loo/ß²ï¿½WHï¿½ï¿½xî¢˜**Lï¿½
zG{;ï¿½3ï¿½u.'ï¿½ï¿½ï¿½DcC#mß¹ï¿½yï¿½=cï¿½?ï¿½9ï¿½ï¿½'ï¿½3Oï¿½Ì¹ï¿½	ï¿½ï¿½ï¿½ï¿½bHï¿½Hï¿½+ï¿½ï¿½Î¥ï¿½ï¿½ï¿½ZKï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½KK=5ï¿½ï¿½ï¿½8PQï¿½} ï¿½ï¿½|Aï¿½sï¿½Vj^Gï¿½ï¿½ï¿½dÐŽzï¿½ï¿½ï¿½ï¿½ï¿½c;^ï¿½+xfï¿½ï¿½1ï¿½ï¿½/ï¿½ï¿½ï¿½~ï¿½6lï¿½@---TSSM3fï¿½Fgï¿½9ï¿½,Nï¿½	ï¿½ï¿½ï¿½jï¿½dï¿½ï¿½ï¿½nï¿½ï¿½a^ï¿½WEï¿½=ï¿½ ï¿½0ï¿½ï¿½1~ï¿½uï¿½ï¿½ï¿½3ï¿½ï¿½=ï¿½ï¿½<B7ï¿½ï¿½ ï¿½ï¿½+ï¿½ï¿½kÄ•ï¿½ï¿½sï¿½ï¿½eRzï¿½ï¿½}rï¿½ï¿½ï¿½ï¿½Dï¿½Eï¿½Aï¿½5ï¿½
ï¿½KGï¿½ï¿½ï¿½ï¿½ï¿½Bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½[iï¿½[oï¿½ï¿½ï¿½ï¿½fjhlï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Aï¿½gÍ¢ï¿½~ï¿½ï¿½nyï¿½N7ï¿½Ö¬yï¿½Ö¯[Oï¿½9ï¿½=ï¿½ï¿½mQï¿½Kï¿½ï¿½sï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½gï¿½lg~Ç—ï¿½ï¿½ï¿½ï¿½nï¿½ï¿½sï¿½8ï¿½pï¿½Mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½iBï¿½<(ï¿½ï¿½ï¿½Ó¤ï¿½ï¿½ï¿½)x]oï¿½_ï¿½v
Íš}6ï¿½>9ï¿½ï¿½\ï¿½:ï¿½9wï¿½\ï¿½ï¿½ ï¿½<ï¿½_ï¿½ï¿½ï¿½ï¿½kï¿½ï¿½Í¸YS-ï¿½ï¿½ï¿½]@3gÎ¤uï¿½ï¿½Ñ“O>Isï¿½Î¥3ï¿½<ï¿½wï¿½ï¿½ï¿½ï¿½ï¿½6mzï¿½ï¿½Oï¿½Nsï¿½=ï¿½ï¿½vpï¿½-ï¿½ ï¿½pï¿½Û¾cï¿½7ï¿½ï¿½Gaï¿½Pï¿½,Ø˜ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½:ï¿½ï¿½?ï¿½å¸†ï¿½p_ï¿½x1<#:4ï¿½ï¿½ï¿½8 W|ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½ï¿½pG9ï¿½C:S0ï¿½tï¿½ï¿½8ï¿½ï¿½ï¿½\ï¿½J<ï¿½ï¿½ï¿½ï¿½ï¿½)Sï¿½ï¿½)ï¿½ï¿½ï¿½3~Ø¤ï¿½&Nï¿½ ï¿½ï¿½IÝ½{7Mcï¿½mimï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½ï¿½!ï¿½~ï¿½ï¿½ï¿½Â˜ï¿½+uÈƒ0~ï¿½ï¿½ï¿½?ï¿½ï¿½rï¿½ aï¿½bï¿½ï¿½0)oï¿½ï¿½ï¿½Wï¿½ï¿½(ï¿½8f8|ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½kjiÜ¸SXï¿½ï¿½^ï¿½Sï¿½[ï¿½|ï¿½ï¿½Ã¹0Qï¿½Zï¿½ï¿½xXï¿½ï¿½ÍŸTï¿½W]wï¿½uï¿½6ï¿½{Ø‰ï¿½*ï¿½ï¿½ï¿½krï¿½bÞ¼y>ï¿½ï¿½}ï¿½ï¿½ï¿½[ï¿½ï¿½ß‰sï¿½!ï¿½-qï¿½ ï¿½wï¿½ï¿½ï¿½sï¿½8mÜ¸Aï¿½2ï¿½ï¿½aï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½>.[ï¿½Wï¿½>ï¿½ï¿½_ï¿½ï¿½zï¿½Ù§8:ï¿½ï¿½Lï¿½ï¿½[ï¿½ï¿½Â€x0;ï¿½ï¿½ï¿½ NGNï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½.ï¿½6oï¿½$<ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½GÛ·mKï¿½ï¿½ï¿½ï¿½nï¿½{9oï¿½ï¿½ï¿½ï¿½ï¿½gÏ®ï¿½ï¿½sOÑ²ï¿½~ï¿½h|ï¿½ï¿½ï¿½ï¿½quqï¿½Eï¿½pï¿½	ï¿½ï¿½ï¿½6Nï¿½i6ï¿½,ï¿½&rï¿½w~ï¿½[ï¿½ï¿½_vÅ•|:E5ï¿½uï¿½ï¿½ï¿½bWEUu !ï¿½uhã¼´ï¿½ï¿½ï¿½/ï¿½pÑ”Xï¿½#;ï¿½&ï¿½cï¿½ï¿½ï¿½Ò†ï¿½%ÚŽ;ï¿½ï¿½Sè¥‰ï¿½&ï¿½Ô©SyPbIWï¿½Ñ¾>vï¿½4~Â©ï¿½9ï¿½aï¿½(ï¿½@C<Hï¿½ï¿½#mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½P(ï¿½|gÒ¾hï¿½ï¿½
ï¿½ï¿½qï¿½ï¿½
/ï¿½Þ±ï¿½Æ‡>ï¿½ï¿½2ï¿½o@ï¿½8Ü¯ï¿½ï¿½755ï¿½E]Dï¿½ï¿½~:ï¿½ï¿½ï¿½$<M5ï¿½[?ï¿½ï¿½Lï¿½yï¿½`ï¿½xNg|JG×;wÒªï¿½+Yï¿½Ytê©“ï¿½ï¿½z+vÖ®ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½qq1ï¿½ï¿½ï¿½ï¿½áˆŽï¿½oQ1~ï¿½ï¿½Xï¿½|ï¿½ï¿½*lyï¿½Ý»ï¿½ï¿½|ï¿½Mzï¿½ï¿½ï¿½4ï¿½ï¿½Aï¿½ï¿½ï¿½EMï¿½ï¿½%!
ï¿½
ï¿½ï¿½Îï¿½ï¿½ï¿½R^ï¿½`ï¿½Lï¿½r*}ï¿½ï¿½_ï¿½S}Õ°ï¿½ï¿½ï¿½CDï¿½ï¿½ZRR*ï¿½^HZ[[y[m
}ï¿½/ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½beï¿½ï¿½ï¿½ê®ï¿½hï¿½ï¿½-tï¿½y?ï¿½:ï¿½ï¿½ï¿½vÂŽï¿½9ï¿½ï¿½	ï¿½Yï¿½ï¿½xZl×®ï¿½ï¿½ï¿½ï¿½ï¿½Ã¼ï¿½rï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½a:ï¿½ï¿½ï¿½:ï¿½ï¿½ï¿½ï¿½~z/ç¸·Hï¿½ll)[_ï¿½a>ï¿½]]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½uoï¿½ï¿½Õ«N(ï¿½ï¿½tï¿½ï¿½dÔ¨ï¿½ï¿½Å»ï¿½ï¿½>^ï¿½?ï¿½ï¿½=Kï¿½yï¿½ï¿½ï¿½ï¿½`|'lë–­tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½JXï¿½]ï¿½ï¿½ï¿½Dï¿½ï¿½
ï¿½={vï¿½ï¿½Uï¿½ï¿½'ï¿½ï¿½_ ï¿½ï¿½vï¿½ï¿½OJoï¿½Úª)ï¿½ï¿½ï¿½&ï¿½|ï¿½ï¿½ï¿½<ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½Lï¿½|ï¿½#ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½{qAï¿½ï¿½ï¿½fï¿½ï¿½"8pï¿½ï¿½ï¿½Ù´ï¿½}ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½_ï¿½L'ï¿½Dï¿½ï¿½ï¿½U`ï¿½ï¿½*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Sgì‰¨dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Oragï¿½ï¿½/ï¿½'ï¿½e;ï¿½ï¿½ë¼¯ï¿½W.ï¿½ï¿½ï¿½oï¿½mÛ¶ï¿½3|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ôž8Ç©ï¿½\K3>wW!,ï¿½)ï¿½Gï¿½Iï¿½Ã¿sï¿½ï¿½ï¿½JHï¿½1ï¿½ï¿½ï¿½!ï¿½ï¿½ï¿½'ï¿½rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½;sHRï¿½D+ï¿½ï¿½ï¿½c:ï¿½ï¿½&ï¿½Ê ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½ï¿½ï¿½Îï¿½EÅ˜Ôœï¿½2ï¿½ï¿½yï¿½+Sï¿½ï¿½ï¿½ï¿½Upï¿½ï¿½ï¿½*ï¿½9ï¿½Ç½ï¿½rNÌ£ï¿½nczï¿½A\ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½>.Åï¿½ï¿½
ï¿½[ï¿½fï¿½bsï¿½f.ï¿½ï¿½ï¿½#'{ï¿½ï¿½ï¿½ï¿½0ï¿½Gd'ï¿½ï¿½ï¿½ï¿½ï¿½AbDqï¿½tï¿½=ï¿½ï¿½qqï¿½ ï¿½  Aï¿½ï¿½ï¿½h6ï¿½0ï¿½ï¿½:ï¿½uï¿½8eï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½Fv`ï¿½ï¿½nÄ…ï¿½aHï¿½ï¿½8\ê³£ï¿½ï¿½'l

ï¿½ï¿½ï¿½ï¿½ï¿½E\ï¿½Fxdï¿½ï¿½yï¿½ï¿½ï¿½ï¿½ï¿½ï¿½A3h0    IENDï¿½B`ï¿½
--- END OF FILE draft/server/resource-picker.png ---


--- START OF FILE draft/server/resources.mdx ---
---
title: Resources
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol (MCP) provides a standardized way for servers to expose
resources to clients. Resources allow servers to share data that provides context to
language models, such as files, database schemas, or application-specific information.
Each resource is uniquely identified by a
[URI](https://datatracker.ietf.org/doc/html/rfc3986).

## User Interaction Model

Resources in MCP are designed to be **application-driven**, with host applications
determining how to incorporate context based on their needs.

For example, applications could:

- Expose resources through UI elements for explicit selection, in a tree or list view
- Allow the user to search through and filter available resources
- Implement automatic context inclusion, based on heuristics or the AI model's selection

![Example of resource context picker](/specification/draft/server/resource-picker.png)

However, implementations are free to expose resources through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

## Capabilities

Servers that support resources **MUST** declare the `resources` capability:

```json
{
  "capabilities": {
    "resources": {
      "subscribe": true,
      "listChanged": true
    }
  }
}
```

The capability supports two optional features:

- `subscribe`: whether the client can subscribe to be notified of changes to individual
  resources.
- `listChanged`: whether the server will emit notifications when the list of available
  resources changes.

Both `subscribe` and `listChanged` are optional&mdash;servers can support neither,
either, or both:

```json
{
  "capabilities": {
    "resources": {} // Neither feature supported
  }
}
```

```json
{
  "capabilities": {
    "resources": {
      "subscribe": true // Only subscriptions supported
    }
  }
}
```

```json
{
  "capabilities": {
    "resources": {
      "listChanged": true // Only list change notifications supported
    }
  }
}
```

## Protocol Messages

### Listing Resources

To discover available resources, clients send a `resources/list` request. This operation
supports [pagination](/specification/draft/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "resources/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "file:///project/src/main.rs",
        "name": "main.rs",
        "title": "Rust Software Application Main File",
        "description": "Primary application entry point",
        "mimeType": "text/x-rust"
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Reading Resources

To retrieve resource contents, clients send a `resources/read` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "resources/read",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "contents": [
      {
        "uri": "file:///project/src/main.rs",
        "name": "main.rs",
        "title": "Rust Software Application Main File",
        "mimeType": "text/x-rust",
        "text": "fn main() {\n    println!(\"Hello world!\");\n}"
      }
    ]
  }
}
```

### Resource Templates

Resource templates allow servers to expose parameterized resources using
[URI templates](https://datatracker.ietf.org/doc/html/rfc6570). Arguments may be
auto-completed through [the completion API](/specification/draft/server/utilities/completion).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "resources/templates/list"
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "resourceTemplates": [
      {
        "uriTemplate": "file:///{path}",
        "name": "Project Files",
        "title": "ðŸ“ Project Files",
        "description": "Access files in the project directory",
        "mimeType": "application/octet-stream"
      }
    ]
  }
}
```

### List Changed Notification

When the list of available resources changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/list_changed"
}
```

### Subscriptions

The protocol supports optional subscriptions to resource changes. Clients can subscribe
to specific resources and receive notifications when they change:

**Subscribe Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "resources/subscribe",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

**Update Notification:**

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "file:///project/src/main.rs",
    "title": "Rust Software Application Main File"
  }
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Resource Discovery
    Client->>Server: resources/list
    Server-->>Client: List of resources

    Note over Client,Server: Resource Access
    Client->>Server: resources/read
    Server-->>Client: Resource contents

    Note over Client,Server: Subscriptions
    Client->>Server: resources/subscribe
    Server-->>Client: Subscription confirmed

    Note over Client,Server: Updates
    Server--)Client: notifications/resources/updated
    Client->>Server: resources/read
    Server-->>Client: Updated contents
```

## Data Types

### Resource

A resource definition includes:

- `uri`: Unique identifier for the resource
- `name`: The name of the resource.
- `title`: Optional human-readable name of the resource for display purposes.
- `description`: Optional description
- `mimeType`: Optional MIME type
- `size`: Optional size in bytes

### Resource Contents

Resources can contain either text or binary data:

#### Text Content

```json
{
  "uri": "file:///example.txt",
  "name": "example.txt",
  "title": "Example Text File",
  "mimeType": "text/plain",
  "text": "Resource content"
}
```

#### Binary Content

```json
{
  "uri": "file:///example.png",
  "name": "example.png",
  "title": "Example Image",
  "mimeType": "image/png",
  "blob": "base64-encoded-data"
}
```

## Common URI Schemes

The protocol defines several standard URI schemes. This list not
exhaustive&mdash;implementations are always free to use additional, custom URI schemes.

### https://

Used to represent a resource available on the web.

Servers **SHOULD** use this scheme only when the client is able to fetch and load the
resource directly from the web on its ownâ€”that is, it doesnâ€™t need to read the resource
via the MCP server.

For other use cases, servers **SHOULD** prefer to use another URI scheme, or define a
custom one, even if the server will itself be downloading resource contents over the
internet.

### file://

Used to identify resources that behave like a filesystem. However, the resources do not
need to map to an actual physical filesystem.

MCP servers **MAY** identify file:// resources with an
[XDG MIME type](https://specifications.freedesktop.org/shared-mime-info-spec/0.14/ar01s02.html#id-1.3.14),
like `inode/directory`, to represent non-regular files (such as directories) that donâ€™t
otherwise have a standard MIME type.

### git://

Git version control integration.

### Custom URI Schemes

Custom URI schemes **MUST** be in accordance with [RFC3986](https://datatracker.ietf.org/doc/html/rfc3986),
taking the above guidance in to account.

## Error Handling

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:

- Resource not found: `-32002`
- Internal errors: `-32603`

Example error:

```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "error": {
    "code": -32002,
    "message": "Resource not found",
    "data": {
      "uri": "file:///nonexistent.txt"
    }
  }
}
```

## Security Considerations

1. Servers **MUST** validate all resource URIs
2. Access controls **SHOULD** be implemented for sensitive resources
3. Binary data **MUST** be properly encoded
4. Resource permissions **SHOULD** be checked before operations

--- END OF FILE draft/server/resources.mdx ---


--- START OF FILE draft/server/slash-command.png ---
ï¿½PNG

   
IHDR  %   j   ï¿½Gz  ^iCCPICC Profile  (ï¿½uï¿½;HAï¿½ï¿½ï¿½h0ï¿½"ï¿½ï¿½ï¿½ï¿½b$ï¿½6"ï¿½"XQï¿½ï¿½es^ï¿½K\7'bï¿½ï¿½ï¿½66ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½+Eï¿½Oï¿½ï¿½
ï¿½ï¿½EMï¿½ï¿½ï¿½ï¿½ï¿½ï¿½33ï¿½ï¿½uï¿½-ï¿½Bï¿½ï¿½Ù¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!ï¿½ï¿½Og%ï¿½Ð´y*ï¿½ï¿½ï¿½ï¿½ï¿½#<Rï¿½Gï¿½ï¿½ï¿½ï¿½iï¿½ï¿½W^ï¿½ï¿½;#ï¿½ï¿½ï¿½-/ï¿½3Jï¿½ï¿½rï¿½qaï¿½XÛµï¿½ï¿½âˆ ï¿½ï¿½ï¿½%ï¿½uï¿½ï¿½ï¿½ï¿½sÙ­YÌ¤ï¿½ï¿½ï¿½,ï¿½ï¿½+ï¿½ï¿½lï¿½o6qï¿½ï¿½a_;ï¿½ï¿½Fqiï¿½ï¿½ï¿½ï¿½iï¿½($ï¿½ï¿½8Tï¿½ï¿½Oï¿½>ï¿½ï¿½Ka{Ø„ï¿½<lwï¿½ï¿½hï¿½ï¿½9ï¿½0ï¿½(qã”ªï¿½ï¿½ï¿½;6ï¿½ï¿½;`fï¿½`ï¿½ï¿½%9pï¿½tï¿½4ï¿½ï¿½# t
ÜŽq]ï¿½?ï¿½ï¿½T}ï¿½ï¿½xï¿½ï¿½Aï¿½ï¿½9ï¿½k/ï¿½jï¿½qï¿½Oï¿½vxï¿½ï¿½ï¿½ï¿½'ï¿½9ajï¿½Jï¿½   DeXIfMM *           ï¿½i       &     ï¿½      %ï¿½       j    oIï¿½ï¿½  iTXtXML:com.adobe.xmp     <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="XMP Core 6.0.0">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:tiff="http://ns.adobe.com/tiff/1.0/"
            xmlns:exif="http://ns.adobe.com/exif/1.0/">
         <tiff:Orientation>1</tiff:Orientation>
         <exif:PixelXDimension>293</exif:PixelXDimension>
         <exif:PixelYDimension>106</exif:PixelYDimension>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
l0ï¿½5  lIDATxï¿½]	xUEï¿½>Y YHï¿½ï¿½ï¿½ï¿½HXHï¿½DDdwï¿½Glhmï¿½luï¿½Fï¿½ï¿½ï¿½vz>ï¿½ï¿½vï¿½[g[wTï¿½%HXdï¿½%a'+	[ !ï¿½Adï¿½_ï¿½.ï¿½ï¿½ï¿½GÖ—Ü¼wï¿½ï¿½ï¿½Wuï¿½Ö­[ï¿½×½ï¿½=uNï¿½[^Wï¿½^ï¿½N"ï¿½ï¿½  Xoï¿½ï¿½Cï¿½!ï¿½ï¿½B@HI.A@ï¿½BJï¿½ï¿½ï¿½ï¿½  )ï¿½5 ï¿½B@Hï¿½Rï¿½!ï¿½!%ï¿½Aï¿½R)Yï¿½;ï¿½2ï¿½ï¿½  ï¿½$×€  X
!%Kuï¿½TFï¿½ï¿½ï¿½K! ï¿½dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ `)ï¿½ï¿½,ï¿½RA@ï¿½ï¿½ï¿½+ï¿½ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½^iï¿½ ï¿½PMï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CE@Hï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CE@Hï¿½ï¿½ï¿½ï¿½ï¿½[pSï¿½ï¿½Ü´cï¿½Yï¿½@CEï¿½å¤´nï¿½zJKKï¿½1>ï¿½Îï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½p))ï¿½ï¿½ï¿½Ó›oï¿½C.ï¿½ï¿½ï¿½ï¿½ï¿½YNï¿½ï¿½Cï¿½,ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½(.nï¿½ï¿½\pï¿½Gvï¿½ï¿½ï¿½p))ï¿½Zï¿½ï¿½Zï¿½jEï¿½^#$ï¿½ï¿½5%/oo
nï¿½ï¿½i9ï¿½hï¿½ï¿½7ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½A@ï¿½>ï¿½ï¿½ï¿½bAA>ï¿½Ø±ï¿½ï¿½1ï¿½ï¿½ï¿½nï¿½}EEï¿½ï¿½ï¿½lï¿½Â¢+4tHï¿½nm;ï¿½zÜ¸ï¿½4fï¿½hï¿½ï¿½ï¿½qZï¿½ï¿½$ï¿½ï¿½9Gv
ï¿½ï¿½Ò†ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æï¿½ï¿½ï¿½Gï¿½PjJ7ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½5kï¿½ï¿½Ë‹ï¿½B[)Rï¿½pï¿½Ä‰ï¿½c;vï¿½@ï¿½ï¿½ï¿½Fï¿½Õ«W())Emoï¿½ï¿½ï¿½
ï¿½ï¿½3(((ï¿½ï¿½Þ‘ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½ï¿½p)ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ã·PJï¿½ï¿½æ¿¼ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½Ktï¿½:ï¿½ï¿½ï¿½Gï¿½ï¿½Ggyï¿½ï¿½ï¿½wcï¿½yï¿½ï¿½*ï¿½K'ï¿½gï¿½ï¿½yï¿½Eï¿½ï¿½ï¿½%ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½Ñ!ï¿½mï¿½dCï¿½ï¿½ï¿½KH)99ï¿½RSSiï¿½ï¿½+ï¿½ï¿½ï¿½VÒ¼yï¿½ï¿½iS'Snï¿½eE>ï¿½>ï¿½ï¿½&Mï¿½Hï¿½oØï¿½ï¿½ï¿½>ï¿½@ï¿½Éžï¿½ï¿½ï¿½_-WVï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½[oï¿½KO>ï¿½ï¿½hï¿½
3ï¿½ï¿½#ï¿½RZï¿½zï¿½fï¿½9|X9ï¿½Oï¿½Fï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½Ç—BBBï¿½^t/ï¿½ï¿½ï¿½qï¿½3Hï¿½ï¿½wï¿½k×®ï¿½ï¿½ï¿½_ï¿½FFï¿½3gÎª]ï¿½Utï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½u-))ï¿½ï¿½ï¿½[iï¿½È‘ï¿½ï¿½[ï¿½ï¿½ï¿½3ï¿½ Ozï¿½M{Qrrï¿½:Sï¿½V-ï¿½qF9Dï¿½	ï¿½ï¿½Qï¿½ï¿½ï¿½mï¿½Fï¿½ï¿½yï¿½8aï¿½Ã’ï¿½ï¿½Zï¿½fï¿½ï¿½ï¿½ï¿½iPï¿½@5ï¿½iß¾xï¿½Û·/a8&"ï¿½ï¿½@ï¿½kJkØ‹Ö£{
wï¿½lï¿½vmï¿½ï¿½;ï¿½)ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½f>ï¿½ -^ï¿½zï¿½S(ï¿½ï¿½ï¿½ ï¿½VÔªï¿½ï¿½ï¿½ï¿½Iï¿½gï¿½~ï¿½)H0tï¿½ï¿½ï¿½Hï¿½/ï¿½ï¿½]ï¿½ï¿½Nï¿½Uuï¿½ï¿½Oï¿½ï¿½kUï¿½ ï¿½Aï¿½ï¿½URZï¿½j
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½w;ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½Oï¿½ï¿½<5IÙž:wï¿½)S&Qï¿½.]Ô±ï¿½ï¿½}ï¿½|ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½nï¿½Ô´Tï¿½ï¿½ï¿½Ý»ï¿½ï¿½ï¿½WÏžl@oDË¿ï¿½ï¿½ï¿½ï¿½T6g	ï¿½3ï¿½O3ï¿½Ä¶ï¿½  Xï¿½Z#ï¿½ï¿½ï¿½ï¿½Xï¿½09|ï¿½PjÒ¤ï¿½ï¿½V7oï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½5f$ï¿½ï¿½iÓ¦Í´kï¿½ï¿½lï¿½ERï¿½yï¿½tï¿½G
yzï¿½*# ï¿½ï¿½ï¿½ï¿½ï¿½dCï¿½6mJï¿½-xEMï¿½<sï¿½ï¿½ï¿½~ï¿½
Ïƒï¿½ï¿½@ï¿½ï¿½ï¿½n&ï¿½ï¿½2ï¿½ï¿½ï¿½9m|^ï¿½ezï¿½ï¿½Í™ï¿½=ï¿½ï¿½tï¿½|q[ï¿½Ò¢Eï¿½WSvï¿½ï¿½i8EFFÒ»ï¿½iï¿½ï¿½ï¿½
L'ï¿½S
*ï¿½+ï¿½Aï¿½ï¿½Ôš!fï¿½ï¿½uÔ–ï¿½ï¿½QQï¿½N[ï¿½ï¿½_@×®]ï¿½Ý»ï¿½ï¿½'Oï¿½|Ð°2xz ï¿½fï¿½ï¿½ï¿½`ÊŸ  x&ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½9ï¿½Mï¿½6tï¿½ï¿½hÕªï¿½ï¿½ï¿½ï¿½Oï¿½mMï¿½Ðµï¿½kjï¿½^9yï¿½g+
ï¿½3ï¿½BZ-@ï¿½+;;ï¿½ï¿½_ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½F}xï¿½eHp0EDtï¿½Æï¿½\ï¿½+ï¿½ï¿½ACï¿½!Pkï¿½RUï¿½ï¿½ï¿½Û¢ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½Ïœ×žï¿½ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ `ê…”ï¿½ï¿½L>7ï¿½Gï¿½ï¿½>rVA@pï¿½ï¿½Û“ï¿½ï¿½)Nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½P:8ï¿½#ï¿½$M\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4É˜Cï¿½ï¿½|9Oï¿½ï¿½oï¿½/ï¿½ï¿½}ï¿½ï¿½ï¿½Fï¿½'8Cï¿½4ï¿½2ï¿½ï¿½


)??_y
ï¿½ï¿½ï¿½ï¿½ï¿½'q:Iï¿½Aï¿½ï¿½p[Rï¿½ï¿½ï¿½Ô„ï¿½yRï¿½/_ï¿½ï¿½Mï¿½+)uï¿½ï¿½I*ï¿½ï¿½[ï¿½ï¿½&$ï¿½ï¿½ï¿½5ï¿½!5kÖŒ?.ï¿½|ï¿½ï¿½'ï¿½Aï¿½5ï¿½zï¿½ï¿½kï¿½Y'ï¿½j2ï¿½ï¿½ï¿½lHxaWï¿½Nï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½HIkI@q=tï¿½ï¿½Ô¸qï¿½j%
ï¿½@ï¿½ ï¿½ï¿½ï¿½7@ï¿½ï¿½Iï¿½ÚŽÚ—.]T3ï¿½KJJï¿½q9ï¿½  ï¿½ï¿½$%3!iRrï¿½^^vv6]ï¿½Xï¿½%ï¿½oï¿½ï¿½ï¿½ï¿½*#ï¿½vï¿½7ï¿½ï¿½&#ï¿½ï¿½ï¿½ï¿½>
!i$$ï¿½ï¿½ï¿½[ï¿½ï¿½#ï¿½)Yï¿½ï¿½&ï¿½ï¿½ ï¿½p+RÒÒ¡&)ï¿½t	Aï¿½ï¿½ï¿½%)		Yï¿½ï¿½ï¿½ï¿½	!ï¿½ï¿½ï¿½dn4ï¿½ï¿½ï¿½@ï¿½Aï¿½mIÉ¬-ï¿½ï¿½ï¿½5ï¿½yaï¿½%Zï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½	ï¿½ï¿½SU*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½oï¿½ï¿½Ê¡5Î›ï¿½{ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'qï¿½Ü–ï¿½êª¯Nï¿½<ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½ï¿½PRR/
qï¿½ï¿½ï¿½]'ï¿½ï¿½8EVï¿½<nÛ¾ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½}ï¿½EE4ï¿½/ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X.Lï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½n9Oï¿½fï¿½j7vï¿½ï¿½1:pï¿½ï¿½ï¿½%ï¿½Ðƒï¿½å••Ú…ï¿½%ï¿½ï¿½ï¿½ï¿½"|ï¿½ï¿½ï¿½+Ô¡}{ï¿½h]rb.ï¿½kï¿½ï¿½4oï¿½
ï¿½ï¿½	ï¿½ ï¿½ï¿½R%ï¿½ï¿½ï¿½sKï¿½|ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½1}ï¿½ï¿½R%ï¿½ï¿½ï¿½lï¿½"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|jZï¿½ï¿½ï¿½ï¿½!YeoDEï¿½ï¿½lvï¿½w!%'ï¿½BVV6ï¿½Zï¿½ï¿½RRR)_ï¿½ï¿½.AHï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½nï¿½A6ï¿½R.ï¿½Ö¡4uï¿½$ï¿½Ñ½ï¿½ï¿½Ò'cï¿½ï¿½ï¿½ï¿½ï¿½4ï¿½ï¿½ï¿½)==ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½G{ï¿½ï¿½5
ï¿½×¯/ï¿½ï¿½Iï¿½ï¿½Kï¿½\ï¿½ ^ï¿½ï¿½_?nï¿½Lï¿½ï¿½ï¿½_Aï¿½ï¿½ï¿½
/ï¿½Þ‰W;ï¿½ï¿½ï¿½ï¿½ï¿½4Zï¿½r-ï¿½ï¿½?}ï¿½ï¿½ï¿½;ï¿½4nsË–-lï¿½>|ï¿½Ö­ï¿½ï¿½ï¿½ï¿½sï¿½a^ï¿½Ð°0ï¿½Ý«ï¿½7nL9Rï¿½Û²]ï¿½ï¿½wï¿½|6ï¿½ï¿½ï¿½ï¿½ï¿½={ï¿½6ë—¨ï¿½xï¿½ï¿½ï¿½ï¿½å‡„ï¿½ï¿½ï¿½Í ï¿½ï¿½vÓ±ï¿½ï¿½TXTHO?ï¿½kï¿½ï¿½ï¿½Ï¾ï¿½Ó§Nyï¿½Ø±ï¿½|ï¿½ï¿½ï¿½Ï–}ï¿½>ï¿½ÝŸë¹‰2ï¿½fï¿½6ï¿½s
`ï¿½!ï¿½ï¿½xï¿½FÕ·ï¿½ï¿½Aï¿½ï¿½3C9-O>1ï¿½ï¿½ï¿½yï¿½ï¿½bzï¿½ï¿½ï¿½ï¿½dFDï¿½ï¿½)ï¿½'Ú¤a$ï¿½ï¿½[ï¿½"ï¿½ï¿½ï¿½gï¿½ï¿½{Gï¿½ï¿½I'ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½Ô‡ï¿½ï¿½6ï¿½1ï¿½`ï¿½F|,Xï¿½Ð¢uï¿½vï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½R^ï¿½	ï¿™%ï¿½ï¿½t$EEEï¿½ï¿½;ï¿½ï¿½	ï¿½ï¿½9ï¿½bï¿½<ï¿½ï¿½ï¿½ï¿½bzï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ý¯nï¿½l&ï¿½!ï¿½Q@@ ï¿½8ï¿½ï¿½Ãƒ
ï¿½ï¿½Umï¿½ï¿½Cï¿½ï¿½P<ï¿½ï¿½ï¿½Rï¿½{ï¿½ï¿½Ô¡C;^)8ï¿½ï¿½;N%ï¿½%ï¿½ï¿½KUï¿½Bï¿½Xï¿½ï¿½-Zï¿½ï¿½C|ï¿½C#Xï¿½7zï¿½Iï¿½:LPï¿½@&ï¿½(ï¿½ï¿½ï¿½_}ï¿½ï¿½ï¿½nï¿½I-}3ï¿½?ï¿½Ò”ï¿½oØ¤ï¿½>8oï¿½.áª¨ï¿½Ç“ï¿½ï¿½yï¿½ï¿½ï¿½ï¿½ï¿½JH8D[ï¿½mï¿½Awï¿½l3Frï¿½`Ã†
ï¿½ï¿½oï¿½O^ï¿½ï¿½ï¿½ï¿½ï¿½wRï¿½ï¿½Ô¿_ï¿½j+Vï¿½á¥·ï¿½(ï¿½:t0ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½!%%ï¿½ï¿½ï¿½Aï¿½Oï¿½:Cï¿½ï¿½ï¿½t<1ï¿½ï¿½ï¿½Cï¿½ï¿½
ï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½ï¿½Ú‚ï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½o#ï¿½Gï¿½I9ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½r@8ï¿½ï¿½(ï¿½SGjÕªï¿½"ï¿½]ï¿½~Vï¿½ï¿½ï¿½ï¿½vï¿½Ô¦ï¿½ï¿½Ã‡Viï¿½d_ï¿½QuD=Sï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½]ï¿½ï¿½`^ï¿½gÈ;ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½|ï¿½ï¿½}r<1ï¿½jï¿½3
ï¿½hï¿½ï¿½.ï¿½h%ï¿½ZIÉ©tï¿½bï¿½awÆŒitï¿½ï¿½!ï¿½ï¿½Mï¿½ï¿½ï¿½ï¿½Pï¿½|ï¿½@+ï¿½ï¿½ï¿½ï¿½Mï¿½?ï¿½ï¿½qQBï¿½ï¿½á‡•tï¿½ï¿½Q:$Fgï¿½R8mï¿½dï¿½ï¿½ï¿½S3yï¿½DZï¿½ï¿½bÚ¶m'ï¿½;Fï¿½ï¿½ï¿½ï¿½ï¿½08ï¿½ï¿½ï¿½d^6}p9ï¿½Ì‰ï¿½fßµkk	-ï¿½ï¿½W^242Ü˜ï¿½ï¿½Ö»ï¿½ï¿½ï¿½ÔŠoï¿½}á·†ï¿½Ù‹ï¿½xï¿½M^6}ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½Ö­[Uï¿½!|ï¿½ï¿½ï¿½ï¿½Ûµï¿½06oÞªHjï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½i-Aï¿½ï¿½Nï¿½_ï¿½>Å¤ï¿½ï¿½ï¿½Lï¿½ï¿½~ï¿½ï¿½ÖŽï¿½ï¿½ï¿½Tï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½ï¿½?<ï¿½~ï¿½ï¿½oï¿½ï¿½;Ç„ï¿½ï¿½Oï¿½Ic7ï¿½rï¿½ï¿½ï¿½Eï¿½ï¿½?Jï¿½ï¿½N-ï¿½XÚ¶mCï¿½ï¿½ï¿½kï¿½ï¿½ï¿½ï¿½tï¿½ï¿½oï¿½cï¿½ï¿½&.ï¿½sDD=ï¿½ï¿½ï¿½F9+ï¿½ï¿½7ï¿½ï¿½ ï¿½ï¿½ï¿½_ï¿½>Fï¿½+ï¿½1ï¿½pï¿½Eï¿½ï¿½tH1kGZï¿½-Zï¿½ï¿½$ï¿½m&cï¿½#xJï¿½$Ò£ï¿½)a];ï¿½ï¿½ï¿½ï¿½Yï¿½I4'ï¿½ï¿½ï¿½ï¿½1ï¿½&
ï¿½xï¿½ï¿½/ï¿½ï¿½ß‡ï¿½ï¿½.ï¿½6mï¿½ï¿½.#ï¿½ï¿½ï¿½kï¿½ï¿½mï¿½ï¿½ï¿½ï¿½+ï¿½Ïœï¿½Ò‹ï¿½eï¿½ï¿½<ï¿½ï¿½d	k3ï¿½BB^yï¿½rï¿½
ï¿½gÏž%hï¿½gyHfï¿½ ï¿½132NImZï¿½ï¿½ï¿½7|`ï¿½uï¿½ï¿½ÊšG;ï¿½ï¿½Í‚cÔ¹ï¿½ï¿½3'Ó¨Qwï¿½lï¿½oï¿½ï¿½&NWï¿½ï¿½ï¿½ï¿½3'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½á¸¹ï¿½Â˜ï¿½ï¿½ï¿½jï¿½h'ï¿½Dï¿½@^Zï¿½ï¿½lHCï¿½W6<q"]vtï¿½mï¿½DG+RJMMï¿½)ï¿½ï¿½ï¿½Xeï¿½oï¿½|BJzï¿½\ï¿½ï¿½yØ‡!ï¿½a~Reï¿½ï¿½ï¿½ï¿½G
ï¿½f$é§¶ï¿½"ï¿½Î®]ï¿½ï¿½ï¿½ï¿½ï¿½È‡n Gï¿½ï¿½YBCï¿½nï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½wï¿½ï¿½Ù¼Y.Þ·oï¿½ï¿½Øyï¿½ï¿½.ï¿½\.Dï¿½9ï¿½9ï¿½ï¿½]6ï¿½Å	?{)5}ZÆ„ï¿½ï¿½(nï¿½6Cï¿½ï¿½aï¿½ï¿½Ö­+=0cï¿½ï¿½x=Ý )ï¿½"-YWï¿½ï¿½yï¿½ï¿½Vy`ï¿½:}ï¿½ï¿½;ï¿½Â„Ã‚ï¿½ï¿½x!ï¿½ï¿½ï¿½;ï¿½ï¿½9
ï¿½rrlh6ï¿½xï¿½ï¿½5fï¿½ï¿½!n)9ï¿½5ï¿½ï¿½ï¿½,ï¿½ï¿½_ï¿½g;ï¿½!Íš6Sï¿½M_ï¿½Õ‘ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½ï¿½uï¿½
Stï¿½ï¿½ï¿½ï¿½ï¿½!|dï¿½ï¿½ï¿½rqï¿½rï¿½R9ï¿½ï¿½p#ï¿½5ï¿½Ø±ï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½`ï¿½ï¿½ï¿½aaGï¿½ï¿½ ;ï¿½GKï¿½ï¿½K/>ï¿½ï¿½
*ï¿½\e{]Uï¿½ï¿½6Wï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½
BÂ¹0M ï¿½ï¿½L
jA?ï¿½ï¿½ï¿½Wuï¿½'ï¿½BJz7Ð—_~Kï¿½ï¿½4{ï¿½ï¿½lè½ª.ï¿½6<ï¿½0{EZkIYYï¿½ï¿½ï¿½uï¿½	ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½kï¿½ï¿½|Xï¿½ah5ï¿½'ï¿½ï¿½fï¿½!ï¿½ï¿½4Mp&ï¿½[8ï¿½ï¿½ï¿½0CÎž=Çžï¿½<ï¿½ï¿½Cï¿½Þ½zï¿½ï¿½ï¿½Xï¿½ï¿½]Û¶ï¿½ï¿½0ï¿½ï¿½1ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½T^brï¿½'ï¿½LÊ†]pZï¿½ï¿½ï¿½ï¿½ï¿½Ï¯ï¿½	ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Ã§ï¿½ï¿½Nï¿½ï¿½ï¿½<ï¿½3ï¿½Ú¨Qc6ï¿½S	ï¿½ï¿½ï¿½Bï¿½KULkHï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½/ï¿½sï¿½ï¿½ï¿½ï¿½q!%=ï¿½':l ï¿½ï¿½K?7<mï¿½ ï¿½~ï¿½]#x(vï¿½á’ƒbï¿½ï¿½Wï¿½ï¿½{ï¿½Vï¿½={ï¿½ï¿½ï¿½ï¿½,8pï¿½Z
ï¿½ï¿½>ï¿½ï¿½kï¿½)ï¿½ï¿½vï¿½ï¿½
ï¿½q=y{Tf'ï¿½ï¿½5ï¿½É³ï¿½)ï¿½ï¿½ vï¿½ï¿½ï¿½6ï¿½=ï¿½^ÆKË¸~ï¿½ï¿½Ö‡ï¿½ï¿½+ï¿½Ü‰<ï¿½Cï¿½v)}ï¿½ï¿½rJIKeï¿½Rï¿½ï¿½!1mHeOï¿½Q&ï¿½^=#ï¿½bqCÃ–ï¿½ï¿½ï¿½d1ï¿½ï¿½bï¿½ï¿½Æï¿½ï¿½ï¿½`ï¿½ï¿½0ï¿½ï¿½ï¿½Afï¿½ï¿½bÚ‚n3
ï¿½Û§ï¿½aï¿½&vï¿½ï¿½ï¿½,ï¿½-Zï¿½gï¿½4{ï¿½Lï¿½3ZÅ‹YCï¿½ï¿½ï¿½?dBï¿½Qï¿½ï¿½Î?ï¿½ï¿½ï¿½pvpï¿½ï¿½ï¿½ï¿½ï¿½+ï¿½ï¿½e!Ï‚Wï¿½ï¿½	ï¿½ï¿½ï¿½}ï¿½a 0<ï¿½t=[3ï¿½ï¿½[	ï¿½(Jï¿½}ï¿½>ï¿½kdï¿½7vï¿½Þ«<wï¿½~zï¿½)9ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Öµ+ï¿½ï¿½Sxï¿½ï¿½ï¿½pï¿½m:ï¿½Þ¶gï¿½\ï¿½$ï¿½Ú‚.ï¿½~[ï¿½W%7vï¿½zWKÏ‹ï¿½ï¿½fï¿½ï¿½ï¿½F{ï¿½ï¿½cï¿½ï¿½Vc;%5ï¿½ï¿½ï¿½ï¿½VURï¿½q3ï¿½AEï¿½Eï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Yfï¿½ï¿½ï¿½CMï¿½Xï¿½r5a#ï¿½ï¿½ï¿½Ó¦Øœï¿½ï¿½ï¿½ï¿½ï¿½ï¿½WPï¿½{ï¿½ï¿½ï¿½	ï¿½hï¿½ï¿½9Mfyï¿½ï¿½5bï¿½nÓ¦ÍŠï¿½:uï¿½Dï¿½f=dxOï¿½eË¾0fï¿½ï¿½"ï¿½Iï¿½ï¿½WQï¿½ï¿½ï¿½bRï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½ ï¿½7jï¿½Hï¿½acï¿½ï¿½L`Bï¿½ï¿½kï¿½fï¿½cJï¿½oï¿½2ï¿½^'ï¿½ï¿½#ï¿½1ï¿½4Lï¿½xï¿½I	ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½=tï¿½esï¿½ï¿½!ï¿½%<ï¿½ï¿½ï¿½6x#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½V+ï¿½jï¿½2ï¿½Vï¿½a6.ï¿½ï¿½ï¿½Rï¿½Tï¿½Â“fIJ*3^ï¿½ï¿½ï¿½+xÅŠUÔžï¿½ï¿½#Gï¿½yï¿½ï¿½ï¿½;8))Ù˜ï¿½.l%ï¿½-pï¿½ï¿½[ï¿½ï¿½/Zï¿½4ï¿½ï¿½aï¿½ï¿½ï¿½ï¿½ï¿½hï¿½LNï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ub0ï¿½ï¿½ï¿½ï¿½ï¿½Ù‹ï¿½(?ï¿½eï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½É¬ï¿½a:Ú‡ï¿½3++[ï¿½ï¿½ï¿½uuï¿½ï¿½Xï¿½hJz%!ï¿½J-ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½.Ä™wÎ•ï¿½	jï¿½wEç©¬ï¿½ï¿½ï¿½ï¿½ï¿½6ï¿½n8ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½FMaï¿½)C@Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½vï¿½ï¿½ï¿½ÈŽï¿½Ý ;88Rï¿½Aï¿½ï¿½)9@ï¿½ï¿½ï¿½×ï¿½;ï¿½Hï¿½jï¿½O
ï¿½ï¿½:w/7ï¿½wPLï¿½ï¿½ï¿½"ï¿½È¿ï¿½ï¿½ï¿½ï¿½V!rPï¿½5jDï¿½Iï¿½ï¿½>X2ï¿½ï¿½)ï¿½V)Tï¿½ï¿½ï¿½M#IuKï¿½ï¿½qfoï¿½9nï¿½ï¿½Jï¿½Aï¿½nKJï¿½ï¿½o5ï¿½-8ï¿½ï¿½ï¿½l:ï¿½ï¿½ï¿½ï¿½ Pï¿½ï¿½ï¿½M	ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½"1ï¿½_>Wjï¿½ï¿½lï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Rï¿½b.ï¿½Jï¿½ï¿½<Í›~"ï¿½ï¿½ `
ï¿½jï¿½fO8ï¿½iï¿½a2ï¿½ï¿½wï¿½ï¿½ï¿½ï¿½Bï¿½#ï¿½Vï¿½dnï¿½ï¿½$MJpï¿½cï¿½ï¿½ï¿½"ï¿½ï¿½ `]Ü’ï¿½@DMH 'ï¿½ï¿½ï¿½;Kxï¿½Lï¿½GÖ½ ï¿½fï¿½ï¿½ï¿½Ú”@HÚ†Rï¿½ï¿½hï¿½ï¿½ï¿½ï¿½Æ„ï¿½ï¿½ï¿½iï¿½ï¿½Aï¿½ï¿½#%MFï¿½qï¿½ï¿½	ï¿½Bï¿½ï¿½7ï¿½ï¿½ï¿½ 4&ï¿½ï¿½ï¿½ï¿½3Wï¿½]#5<ï¿½#%ÝZï¿½)i1iA:ï¿½Dï¿½Dï¿½:ï¿½ï¿½ï¿½ï¿½ Pï¿½ï¿½%)imIBMHï¿½ï¿½g&$31ï¿½}ï¿½Aï¿½ï¿½ï¿½[ï¿½ï¿½Ñšï¿½ÖŠï¿½Ä„}ï¿½ï¿½ï¿½<:4ï¿½#qA@ï¿½{Ü–ï¿½4ï¿½ï¿½ï¿½ï¿½mIoCSï¿½iï¿½+ï¿½ï¿½ï¿½Pï¿½_Üšï¿½4!4ï¿½ï¿½>ï¿½.ï¿½nï¿½ï¿½ï¿½ï¿½@ï¿½"ï¿½Ö¤h5!A2ï¿½ï¿½=)Akï¿½ï¿½Æ¤`ï¿½?Aï¿½ï¿½p{Rï¿½ÈšIHï¿½9ÍœOï¿½%ï¿½ï¿½Gï¿½cH	ï¿½j2B\kDï¿½4ï¿½ï¿½ï¿½@ï¿½"ï¿½Qï¿½dï¿½Zï¿½ÈŒï¿½ï¿½ï¿½ psfï¿½uï¿½$5F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½ï¿½<ï¿½ï¿½é‚€Rï¿½bï¿½Hï¿½F@HÉƒ;_ï¿½.X!%+ï¿½ï¿½ï¿½Iï¿½`ï¿½3DEï¿½Aï¿½Xs    IENDï¿½B`ï¿½
--- END OF FILE draft/server/slash-command.png ---


--- START OF FILE draft/server/tools.mdx ---
---
title: Tools
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

The Model Context Protocol (MCP) allows servers to expose tools that can be invoked by
language models. Tools enable models to interact with external systems, such as querying
databases, calling APIs, or performing computations. Each tool is uniquely identified by
a name and includes metadata describing its schema.

## User Interaction Model

Tools in MCP are designed to be **model-controlled**, meaning that the language model can
discover and invoke tools automatically based on its contextual understanding and the
user's prompts.

However, implementations are free to expose tools through any interface pattern that
suits their needs&mdash;the protocol itself does not mandate any specific user
interaction model.

<Warning>

For trust & safety and security, there **SHOULD** always
be a human in the loop with the ability to deny tool invocations.

Applications **SHOULD**:

- Provide UI that makes clear which tools are being exposed to the AI model
- Insert clear visual indicators when tools are invoked
- Present confirmation prompts to the user for operations, to ensure a human is in the
  loop

</Warning>

## Capabilities

Servers that support tools **MUST** declare the `tools` capability:

```json
{
  "capabilities": {
    "tools": {
      "listChanged": true
    }
  }
}
```

`listChanged` indicates whether the server will emit notifications when the list of
available tools changes.

## Protocol Messages

### Listing Tools

To discover available tools, clients send a `tools/list` request. This operation supports
[pagination](/specification/draft/server/utilities/pagination).

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "get_weather",
        "title": "Weather Information Provider",
        "description": "Get current weather information for a location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "City name or zip code"
            }
          },
          "required": ["location"]
        }
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### Calling Tools

To invoke a tool, clients send a `tools/call` request:

**Request:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "get_weather",
    "arguments": {
      "location": "New York"
    }
  }
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Current weather in New York:\nTemperature: 72Â°F\nConditions: Partly cloudy"
      }
    ],
    "isError": false
  }
}
```

### List Changed Notification

When the list of available tools changes, servers that declared the `listChanged`
capability **SHOULD** send a notification:

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/list_changed"
}
```

## Message Flow

```mermaid
sequenceDiagram
    participant LLM
    participant Client
    participant Server

    Note over Client,Server: Discovery
    Client->>Server: tools/list
    Server-->>Client: List of tools

    Note over Client,LLM: Tool Selection
    LLM->>Client: Select tool to use

    Note over Client,Server: Invocation
    Client->>Server: tools/call
    Server-->>Client: Tool result
    Client->>LLM: Process result

    Note over Client,Server: Updates
    Server--)Client: tools/list_changed
    Client->>Server: tools/list
    Server-->>Client: Updated tools
```

## Data Types

### Tool

A tool definition includes:

- `name`: Unique identifier for the tool
- `title`: Optional human-readable name of the tool for display purposes.
- `description`: Human-readable description of functionality
- `inputSchema`: JSON Schema defining expected parameters
- `outputSchema`: Optional JSON Schema defining expected output structure
- `annotations`: optional properties describing tool behavior

<Warning>

For trust & safety and security, clients **MUST** consider
tool annotations to be untrusted unless they come from trusted servers.

</Warning>

### Tool Result

Tool results may contain [**structured**](#structured-content) or **unstructured** content.

**Unstructured** content is returned in the `content` field of a result, and can contain multiple content items of different types:

#### Text Content

```json
{
  "type": "text",
  "text": "Tool result text"
}
```

#### Image Content

```json
{
  "type": "image",
  "data": "base64-encoded-data",
  "mimeType": "image/png"
}
```

#### Audio Content

```json
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

#### Resource Links

A tool **MAY** return links to [Resources](/specification/draft/server/resources), to provide additional context
or data. In this case, the tool will return a URI that can be subscribed to or fetched by the client:

```json
{
  "type": "resource_link",
  "uri": "file:///project/src/main.rs",
  "name": "main.rs",
  "description": "Primary application entry point",
  "mimeType": "text/x-rust"
}
```

<Info>
  Resource links returned by tools are not guaranteed to appear in the results
  of a `resources/list` request.
</Info>

#### Embedded Resources

[Resources](/specification/draft/server/resources) **MAY** be embedded to provide additional context
or data using a suitable [URI scheme](./resources#common-uri-schemes). Servers that use embedded resources **SHOULD** implement the `resources` capability:

```json
{
  "type": "resource",
  "resource": {
    "uri": "file:///project/src/main.rs",
    "title": "Project Rust Main File",
    "mimeType": "text/x-rust",
    "text": "fn main() {\n    println!(\"Hello world!\");\n}"
  }
}
```

#### Structured Content

**Structured** content is returned as a JSON object in the `structuredContent` field of a result.

For backwards compatibility, a tool that returns structured content SHOULD also return functionally equivalent unstructured content.
(For example, serialized JSON can be returned in a `TextContent` block.)

#### Output Schema

Tools may also provide an output schema for validation of structured results.
If an output schema is provided:

- Servers **MUST** provide structured results that conform to this schema.
- Clients **SHOULD** validate structured results against this schema.

Example tool with output schema:

```json
{
  "name": "get_weather_data",
  "title": "Weather Data Retriever",
  "description": "Get current weather data for a location",
  "inputSchema": {
    "type": "object",
    "properties": {
      "location": {
        "type": "string",
        "description": "City name or zip code"
      }
    },
    "required": ["location"]
  },
  "outputSchema": {
    "type": "object",
    "properties": {
      "temperature": {
        "type": "number",
        "description": "Temperature in celsius"
      },
      "conditions": {
        "type": "string",
        "description": "Weather conditions description"
      },
      "humidity": {
        "type": "number",
        "description": "Humidity percentage"
      }
    },
    "required": ["temperature", "conditions", "humidity"]
  }
}
```

Example valid response for this tool:

```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "{\"temperature\": 22.5, \"conditions\": \"Partly cloudy\", \"humidity\": 65}"
      }
    ],
    "structuredContent": {
      "temperature": 22.5,
      "conditions": "Partly cloudy",
      "humidity": 65
    }
  }
}
```

Providing an output schema helps clients and LLMs understand and properly handle structured tool outputs by:

- Enabling strict schema validation of responses
- Providing type information for better integration with programming languages
- Guiding clients and LLMs to properly parse and utilize the returned data
- Supporting better documentation and developer experience

## Error Handling

Tools use two error reporting mechanisms:

1. **Protocol Errors**: Standard JSON-RPC errors for issues like:

   - Unknown tools
   - Invalid arguments
   - Server errors

2. **Tool Execution Errors**: Reported in tool results with `isError: true`:
   - API failures
   - Invalid input data
   - Business logic errors

Example protocol error:

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "error": {
    "code": -32602,
    "message": "Unknown tool: invalid_tool_name"
  }
}
```

Example tool execution error:

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Failed to fetch weather data: API rate limit exceeded"
      }
    ],
    "isError": true
  }
}
```

## Security Considerations

1. Servers **MUST**:

   - Validate all tool inputs
   - Implement proper access controls
   - Rate limit tool invocations
   - Sanitize tool outputs

2. Clients **SHOULD**:
   - Prompt for user confirmation on sensitive operations
   - Show tool inputs to the user before calling the server, to avoid malicious or
     accidental data exfiltration
   - Validate tool results before passing to LLM
   - Implement timeouts for tool calls
   - Log tool usage for audit purposes

--- END OF FILE draft/server/tools.mdx ---


--- START OF FILE draft/changelog.mdx ---
---
title: Key Changes
---

<div id="enable-section-numbers" />

This document lists changes made to the Model Context Protocol (MCP) specification since
the previous revision, [2025-06-18](/specification/2025-06-18).

## Major changes

## Other schema changes

## Full changelog

For a complete list of all changes that have been made since the last protocol revision,
[see GitHub](https://github.com/modelcontextprotocol/specification/compare/2025-06-18...draft).

--- END OF FILE draft/changelog.mdx ---


--- START OF FILE draft/index.mdx ---
---
title: Specification
---

<div id="enable-section-numbers" />

[Model Context Protocol](https://modelcontextprotocol.io) (MCP) is an open protocol that
enables seamless integration between LLM applications and external data sources and
tools. Whether you're building an AI-powered IDE, enhancing a chat interface, or creating
custom AI workflows, MCP provides a standardized way to connect LLMs with the context
they need.

This specification defines the authoritative protocol requirements, based on the
TypeScript schema in
[schema.ts](https://github.com/modelcontextprotocol/specification/blob/main/schema/draft/schema.ts).

For implementation guides and examples, visit
[modelcontextprotocol.io](https://modelcontextprotocol.io).

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [BCP 14](https://datatracker.ietf.org/doc/html/bcp14)
[[RFC2119](https://datatracker.ietf.org/doc/html/rfc2119)]
[[RFC8174](https://datatracker.ietf.org/doc/html/rfc8174)] when, and only when, they
appear in all capitals, as shown here.

## Overview

MCP provides a standardized way for applications to:

- Share contextual information with language models
- Expose tools and capabilities to AI systems
- Build composable integrations and workflows

The protocol uses [JSON-RPC](https://www.jsonrpc.org/) 2.0 messages to establish
communication between:

- **Hosts**: LLM applications that initiate connections
- **Clients**: Connectors within the host application
- **Servers**: Services that provide context and capabilities

MCP takes some inspiration from the
[Language Server Protocol](https://microsoft.github.io/language-server-protocol/), which
standardizes how to add support for programming languages across a whole ecosystem of
development tools. In a similar way, MCP standardizes how to integrate additional context
and tools into the ecosystem of AI applications.

## Key Details

### Base Protocol

- [JSON-RPC](https://www.jsonrpc.org/) message format
- Stateful connections
- Server and client capability negotiation

### Features

Servers offer any of the following features to clients:

- **Resources**: Context and data, for the user or the AI model to use
- **Prompts**: Templated messages and workflows for users
- **Tools**: Functions for the AI model to execute

Clients may offer the following features to servers:

- **Sampling**: Server-initiated agentic behaviors and recursive LLM interactions
- **Roots**: Server-initiated inquiries into uri or filesystem boundaries to operate in
- **Elicitation**: Server-initiated requests for additional information from users

### Additional Utilities

- Configuration
- Progress tracking
- Cancellation
- Error reporting
- Logging

## Security and Trust & Safety

The Model Context Protocol enables powerful capabilities through arbitrary data access
and code execution paths. With this power comes important security and trust
considerations that all implementors must carefully address.

### Key Principles

1. **User Consent and Control**

   - Users must explicitly consent to and understand all data access and operations
   - Users must retain control over what data is shared and what actions are taken
   - Implementors should provide clear UIs for reviewing and authorizing activities

2. **Data Privacy**

   - Hosts must obtain explicit user consent before exposing user data to servers
   - Hosts must not transmit resource data elsewhere without user consent
   - User data should be protected with appropriate access controls

3. **Tool Safety**

   - Tools represent arbitrary code execution and must be treated with appropriate
     caution.
     - In particular, descriptions of tool behavior such as annotations should be
       considered untrusted, unless obtained from a trusted server.
   - Hosts must obtain explicit user consent before invoking any tool
   - Users should understand what each tool does before authorizing its use

4. **LLM Sampling Controls**
   - Users must explicitly approve any LLM sampling requests
   - Users should control:
     - Whether sampling occurs at all
     - The actual prompt that will be sent
     - What results the server can see
   - The protocol intentionally limits server visibility into prompts

### Implementation Guidelines

While MCP itself cannot enforce these security principles at the protocol level,
implementors **SHOULD**:

1. Build robust consent and authorization flows into their applications
2. Provide clear documentation of security implications
3. Implement appropriate access controls and data protections
4. Follow security best practices in their integrations
5. Consider privacy implications in their feature designs

## Learn More

Explore the detailed specification for each protocol component:

<CardGroup cols={5}>
  <Card
    title="Architecture"
    icon="sitemap"
    href="/specification/draft/architecture"
  />
  <Card title="Base Protocol" icon="code" href="/specification/draft/basic" />
  <Card
    title="Server Features"
    icon="server"
    href="/specification/draft/server"
  />
  <Card
    title="Client Features"
    icon="user"
    href="/specification/draft/client"
  />
  <Card title="Contributing" icon="pencil" href="/development/contributing" />
</CardGroup>

--- END OF FILE draft/index.mdx ---


--- START OF FILE versioning.mdx ---
---
title: Versioning
type: docs
weight: 10
---

The Model Context Protocol uses string-based version identifiers following the format
`YYYY-MM-DD`, to indicate the last date backwards incompatible changes were made.

<Info>

The protocol version will _not_ be incremented when the
protocol is updated, as long as the changes maintain backwards compatibility. This allows
for incremental improvements while preserving interoperability.

</Info>

## Revisions

Revisions may be marked as:

- **Draft**: in-progress specifications, not yet ready for consumption.
- **Current**: the current protocol version, which is ready for use and may continue to
  receive backwards compatible changes.
- **Final**: past, complete specifications that will not be changed.

The **current** protocol version is [**2025-06-18**](/specification/2025-06-18/).

## Negotiation

Version negotiation happens during
[initialization](/specification/2025-06-18/basic/lifecycle#initialization). Clients and
servers **MAY** support multiple protocol versions simultaneously, but they **MUST**
agree on a single version to use for the session.

The protocol provides appropriate error handling if version negotiation fails, allowing
clients to gracefully terminate connections when they cannot find a version compatible
with the server.

--- END OF FILE versioning.mdx ---



--- PROJECT PACKAGING COMPLETE ---